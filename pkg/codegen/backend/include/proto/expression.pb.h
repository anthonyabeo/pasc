// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/expression.proto

#ifndef PROTOBUF_INCLUDED_proto_2fexpression_2eproto
#define PROTOBUF_INCLUDED_proto_2fexpression_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/type.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_proto_2fexpression_2eproto 

namespace protobuf_proto_2fexpression_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_proto_2fexpression_2eproto
namespace Pasc {
class BinaryExpr;
class BinaryExprDefaultTypeInternal;
extern BinaryExprDefaultTypeInternal _BinaryExpr_default_instance_;
class Expression;
class ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class FuncCall;
class FuncCallDefaultTypeInternal;
extern FuncCallDefaultTypeInternal _FuncCall_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Identifier_FieldDesignator;
class Identifier_FieldDesignatorDefaultTypeInternal;
extern Identifier_FieldDesignatorDefaultTypeInternal _Identifier_FieldDesignator_default_instance_;
class Identifier_IndexedVariable;
class Identifier_IndexedVariableDefaultTypeInternal;
extern Identifier_IndexedVariableDefaultTypeInternal _Identifier_IndexedVariable_default_instance_;
class Identifier_Variable;
class Identifier_VariableDefaultTypeInternal;
extern Identifier_VariableDefaultTypeInternal _Identifier_Variable_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
class UIntLiteral;
class UIntLiteralDefaultTypeInternal;
extern UIntLiteralDefaultTypeInternal _UIntLiteral_default_instance_;
class WriteParameter;
class WriteParameterDefaultTypeInternal;
extern WriteParameterDefaultTypeInternal _WriteParameter_default_instance_;
}  // namespace Pasc
namespace google {
namespace protobuf {
template<> ::Pasc::BinaryExpr* Arena::CreateMaybeMessage<::Pasc::BinaryExpr>(Arena*);
template<> ::Pasc::Expression* Arena::CreateMaybeMessage<::Pasc::Expression>(Arena*);
template<> ::Pasc::FuncCall* Arena::CreateMaybeMessage<::Pasc::FuncCall>(Arena*);
template<> ::Pasc::Identifier* Arena::CreateMaybeMessage<::Pasc::Identifier>(Arena*);
template<> ::Pasc::Identifier_FieldDesignator* Arena::CreateMaybeMessage<::Pasc::Identifier_FieldDesignator>(Arena*);
template<> ::Pasc::Identifier_IndexedVariable* Arena::CreateMaybeMessage<::Pasc::Identifier_IndexedVariable>(Arena*);
template<> ::Pasc::Identifier_Variable* Arena::CreateMaybeMessage<::Pasc::Identifier_Variable>(Arena*);
template<> ::Pasc::Operator* Arena::CreateMaybeMessage<::Pasc::Operator>(Arena*);
template<> ::Pasc::UIntLiteral* Arena::CreateMaybeMessage<::Pasc::UIntLiteral>(Arena*);
template<> ::Pasc::WriteParameter* Arena::CreateMaybeMessage<::Pasc::WriteParameter>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Pasc {

enum Identifier_IDKind {
  Identifier_IDKind_EntireVar = 0,
  Identifier_IDKind_IdxVar = 1,
  Identifier_IDKind_Field = 2,
  Identifier_IDKind_Identifier_IDKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Identifier_IDKind_Identifier_IDKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Identifier_IDKind_IsValid(int value);
const Identifier_IDKind Identifier_IDKind_IDKind_MIN = Identifier_IDKind_EntireVar;
const Identifier_IDKind Identifier_IDKind_IDKind_MAX = Identifier_IDKind_Field;
const int Identifier_IDKind_IDKind_ARRAYSIZE = Identifier_IDKind_IDKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Identifier_IDKind_descriptor();
inline const ::std::string& Identifier_IDKind_Name(Identifier_IDKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Identifier_IDKind_descriptor(), value);
}
inline bool Identifier_IDKind_Parse(
    const ::std::string& name, Identifier_IDKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Identifier_IDKind>(
    Identifier_IDKind_descriptor(), name, value);
}
enum Expression_ExprKind {
  Expression_ExprKind_UInt = 0,
  Expression_ExprKind_Bool = 1,
  Expression_ExprKind_Ident = 2,
  Expression_ExprKind_BinExpr = 3,
  Expression_ExprKind_WriteParam = 4,
  Expression_ExprKind_FCall = 5,
  Expression_ExprKind_Expression_ExprKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Expression_ExprKind_Expression_ExprKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Expression_ExprKind_IsValid(int value);
const Expression_ExprKind Expression_ExprKind_ExprKind_MIN = Expression_ExprKind_UInt;
const Expression_ExprKind Expression_ExprKind_ExprKind_MAX = Expression_ExprKind_FCall;
const int Expression_ExprKind_ExprKind_ARRAYSIZE = Expression_ExprKind_ExprKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_ExprKind_descriptor();
inline const ::std::string& Expression_ExprKind_Name(Expression_ExprKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_ExprKind_descriptor(), value);
}
inline bool Expression_ExprKind_Parse(
    const ::std::string& name, Expression_ExprKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_ExprKind>(
    Expression_ExprKind_descriptor(), name, value);
}
enum Operator_OpKind {
  Operator_OpKind_Plus = 0,
  Operator_OpKind_Minus = 1,
  Operator_OpKind_Div = 2,
  Operator_OpKind_Sub = 3,
  Operator_OpKind_Mod = 4,
  Operator_OpKind_And = 5,
  Operator_OpKind_Or = 6,
  Operator_OpKind_In = 7,
  Operator_OpKind_Equal = 8,
  Operator_OpKind_Less = 9,
  Operator_OpKind_Great = 10,
  Operator_OpKind_GreatEqual = 11,
  Operator_OpKind_Operator_OpKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Operator_OpKind_Operator_OpKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Operator_OpKind_IsValid(int value);
const Operator_OpKind Operator_OpKind_OpKind_MIN = Operator_OpKind_Plus;
const Operator_OpKind Operator_OpKind_OpKind_MAX = Operator_OpKind_GreatEqual;
const int Operator_OpKind_OpKind_ARRAYSIZE = Operator_OpKind_OpKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operator_OpKind_descriptor();
inline const ::std::string& Operator_OpKind_Name(Operator_OpKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operator_OpKind_descriptor(), value);
}
inline bool Operator_OpKind_Parse(
    const ::std::string& name, Operator_OpKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operator_OpKind>(
    Operator_OpKind_descriptor(), name, value);
}
// ===================================================================

class Identifier_Variable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.Variable) */ {
 public:
  Identifier_Variable();
  virtual ~Identifier_Variable();

  Identifier_Variable(const Identifier_Variable& from);

  inline Identifier_Variable& operator=(const Identifier_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_Variable(Identifier_Variable&& from) noexcept
    : Identifier_Variable() {
    *this = ::std::move(from);
  }

  inline Identifier_Variable& operator=(Identifier_Variable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_Variable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_Variable* internal_default_instance() {
    return reinterpret_cast<const Identifier_Variable*>(
               &_Identifier_Variable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Identifier_Variable* other);
  friend void swap(Identifier_Variable& a, Identifier_Variable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_Variable* New() const final {
    return CreateMaybeMessage<Identifier_Variable>(NULL);
  }

  Identifier_Variable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_Variable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_Variable& from);
  void MergeFrom(const Identifier_Variable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_Variable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.Variable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_IndexedVariable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.IndexedVariable) */ {
 public:
  Identifier_IndexedVariable();
  virtual ~Identifier_IndexedVariable();

  Identifier_IndexedVariable(const Identifier_IndexedVariable& from);

  inline Identifier_IndexedVariable& operator=(const Identifier_IndexedVariable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_IndexedVariable(Identifier_IndexedVariable&& from) noexcept
    : Identifier_IndexedVariable() {
    *this = ::std::move(from);
  }

  inline Identifier_IndexedVariable& operator=(Identifier_IndexedVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_IndexedVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_IndexedVariable* internal_default_instance() {
    return reinterpret_cast<const Identifier_IndexedVariable*>(
               &_Identifier_IndexedVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Identifier_IndexedVariable* other);
  friend void swap(Identifier_IndexedVariable& a, Identifier_IndexedVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_IndexedVariable* New() const final {
    return CreateMaybeMessage<Identifier_IndexedVariable>(NULL);
  }

  Identifier_IndexedVariable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_IndexedVariable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_IndexedVariable& from);
  void MergeFrom(const Identifier_IndexedVariable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_IndexedVariable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.IndexedVariable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_FieldDesignator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.FieldDesignator) */ {
 public:
  Identifier_FieldDesignator();
  virtual ~Identifier_FieldDesignator();

  Identifier_FieldDesignator(const Identifier_FieldDesignator& from);

  inline Identifier_FieldDesignator& operator=(const Identifier_FieldDesignator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_FieldDesignator(Identifier_FieldDesignator&& from) noexcept
    : Identifier_FieldDesignator() {
    *this = ::std::move(from);
  }

  inline Identifier_FieldDesignator& operator=(Identifier_FieldDesignator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_FieldDesignator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_FieldDesignator* internal_default_instance() {
    return reinterpret_cast<const Identifier_FieldDesignator*>(
               &_Identifier_FieldDesignator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Identifier_FieldDesignator* other);
  friend void swap(Identifier_FieldDesignator& a, Identifier_FieldDesignator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_FieldDesignator* New() const final {
    return CreateMaybeMessage<Identifier_FieldDesignator>(NULL);
  }

  Identifier_FieldDesignator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_FieldDesignator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_FieldDesignator& from);
  void MergeFrom(const Identifier_FieldDesignator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_FieldDesignator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.FieldDesignator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  enum ValueCase {
    kVar = 2,
    kIv = 3,
    kFld = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(NULL);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Identifier_Variable Variable;
  typedef Identifier_IndexedVariable IndexedVariable;
  typedef Identifier_FieldDesignator FieldDesignator;

  typedef Identifier_IDKind IDKind;
  static const IDKind EntireVar =
    Identifier_IDKind_EntireVar;
  static const IDKind IdxVar =
    Identifier_IDKind_IdxVar;
  static const IDKind Field =
    Identifier_IDKind_Field;
  static inline bool IDKind_IsValid(int value) {
    return Identifier_IDKind_IsValid(value);
  }
  static const IDKind IDKind_MIN =
    Identifier_IDKind_IDKind_MIN;
  static const IDKind IDKind_MAX =
    Identifier_IDKind_IDKind_MAX;
  static const int IDKind_ARRAYSIZE =
    Identifier_IDKind_IDKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IDKind_descriptor() {
    return Identifier_IDKind_descriptor();
  }
  static inline const ::std::string& IDKind_Name(IDKind value) {
    return Identifier_IDKind_Name(value);
  }
  static inline bool IDKind_Parse(const ::std::string& name,
      IDKind* value) {
    return Identifier_IDKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Identifier.IDKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Identifier_IDKind kind() const;
  void set_kind(::Pasc::Identifier_IDKind value);

  // .Pasc.Identifier.Variable var = 2;
  bool has_var() const;
  void clear_var();
  static const int kVarFieldNumber = 2;
  private:
  const ::Pasc::Identifier_Variable& _internal_var() const;
  public:
  const ::Pasc::Identifier_Variable& var() const;
  ::Pasc::Identifier_Variable* release_var();
  ::Pasc::Identifier_Variable* mutable_var();
  void set_allocated_var(::Pasc::Identifier_Variable* var);

  // .Pasc.Identifier.IndexedVariable iv = 3;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 3;
  private:
  const ::Pasc::Identifier_IndexedVariable& _internal_iv() const;
  public:
  const ::Pasc::Identifier_IndexedVariable& iv() const;
  ::Pasc::Identifier_IndexedVariable* release_iv();
  ::Pasc::Identifier_IndexedVariable* mutable_iv();
  void set_allocated_iv(::Pasc::Identifier_IndexedVariable* iv);

  // .Pasc.Identifier.FieldDesignator fld = 4;
  bool has_fld() const;
  void clear_fld();
  static const int kFldFieldNumber = 4;
  private:
  const ::Pasc::Identifier_FieldDesignator& _internal_fld() const;
  public:
  const ::Pasc::Identifier_FieldDesignator& fld() const;
  ::Pasc::Identifier_FieldDesignator* release_fld();
  ::Pasc::Identifier_FieldDesignator* mutable_fld();
  void set_allocated_fld(::Pasc::Identifier_FieldDesignator* fld);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Identifier)
 private:
  void set_has_var();
  void set_has_iv();
  void set_has_fld();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union ValueUnion {
    ValueUnion() {}
    ::Pasc::Identifier_Variable* var_;
    ::Pasc::Identifier_IndexedVariable* iv_;
    ::Pasc::Identifier_FieldDesignator* fld_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(Expression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  enum ExprCase {
    kId = 2,
    kUint = 3,
    kBe = 4,
    kWp = 5,
    kFc = 6,
    EXPR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Expression* other);
  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression* New() const final {
    return CreateMaybeMessage<Expression>(NULL);
  }

  Expression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_ExprKind ExprKind;
  static const ExprKind UInt =
    Expression_ExprKind_UInt;
  static const ExprKind Bool =
    Expression_ExprKind_Bool;
  static const ExprKind Ident =
    Expression_ExprKind_Ident;
  static const ExprKind BinExpr =
    Expression_ExprKind_BinExpr;
  static const ExprKind WriteParam =
    Expression_ExprKind_WriteParam;
  static const ExprKind FCall =
    Expression_ExprKind_FCall;
  static inline bool ExprKind_IsValid(int value) {
    return Expression_ExprKind_IsValid(value);
  }
  static const ExprKind ExprKind_MIN =
    Expression_ExprKind_ExprKind_MIN;
  static const ExprKind ExprKind_MAX =
    Expression_ExprKind_ExprKind_MAX;
  static const int ExprKind_ARRAYSIZE =
    Expression_ExprKind_ExprKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExprKind_descriptor() {
    return Expression_ExprKind_descriptor();
  }
  static inline const ::std::string& ExprKind_Name(ExprKind value) {
    return Expression_ExprKind_Name(value);
  }
  static inline bool ExprKind_Parse(const ::std::string& name,
      ExprKind* value) {
    return Expression_ExprKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Expression.ExprKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Expression_ExprKind kind() const;
  void set_kind(::Pasc::Expression_ExprKind value);

  // .Pasc.Identifier id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  private:
  const ::Pasc::Identifier& _internal_id() const;
  public:
  const ::Pasc::Identifier& id() const;
  ::Pasc::Identifier* release_id();
  ::Pasc::Identifier* mutable_id();
  void set_allocated_id(::Pasc::Identifier* id);

  // .Pasc.UIntLiteral uint = 3;
  bool has_uint() const;
  void clear_uint();
  static const int kUintFieldNumber = 3;
  private:
  const ::Pasc::UIntLiteral& _internal_uint() const;
  public:
  const ::Pasc::UIntLiteral& uint() const;
  ::Pasc::UIntLiteral* release_uint();
  ::Pasc::UIntLiteral* mutable_uint();
  void set_allocated_uint(::Pasc::UIntLiteral* uint);

  // .Pasc.BinaryExpr be = 4;
  bool has_be() const;
  void clear_be();
  static const int kBeFieldNumber = 4;
  private:
  const ::Pasc::BinaryExpr& _internal_be() const;
  public:
  const ::Pasc::BinaryExpr& be() const;
  ::Pasc::BinaryExpr* release_be();
  ::Pasc::BinaryExpr* mutable_be();
  void set_allocated_be(::Pasc::BinaryExpr* be);

  // .Pasc.WriteParameter wp = 5;
  bool has_wp() const;
  void clear_wp();
  static const int kWpFieldNumber = 5;
  private:
  const ::Pasc::WriteParameter& _internal_wp() const;
  public:
  const ::Pasc::WriteParameter& wp() const;
  ::Pasc::WriteParameter* release_wp();
  ::Pasc::WriteParameter* mutable_wp();
  void set_allocated_wp(::Pasc::WriteParameter* wp);

  // .Pasc.FuncCall fc = 6;
  bool has_fc() const;
  void clear_fc();
  static const int kFcFieldNumber = 6;
  private:
  const ::Pasc::FuncCall& _internal_fc() const;
  public:
  const ::Pasc::FuncCall& fc() const;
  ::Pasc::FuncCall* release_fc();
  ::Pasc::FuncCall* mutable_fc();
  void set_allocated_fc(::Pasc::FuncCall* fc);

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Expression)
 private:
  void set_has_id();
  void set_has_uint();
  void set_has_be();
  void set_has_wp();
  void set_has_fc();

  inline bool has_expr() const;
  inline void clear_has_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union ExprUnion {
    ExprUnion() {}
    ::Pasc::Identifier* id_;
    ::Pasc::UIntLiteral* uint_;
    ::Pasc::BinaryExpr* be_;
    ::Pasc::WriteParameter* wp_;
    ::Pasc::FuncCall* fc_;
  } expr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.WriteParameter) */ {
 public:
  WriteParameter();
  virtual ~WriteParameter();

  WriteParameter(const WriteParameter& from);

  inline WriteParameter& operator=(const WriteParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteParameter(WriteParameter&& from) noexcept
    : WriteParameter() {
    *this = ::std::move(from);
  }

  inline WriteParameter& operator=(WriteParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteParameter* internal_default_instance() {
    return reinterpret_cast<const WriteParameter*>(
               &_WriteParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(WriteParameter* other);
  friend void swap(WriteParameter& a, WriteParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteParameter* New() const final {
    return CreateMaybeMessage<WriteParameter>(NULL);
  }

  WriteParameter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteParameter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteParameter& from);
  void MergeFrom(const WriteParameter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression e = 1;
  bool has_e() const;
  void clear_e();
  static const int kEFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_e() const;
  public:
  const ::Pasc::Expression& e() const;
  ::Pasc::Expression* release_e();
  ::Pasc::Expression* mutable_e();
  void set_allocated_e(::Pasc::Expression* e);

  // .Pasc.Expression totalWidth = 2;
  bool has_totalwidth() const;
  void clear_totalwidth();
  static const int kTotalWidthFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_totalwidth() const;
  public:
  const ::Pasc::Expression& totalwidth() const;
  ::Pasc::Expression* release_totalwidth();
  ::Pasc::Expression* mutable_totalwidth();
  void set_allocated_totalwidth(::Pasc::Expression* totalwidth);

  // .Pasc.Expression fracDigits = 3;
  bool has_fracdigits() const;
  void clear_fracdigits();
  static const int kFracDigitsFieldNumber = 3;
  private:
  const ::Pasc::Expression& _internal_fracdigits() const;
  public:
  const ::Pasc::Expression& fracdigits() const;
  ::Pasc::Expression* release_fracdigits();
  ::Pasc::Expression* mutable_fracdigits();
  void set_allocated_fracdigits(::Pasc::Expression* fracdigits);

  // @@protoc_insertion_point(class_scope:Pasc.WriteParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* e_;
  ::Pasc::Expression* totalwidth_;
  ::Pasc::Expression* fracdigits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinaryExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.BinaryExpr) */ {
 public:
  BinaryExpr();
  virtual ~BinaryExpr();

  BinaryExpr(const BinaryExpr& from);

  inline BinaryExpr& operator=(const BinaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinaryExpr(BinaryExpr&& from) noexcept
    : BinaryExpr() {
    *this = ::std::move(from);
  }

  inline BinaryExpr& operator=(BinaryExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryExpr*>(
               &_BinaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(BinaryExpr* other);
  friend void swap(BinaryExpr& a, BinaryExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinaryExpr* New() const final {
    return CreateMaybeMessage<BinaryExpr>(NULL);
  }

  BinaryExpr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinaryExpr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinaryExpr& from);
  void MergeFrom(const BinaryExpr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_left() const;
  public:
  const ::Pasc::Expression& left() const;
  ::Pasc::Expression* release_left();
  ::Pasc::Expression* mutable_left();
  void set_allocated_left(::Pasc::Expression* left);

  // .Pasc.Expression right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_right() const;
  public:
  const ::Pasc::Expression& right() const;
  ::Pasc::Expression* release_right();
  ::Pasc::Expression* mutable_right();
  void set_allocated_right(::Pasc::Expression* right);

  // .Pasc.Operator op = 3;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 3;
  private:
  const ::Pasc::Operator& _internal_op() const;
  public:
  const ::Pasc::Operator& op() const;
  ::Pasc::Operator* release_op();
  ::Pasc::Operator* mutable_op();
  void set_allocated_op(::Pasc::Operator* op);

  // @@protoc_insertion_point(class_scope:Pasc.BinaryExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* left_;
  ::Pasc::Expression* right_;
  ::Pasc::Operator* op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UIntLiteral : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.UIntLiteral) */ {
 public:
  UIntLiteral();
  virtual ~UIntLiteral();

  UIntLiteral(const UIntLiteral& from);

  inline UIntLiteral& operator=(const UIntLiteral& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UIntLiteral(UIntLiteral&& from) noexcept
    : UIntLiteral() {
    *this = ::std::move(from);
  }

  inline UIntLiteral& operator=(UIntLiteral&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UIntLiteral& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UIntLiteral* internal_default_instance() {
    return reinterpret_cast<const UIntLiteral*>(
               &_UIntLiteral_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UIntLiteral* other);
  friend void swap(UIntLiteral& a, UIntLiteral& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UIntLiteral* New() const final {
    return CreateMaybeMessage<UIntLiteral>(NULL);
  }

  UIntLiteral* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UIntLiteral>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UIntLiteral& from);
  void MergeFrom(const UIntLiteral& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIntLiteral* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Pasc.UIntLiteral)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FuncCall : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.FuncCall) */ {
 public:
  FuncCall();
  virtual ~FuncCall();

  FuncCall(const FuncCall& from);

  inline FuncCall& operator=(const FuncCall& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FuncCall(FuncCall&& from) noexcept
    : FuncCall() {
    *this = ::std::move(from);
  }

  inline FuncCall& operator=(FuncCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FuncCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FuncCall* internal_default_instance() {
    return reinterpret_cast<const FuncCall*>(
               &_FuncCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(FuncCall* other);
  friend void swap(FuncCall& a, FuncCall& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FuncCall* New() const final {
    return CreateMaybeMessage<FuncCall>(NULL);
  }

  FuncCall* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FuncCall>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FuncCall& from);
  void MergeFrom(const FuncCall& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FuncCall* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression args = 2;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 2;
  ::Pasc::Expression* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_args();
  const ::Pasc::Expression& args(int index) const;
  ::Pasc::Expression* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      args() const;

  // .Pasc.Expression name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_name() const;
  public:
  const ::Pasc::Expression& name() const;
  ::Pasc::Expression* release_name();
  ::Pasc::Expression* mutable_name();
  void set_allocated_name(::Pasc::Expression* name);

  // .Pasc.Type returnType = 3;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 3;
  private:
  const ::Pasc::Type& _internal_returntype() const;
  public:
  const ::Pasc::Type& returntype() const;
  ::Pasc::Type* release_returntype();
  ::Pasc::Type* mutable_returntype();
  void set_allocated_returntype(::Pasc::Type* returntype);

  // @@protoc_insertion_point(class_scope:Pasc.FuncCall)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > args_;
  ::Pasc::Expression* name_;
  ::Pasc::Type* returntype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Operator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Operator) */ {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(Operator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Operator* other);
  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operator* New() const final {
    return CreateMaybeMessage<Operator>(NULL);
  }

  Operator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Operator_OpKind OpKind;
  static const OpKind Plus =
    Operator_OpKind_Plus;
  static const OpKind Minus =
    Operator_OpKind_Minus;
  static const OpKind Div =
    Operator_OpKind_Div;
  static const OpKind Sub =
    Operator_OpKind_Sub;
  static const OpKind Mod =
    Operator_OpKind_Mod;
  static const OpKind And =
    Operator_OpKind_And;
  static const OpKind Or =
    Operator_OpKind_Or;
  static const OpKind In =
    Operator_OpKind_In;
  static const OpKind Equal =
    Operator_OpKind_Equal;
  static const OpKind Less =
    Operator_OpKind_Less;
  static const OpKind Great =
    Operator_OpKind_Great;
  static const OpKind GreatEqual =
    Operator_OpKind_GreatEqual;
  static inline bool OpKind_IsValid(int value) {
    return Operator_OpKind_IsValid(value);
  }
  static const OpKind OpKind_MIN =
    Operator_OpKind_OpKind_MIN;
  static const OpKind OpKind_MAX =
    Operator_OpKind_OpKind_MAX;
  static const int OpKind_ARRAYSIZE =
    Operator_OpKind_OpKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpKind_descriptor() {
    return Operator_OpKind_descriptor();
  }
  static inline const ::std::string& OpKind_Name(OpKind value) {
    return Operator_OpKind_Name(value);
  }
  static inline bool OpKind_Parse(const ::std::string& name,
      OpKind* value) {
    return Operator_OpKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Operator.OpKind op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::Pasc::Operator_OpKind op() const;
  void set_op(::Pasc::Operator_OpKind value);

  // @@protoc_insertion_point(class_scope:Pasc.Operator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fexpression_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Identifier_Variable

// string name = 1;
inline void Identifier_Variable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier_Variable::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.Variable.name)
  return name_.GetNoArena();
}
inline void Identifier_Variable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Identifier.Variable.name)
}
#if LANG_CXX11
inline void Identifier_Variable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Identifier.Variable.name)
}
#endif
inline void Identifier_Variable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Identifier.Variable.name)
}
inline void Identifier_Variable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Identifier.Variable.name)
}
inline ::std::string* Identifier_Variable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.Variable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier_Variable::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.Variable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier_Variable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Identifier.Variable.name)
}

// -------------------------------------------------------------------

// Identifier_IndexedVariable

// -------------------------------------------------------------------

// Identifier_FieldDesignator

// -------------------------------------------------------------------

// Identifier

// .Pasc.Identifier.IDKind kind = 1;
inline void Identifier::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Identifier_IDKind Identifier::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.kind)
  return static_cast< ::Pasc::Identifier_IDKind >(kind_);
}
inline void Identifier::set_kind(::Pasc::Identifier_IDKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Identifier.kind)
}

// .Pasc.Identifier.Variable var = 2;
inline bool Identifier::has_var() const {
  return value_case() == kVar;
}
inline void Identifier::set_has_var() {
  _oneof_case_[0] = kVar;
}
inline void Identifier::clear_var() {
  if (has_var()) {
    delete value_.var_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_Variable& Identifier::_internal_var() const {
  return *value_.var_;
}
inline ::Pasc::Identifier_Variable* Identifier::release_var() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.var)
  if (has_var()) {
    clear_has_value();
      ::Pasc::Identifier_Variable* temp = value_.var_;
    value_.var_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_Variable& Identifier::var() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.var)
  return has_var()
      ? *value_.var_
      : *reinterpret_cast< ::Pasc::Identifier_Variable*>(&::Pasc::_Identifier_Variable_default_instance_);
}
inline ::Pasc::Identifier_Variable* Identifier::mutable_var() {
  if (!has_var()) {
    clear_value();
    set_has_var();
    value_.var_ = CreateMaybeMessage< ::Pasc::Identifier_Variable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.var)
  return value_.var_;
}

// .Pasc.Identifier.IndexedVariable iv = 3;
inline bool Identifier::has_iv() const {
  return value_case() == kIv;
}
inline void Identifier::set_has_iv() {
  _oneof_case_[0] = kIv;
}
inline void Identifier::clear_iv() {
  if (has_iv()) {
    delete value_.iv_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_IndexedVariable& Identifier::_internal_iv() const {
  return *value_.iv_;
}
inline ::Pasc::Identifier_IndexedVariable* Identifier::release_iv() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.iv)
  if (has_iv()) {
    clear_has_value();
      ::Pasc::Identifier_IndexedVariable* temp = value_.iv_;
    value_.iv_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_IndexedVariable& Identifier::iv() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.iv)
  return has_iv()
      ? *value_.iv_
      : *reinterpret_cast< ::Pasc::Identifier_IndexedVariable*>(&::Pasc::_Identifier_IndexedVariable_default_instance_);
}
inline ::Pasc::Identifier_IndexedVariable* Identifier::mutable_iv() {
  if (!has_iv()) {
    clear_value();
    set_has_iv();
    value_.iv_ = CreateMaybeMessage< ::Pasc::Identifier_IndexedVariable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.iv)
  return value_.iv_;
}

// .Pasc.Identifier.FieldDesignator fld = 4;
inline bool Identifier::has_fld() const {
  return value_case() == kFld;
}
inline void Identifier::set_has_fld() {
  _oneof_case_[0] = kFld;
}
inline void Identifier::clear_fld() {
  if (has_fld()) {
    delete value_.fld_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_FieldDesignator& Identifier::_internal_fld() const {
  return *value_.fld_;
}
inline ::Pasc::Identifier_FieldDesignator* Identifier::release_fld() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.fld)
  if (has_fld()) {
    clear_has_value();
      ::Pasc::Identifier_FieldDesignator* temp = value_.fld_;
    value_.fld_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_FieldDesignator& Identifier::fld() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.fld)
  return has_fld()
      ? *value_.fld_
      : *reinterpret_cast< ::Pasc::Identifier_FieldDesignator*>(&::Pasc::_Identifier_FieldDesignator_default_instance_);
}
inline ::Pasc::Identifier_FieldDesignator* Identifier::mutable_fld() {
  if (!has_fld()) {
    clear_value();
    set_has_fld();
    value_.fld_ = CreateMaybeMessage< ::Pasc::Identifier_FieldDesignator >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.fld)
  return value_.fld_;
}

inline bool Identifier::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Identifier::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Identifier::ValueCase Identifier::value_case() const {
  return Identifier::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression

// .Pasc.Expression.ExprKind kind = 1;
inline void Expression::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Expression_ExprKind Expression::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.kind)
  return static_cast< ::Pasc::Expression_ExprKind >(kind_);
}
inline void Expression::set_kind(::Pasc::Expression_ExprKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Expression.kind)
}

// .Pasc.Identifier id = 2;
inline bool Expression::has_id() const {
  return expr_case() == kId;
}
inline void Expression::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void Expression::clear_id() {
  if (has_id()) {
    delete expr_.id_;
    clear_has_expr();
  }
}
inline const ::Pasc::Identifier& Expression::_internal_id() const {
  return *expr_.id_;
}
inline ::Pasc::Identifier* Expression::release_id() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.id)
  if (has_id()) {
    clear_has_expr();
      ::Pasc::Identifier* temp = expr_.id_;
    expr_.id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier& Expression::id() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.id)
  return has_id()
      ? *expr_.id_
      : *reinterpret_cast< ::Pasc::Identifier*>(&::Pasc::_Identifier_default_instance_);
}
inline ::Pasc::Identifier* Expression::mutable_id() {
  if (!has_id()) {
    clear_expr();
    set_has_id();
    expr_.id_ = CreateMaybeMessage< ::Pasc::Identifier >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.id)
  return expr_.id_;
}

// .Pasc.UIntLiteral uint = 3;
inline bool Expression::has_uint() const {
  return expr_case() == kUint;
}
inline void Expression::set_has_uint() {
  _oneof_case_[0] = kUint;
}
inline void Expression::clear_uint() {
  if (has_uint()) {
    delete expr_.uint_;
    clear_has_expr();
  }
}
inline const ::Pasc::UIntLiteral& Expression::_internal_uint() const {
  return *expr_.uint_;
}
inline ::Pasc::UIntLiteral* Expression::release_uint() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.uint)
  if (has_uint()) {
    clear_has_expr();
      ::Pasc::UIntLiteral* temp = expr_.uint_;
    expr_.uint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::UIntLiteral& Expression::uint() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.uint)
  return has_uint()
      ? *expr_.uint_
      : *reinterpret_cast< ::Pasc::UIntLiteral*>(&::Pasc::_UIntLiteral_default_instance_);
}
inline ::Pasc::UIntLiteral* Expression::mutable_uint() {
  if (!has_uint()) {
    clear_expr();
    set_has_uint();
    expr_.uint_ = CreateMaybeMessage< ::Pasc::UIntLiteral >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.uint)
  return expr_.uint_;
}

// .Pasc.BinaryExpr be = 4;
inline bool Expression::has_be() const {
  return expr_case() == kBe;
}
inline void Expression::set_has_be() {
  _oneof_case_[0] = kBe;
}
inline void Expression::clear_be() {
  if (has_be()) {
    delete expr_.be_;
    clear_has_expr();
  }
}
inline const ::Pasc::BinaryExpr& Expression::_internal_be() const {
  return *expr_.be_;
}
inline ::Pasc::BinaryExpr* Expression::release_be() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.be)
  if (has_be()) {
    clear_has_expr();
      ::Pasc::BinaryExpr* temp = expr_.be_;
    expr_.be_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::BinaryExpr& Expression::be() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.be)
  return has_be()
      ? *expr_.be_
      : *reinterpret_cast< ::Pasc::BinaryExpr*>(&::Pasc::_BinaryExpr_default_instance_);
}
inline ::Pasc::BinaryExpr* Expression::mutable_be() {
  if (!has_be()) {
    clear_expr();
    set_has_be();
    expr_.be_ = CreateMaybeMessage< ::Pasc::BinaryExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.be)
  return expr_.be_;
}

// .Pasc.WriteParameter wp = 5;
inline bool Expression::has_wp() const {
  return expr_case() == kWp;
}
inline void Expression::set_has_wp() {
  _oneof_case_[0] = kWp;
}
inline void Expression::clear_wp() {
  if (has_wp()) {
    delete expr_.wp_;
    clear_has_expr();
  }
}
inline const ::Pasc::WriteParameter& Expression::_internal_wp() const {
  return *expr_.wp_;
}
inline ::Pasc::WriteParameter* Expression::release_wp() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.wp)
  if (has_wp()) {
    clear_has_expr();
      ::Pasc::WriteParameter* temp = expr_.wp_;
    expr_.wp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::WriteParameter& Expression::wp() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.wp)
  return has_wp()
      ? *expr_.wp_
      : *reinterpret_cast< ::Pasc::WriteParameter*>(&::Pasc::_WriteParameter_default_instance_);
}
inline ::Pasc::WriteParameter* Expression::mutable_wp() {
  if (!has_wp()) {
    clear_expr();
    set_has_wp();
    expr_.wp_ = CreateMaybeMessage< ::Pasc::WriteParameter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.wp)
  return expr_.wp_;
}

// .Pasc.FuncCall fc = 6;
inline bool Expression::has_fc() const {
  return expr_case() == kFc;
}
inline void Expression::set_has_fc() {
  _oneof_case_[0] = kFc;
}
inline void Expression::clear_fc() {
  if (has_fc()) {
    delete expr_.fc_;
    clear_has_expr();
  }
}
inline const ::Pasc::FuncCall& Expression::_internal_fc() const {
  return *expr_.fc_;
}
inline ::Pasc::FuncCall* Expression::release_fc() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.fc)
  if (has_fc()) {
    clear_has_expr();
      ::Pasc::FuncCall* temp = expr_.fc_;
    expr_.fc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::FuncCall& Expression::fc() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.fc)
  return has_fc()
      ? *expr_.fc_
      : *reinterpret_cast< ::Pasc::FuncCall*>(&::Pasc::_FuncCall_default_instance_);
}
inline ::Pasc::FuncCall* Expression::mutable_fc() {
  if (!has_fc()) {
    clear_expr();
    set_has_fc();
    expr_.fc_ = CreateMaybeMessage< ::Pasc::FuncCall >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.fc)
  return expr_.fc_;
}

inline bool Expression::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void Expression::clear_has_expr() {
  _oneof_case_[0] = EXPR_NOT_SET;
}
inline Expression::ExprCase Expression::expr_case() const {
  return Expression::ExprCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteParameter

// .Pasc.Expression e = 1;
inline bool WriteParameter::has_e() const {
  return this != internal_default_instance() && e_ != NULL;
}
inline void WriteParameter::clear_e() {
  if (GetArenaNoVirtual() == NULL && e_ != NULL) {
    delete e_;
  }
  e_ = NULL;
}
inline const ::Pasc::Expression& WriteParameter::_internal_e() const {
  return *e_;
}
inline const ::Pasc::Expression& WriteParameter::e() const {
  const ::Pasc::Expression* p = e_;
  // @@protoc_insertion_point(field_get:Pasc.WriteParameter.e)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* WriteParameter::release_e() {
  // @@protoc_insertion_point(field_release:Pasc.WriteParameter.e)
  
  ::Pasc::Expression* temp = e_;
  e_ = NULL;
  return temp;
}
inline ::Pasc::Expression* WriteParameter::mutable_e() {
  
  if (e_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    e_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WriteParameter.e)
  return e_;
}
inline void WriteParameter::set_allocated_e(::Pasc::Expression* e) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete e_;
  }
  if (e) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      e = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, e, submessage_arena);
    }
    
  } else {
    
  }
  e_ = e;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WriteParameter.e)
}

// .Pasc.Expression totalWidth = 2;
inline bool WriteParameter::has_totalwidth() const {
  return this != internal_default_instance() && totalwidth_ != NULL;
}
inline void WriteParameter::clear_totalwidth() {
  if (GetArenaNoVirtual() == NULL && totalwidth_ != NULL) {
    delete totalwidth_;
  }
  totalwidth_ = NULL;
}
inline const ::Pasc::Expression& WriteParameter::_internal_totalwidth() const {
  return *totalwidth_;
}
inline const ::Pasc::Expression& WriteParameter::totalwidth() const {
  const ::Pasc::Expression* p = totalwidth_;
  // @@protoc_insertion_point(field_get:Pasc.WriteParameter.totalWidth)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* WriteParameter::release_totalwidth() {
  // @@protoc_insertion_point(field_release:Pasc.WriteParameter.totalWidth)
  
  ::Pasc::Expression* temp = totalwidth_;
  totalwidth_ = NULL;
  return temp;
}
inline ::Pasc::Expression* WriteParameter::mutable_totalwidth() {
  
  if (totalwidth_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    totalwidth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WriteParameter.totalWidth)
  return totalwidth_;
}
inline void WriteParameter::set_allocated_totalwidth(::Pasc::Expression* totalwidth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete totalwidth_;
  }
  if (totalwidth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      totalwidth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totalwidth, submessage_arena);
    }
    
  } else {
    
  }
  totalwidth_ = totalwidth;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WriteParameter.totalWidth)
}

// .Pasc.Expression fracDigits = 3;
inline bool WriteParameter::has_fracdigits() const {
  return this != internal_default_instance() && fracdigits_ != NULL;
}
inline void WriteParameter::clear_fracdigits() {
  if (GetArenaNoVirtual() == NULL && fracdigits_ != NULL) {
    delete fracdigits_;
  }
  fracdigits_ = NULL;
}
inline const ::Pasc::Expression& WriteParameter::_internal_fracdigits() const {
  return *fracdigits_;
}
inline const ::Pasc::Expression& WriteParameter::fracdigits() const {
  const ::Pasc::Expression* p = fracdigits_;
  // @@protoc_insertion_point(field_get:Pasc.WriteParameter.fracDigits)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* WriteParameter::release_fracdigits() {
  // @@protoc_insertion_point(field_release:Pasc.WriteParameter.fracDigits)
  
  ::Pasc::Expression* temp = fracdigits_;
  fracdigits_ = NULL;
  return temp;
}
inline ::Pasc::Expression* WriteParameter::mutable_fracdigits() {
  
  if (fracdigits_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    fracdigits_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WriteParameter.fracDigits)
  return fracdigits_;
}
inline void WriteParameter::set_allocated_fracdigits(::Pasc::Expression* fracdigits) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fracdigits_;
  }
  if (fracdigits) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fracdigits = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fracdigits, submessage_arena);
    }
    
  } else {
    
  }
  fracdigits_ = fracdigits;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WriteParameter.fracDigits)
}

// -------------------------------------------------------------------

// BinaryExpr

// .Pasc.Expression left = 1;
inline bool BinaryExpr::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void BinaryExpr::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::Pasc::Expression& BinaryExpr::_internal_left() const {
  return *left_;
}
inline const ::Pasc::Expression& BinaryExpr::left() const {
  const ::Pasc::Expression* p = left_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.left)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* BinaryExpr::release_left() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.left)
  
  ::Pasc::Expression* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::Pasc::Expression* BinaryExpr::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.left)
  return left_;
}
inline void BinaryExpr::set_allocated_left(::Pasc::Expression* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.left)
}

// .Pasc.Expression right = 2;
inline bool BinaryExpr::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void BinaryExpr::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::Pasc::Expression& BinaryExpr::_internal_right() const {
  return *right_;
}
inline const ::Pasc::Expression& BinaryExpr::right() const {
  const ::Pasc::Expression* p = right_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.right)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* BinaryExpr::release_right() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.right)
  
  ::Pasc::Expression* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::Pasc::Expression* BinaryExpr::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.right)
  return right_;
}
inline void BinaryExpr::set_allocated_right(::Pasc::Expression* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.right)
}

// .Pasc.Operator op = 3;
inline bool BinaryExpr::has_op() const {
  return this != internal_default_instance() && op_ != NULL;
}
inline void BinaryExpr::clear_op() {
  if (GetArenaNoVirtual() == NULL && op_ != NULL) {
    delete op_;
  }
  op_ = NULL;
}
inline const ::Pasc::Operator& BinaryExpr::_internal_op() const {
  return *op_;
}
inline const ::Pasc::Operator& BinaryExpr::op() const {
  const ::Pasc::Operator* p = op_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.op)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Operator*>(
      &::Pasc::_Operator_default_instance_);
}
inline ::Pasc::Operator* BinaryExpr::release_op() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.op)
  
  ::Pasc::Operator* temp = op_;
  op_ = NULL;
  return temp;
}
inline ::Pasc::Operator* BinaryExpr::mutable_op() {
  
  if (op_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Operator>(GetArenaNoVirtual());
    op_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.op)
  return op_;
}
inline void BinaryExpr::set_allocated_op(::Pasc::Operator* op) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete op_;
  }
  if (op) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      op = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.op)
}

// -------------------------------------------------------------------

// UIntLiteral

// uint32 value = 1;
inline void UIntLiteral::clear_value() {
  value_ = 0u;
}
inline ::google::protobuf::uint32 UIntLiteral::value() const {
  // @@protoc_insertion_point(field_get:Pasc.UIntLiteral.value)
  return value_;
}
inline void UIntLiteral::set_value(::google::protobuf::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Pasc.UIntLiteral.value)
}

// -------------------------------------------------------------------

// FuncCall

// .Pasc.Expression name = 1;
inline bool FuncCall::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void FuncCall::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Expression& FuncCall::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Expression& FuncCall::name() const {
  const ::Pasc::Expression* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.FuncCall.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* FuncCall::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.FuncCall.name)
  
  ::Pasc::Expression* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Expression* FuncCall::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FuncCall.name)
  return name_;
}
inline void FuncCall::set_allocated_name(::Pasc::Expression* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncCall.name)
}

// repeated .Pasc.Expression args = 2;
inline int FuncCall::args_size() const {
  return args_.size();
}
inline void FuncCall::clear_args() {
  args_.Clear();
}
inline ::Pasc::Expression* FuncCall::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.FuncCall.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
FuncCall::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.FuncCall.args)
  return &args_;
}
inline const ::Pasc::Expression& FuncCall::args(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.FuncCall.args)
  return args_.Get(index);
}
inline ::Pasc::Expression* FuncCall::add_args() {
  // @@protoc_insertion_point(field_add:Pasc.FuncCall.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
FuncCall::args() const {
  // @@protoc_insertion_point(field_list:Pasc.FuncCall.args)
  return args_;
}

// .Pasc.Type returnType = 3;
inline bool FuncCall::has_returntype() const {
  return this != internal_default_instance() && returntype_ != NULL;
}
inline const ::Pasc::Type& FuncCall::_internal_returntype() const {
  return *returntype_;
}
inline const ::Pasc::Type& FuncCall::returntype() const {
  const ::Pasc::Type* p = returntype_;
  // @@protoc_insertion_point(field_get:Pasc.FuncCall.returnType)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* FuncCall::release_returntype() {
  // @@protoc_insertion_point(field_release:Pasc.FuncCall.returnType)
  
  ::Pasc::Type* temp = returntype_;
  returntype_ = NULL;
  return temp;
}
inline ::Pasc::Type* FuncCall::mutable_returntype() {
  
  if (returntype_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    returntype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FuncCall.returnType)
  return returntype_;
}
inline void FuncCall::set_allocated_returntype(::Pasc::Type* returntype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(returntype_);
  }
  if (returntype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      returntype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    
  } else {
    
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncCall.returnType)
}

// -------------------------------------------------------------------

// Operator

// .Pasc.Operator.OpKind op = 1;
inline void Operator::clear_op() {
  op_ = 0;
}
inline ::Pasc::Operator_OpKind Operator::op() const {
  // @@protoc_insertion_point(field_get:Pasc.Operator.op)
  return static_cast< ::Pasc::Operator_OpKind >(op_);
}
inline void Operator::set_op(::Pasc::Operator_OpKind value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Operator.op)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pasc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pasc::Identifier_IDKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Identifier_IDKind>() {
  return ::Pasc::Identifier_IDKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Expression_ExprKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Expression_ExprKind>() {
  return ::Pasc::Expression_ExprKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Operator_OpKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Operator_OpKind>() {
  return ::Pasc::Operator_OpKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_proto_2fexpression_2eproto
