// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/statement.proto

#ifndef PROTOBUF_INCLUDED_proto_2fstatement_2eproto
#define PROTOBUF_INCLUDED_proto_2fstatement_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "proto/token.pb.h"
#include "proto/expression.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_proto_2fstatement_2eproto 

namespace protobuf_proto_2fstatement_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_proto_2fstatement_2eproto
namespace Pasc {
class AssignStatement;
class AssignStatementDefaultTypeInternal;
extern AssignStatementDefaultTypeInternal _AssignStatement_default_instance_;
class CaseStatement;
class CaseStatementDefaultTypeInternal;
extern CaseStatementDefaultTypeInternal _CaseStatement_default_instance_;
class CaseStatement_CaseListElement;
class CaseStatement_CaseListElementDefaultTypeInternal;
extern CaseStatement_CaseListElementDefaultTypeInternal _CaseStatement_CaseListElement_default_instance_;
class CompoundStatement;
class CompoundStatementDefaultTypeInternal;
extern CompoundStatementDefaultTypeInternal _CompoundStatement_default_instance_;
class ForStatement;
class ForStatementDefaultTypeInternal;
extern ForStatementDefaultTypeInternal _ForStatement_default_instance_;
class GoToStatement;
class GoToStatementDefaultTypeInternal;
extern GoToStatementDefaultTypeInternal _GoToStatement_default_instance_;
class IfStatement;
class IfStatementDefaultTypeInternal;
extern IfStatementDefaultTypeInternal _IfStatement_default_instance_;
class ProcedureStatement;
class ProcedureStatementDefaultTypeInternal;
extern ProcedureStatementDefaultTypeInternal _ProcedureStatement_default_instance_;
class ProcedureStatement_ProcStmt;
class ProcedureStatement_ProcStmtDefaultTypeInternal;
extern ProcedureStatement_ProcStmtDefaultTypeInternal _ProcedureStatement_ProcStmt_default_instance_;
class ProcedureStatement_Read;
class ProcedureStatement_ReadDefaultTypeInternal;
extern ProcedureStatement_ReadDefaultTypeInternal _ProcedureStatement_Read_default_instance_;
class ProcedureStatement_ReadLn;
class ProcedureStatement_ReadLnDefaultTypeInternal;
extern ProcedureStatement_ReadLnDefaultTypeInternal _ProcedureStatement_ReadLn_default_instance_;
class ProcedureStatement_Write;
class ProcedureStatement_WriteDefaultTypeInternal;
extern ProcedureStatement_WriteDefaultTypeInternal _ProcedureStatement_Write_default_instance_;
class ProcedureStatement_WriteLn;
class ProcedureStatement_WriteLnDefaultTypeInternal;
extern ProcedureStatement_WriteLnDefaultTypeInternal _ProcedureStatement_WriteLn_default_instance_;
class RepeatStatement;
class RepeatStatementDefaultTypeInternal;
extern RepeatStatementDefaultTypeInternal _RepeatStatement_default_instance_;
class ReturnStatement;
class ReturnStatementDefaultTypeInternal;
extern ReturnStatementDefaultTypeInternal _ReturnStatement_default_instance_;
class Statement;
class StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class WhileStatement;
class WhileStatementDefaultTypeInternal;
extern WhileStatementDefaultTypeInternal _WhileStatement_default_instance_;
}  // namespace Pasc
namespace google {
namespace protobuf {
template<> ::Pasc::AssignStatement* Arena::CreateMaybeMessage<::Pasc::AssignStatement>(Arena*);
template<> ::Pasc::CaseStatement* Arena::CreateMaybeMessage<::Pasc::CaseStatement>(Arena*);
template<> ::Pasc::CaseStatement_CaseListElement* Arena::CreateMaybeMessage<::Pasc::CaseStatement_CaseListElement>(Arena*);
template<> ::Pasc::CompoundStatement* Arena::CreateMaybeMessage<::Pasc::CompoundStatement>(Arena*);
template<> ::Pasc::ForStatement* Arena::CreateMaybeMessage<::Pasc::ForStatement>(Arena*);
template<> ::Pasc::GoToStatement* Arena::CreateMaybeMessage<::Pasc::GoToStatement>(Arena*);
template<> ::Pasc::IfStatement* Arena::CreateMaybeMessage<::Pasc::IfStatement>(Arena*);
template<> ::Pasc::ProcedureStatement* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement>(Arena*);
template<> ::Pasc::ProcedureStatement_ProcStmt* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_ProcStmt>(Arena*);
template<> ::Pasc::ProcedureStatement_Read* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_Read>(Arena*);
template<> ::Pasc::ProcedureStatement_ReadLn* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_ReadLn>(Arena*);
template<> ::Pasc::ProcedureStatement_Write* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_Write>(Arena*);
template<> ::Pasc::ProcedureStatement_WriteLn* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_WriteLn>(Arena*);
template<> ::Pasc::RepeatStatement* Arena::CreateMaybeMessage<::Pasc::RepeatStatement>(Arena*);
template<> ::Pasc::ReturnStatement* Arena::CreateMaybeMessage<::Pasc::ReturnStatement>(Arena*);
template<> ::Pasc::Statement* Arena::CreateMaybeMessage<::Pasc::Statement>(Arena*);
template<> ::Pasc::WhileStatement* Arena::CreateMaybeMessage<::Pasc::WhileStatement>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Pasc {

enum ProcedureStatement_PSKind {
  ProcedureStatement_PSKind_wln = 0,
  ProcedureStatement_PSKind_write = 1,
  ProcedureStatement_PSKind_read = 2,
  ProcedureStatement_PSKind_readLn = 3,
  ProcedureStatement_PSKind_procStmt = 4,
  ProcedureStatement_PSKind_ProcedureStatement_PSKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ProcedureStatement_PSKind_ProcedureStatement_PSKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ProcedureStatement_PSKind_IsValid(int value);
const ProcedureStatement_PSKind ProcedureStatement_PSKind_PSKind_MIN = ProcedureStatement_PSKind_wln;
const ProcedureStatement_PSKind ProcedureStatement_PSKind_PSKind_MAX = ProcedureStatement_PSKind_procStmt;
const int ProcedureStatement_PSKind_PSKind_ARRAYSIZE = ProcedureStatement_PSKind_PSKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcedureStatement_PSKind_descriptor();
inline const ::std::string& ProcedureStatement_PSKind_Name(ProcedureStatement_PSKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcedureStatement_PSKind_descriptor(), value);
}
inline bool ProcedureStatement_PSKind_Parse(
    const ::std::string& name, ProcedureStatement_PSKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcedureStatement_PSKind>(
    ProcedureStatement_PSKind_descriptor(), name, value);
}
enum Statement_StmtKind {
  Statement_StmtKind_if_ = 0,
  Statement_StmtKind_assign = 1,
  Statement_StmtKind_procedure = 2,
  Statement_StmtKind_return_ = 3,
  Statement_StmtKind_while_ = 4,
  Statement_StmtKind_compound = 5,
  Statement_StmtKind_repeat = 6,
  Statement_StmtKind_for_ = 7,
  Statement_StmtKind_case_ = 8,
  Statement_StmtKind_goto_ = 9,
  Statement_StmtKind_Statement_StmtKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Statement_StmtKind_Statement_StmtKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Statement_StmtKind_IsValid(int value);
const Statement_StmtKind Statement_StmtKind_StmtKind_MIN = Statement_StmtKind_if_;
const Statement_StmtKind Statement_StmtKind_StmtKind_MAX = Statement_StmtKind_goto_;
const int Statement_StmtKind_StmtKind_ARRAYSIZE = Statement_StmtKind_StmtKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Statement_StmtKind_descriptor();
inline const ::std::string& Statement_StmtKind_Name(Statement_StmtKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Statement_StmtKind_descriptor(), value);
}
inline bool Statement_StmtKind_Parse(
    const ::std::string& name, Statement_StmtKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Statement_StmtKind>(
    Statement_StmtKind_descriptor(), name, value);
}
// ===================================================================

class ProcedureStatement_WriteLn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.WriteLn) */ {
 public:
  ProcedureStatement_WriteLn();
  virtual ~ProcedureStatement_WriteLn();

  ProcedureStatement_WriteLn(const ProcedureStatement_WriteLn& from);

  inline ProcedureStatement_WriteLn& operator=(const ProcedureStatement_WriteLn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_WriteLn(ProcedureStatement_WriteLn&& from) noexcept
    : ProcedureStatement_WriteLn() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_WriteLn& operator=(ProcedureStatement_WriteLn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_WriteLn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_WriteLn* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_WriteLn*>(
               &_ProcedureStatement_WriteLn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ProcedureStatement_WriteLn* other);
  friend void swap(ProcedureStatement_WriteLn& a, ProcedureStatement_WriteLn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_WriteLn* New() const final {
    return CreateMaybeMessage<ProcedureStatement_WriteLn>(NULL);
  }

  ProcedureStatement_WriteLn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_WriteLn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_WriteLn& from);
  void MergeFrom(const ProcedureStatement_WriteLn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_WriteLn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression params = 3;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  ::Pasc::Expression* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_params();
  const ::Pasc::Expression& params(int index) const;
  ::Pasc::Expression* add_params();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      params() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression file = 2;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_file() const;
  public:
  const ::Pasc::Expression& file() const;
  ::Pasc::Expression* release_file();
  ::Pasc::Expression* mutable_file();
  void set_allocated_file(::Pasc::Expression* file);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.WriteLn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* file_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_Write : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.Write) */ {
 public:
  ProcedureStatement_Write();
  virtual ~ProcedureStatement_Write();

  ProcedureStatement_Write(const ProcedureStatement_Write& from);

  inline ProcedureStatement_Write& operator=(const ProcedureStatement_Write& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_Write(ProcedureStatement_Write&& from) noexcept
    : ProcedureStatement_Write() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_Write& operator=(ProcedureStatement_Write&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_Write& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_Write* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_Write*>(
               &_ProcedureStatement_Write_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ProcedureStatement_Write* other);
  friend void swap(ProcedureStatement_Write& a, ProcedureStatement_Write& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_Write* New() const final {
    return CreateMaybeMessage<ProcedureStatement_Write>(NULL);
  }

  ProcedureStatement_Write* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_Write>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_Write& from);
  void MergeFrom(const ProcedureStatement_Write& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_Write* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression params = 3;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  ::Pasc::Expression* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_params();
  const ::Pasc::Expression& params(int index) const;
  ::Pasc::Expression* add_params();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      params() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression file = 2;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_file() const;
  public:
  const ::Pasc::Expression& file() const;
  ::Pasc::Expression* release_file();
  ::Pasc::Expression* mutable_file();
  void set_allocated_file(::Pasc::Expression* file);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.Write)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* file_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_Read : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.Read) */ {
 public:
  ProcedureStatement_Read();
  virtual ~ProcedureStatement_Read();

  ProcedureStatement_Read(const ProcedureStatement_Read& from);

  inline ProcedureStatement_Read& operator=(const ProcedureStatement_Read& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_Read(ProcedureStatement_Read&& from) noexcept
    : ProcedureStatement_Read() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_Read& operator=(ProcedureStatement_Read&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_Read& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_Read* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_Read*>(
               &_ProcedureStatement_Read_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProcedureStatement_Read* other);
  friend void swap(ProcedureStatement_Read& a, ProcedureStatement_Read& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_Read* New() const final {
    return CreateMaybeMessage<ProcedureStatement_Read>(NULL);
  }

  ProcedureStatement_Read* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_Read>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_Read& from);
  void MergeFrom(const ProcedureStatement_Read& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_Read* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression varAccess = 3;
  int varaccess_size() const;
  void clear_varaccess();
  static const int kVarAccessFieldNumber = 3;
  ::Pasc::Expression* mutable_varaccess(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_varaccess();
  const ::Pasc::Expression& varaccess(int index) const;
  ::Pasc::Expression* add_varaccess();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      varaccess() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression file = 2;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_file() const;
  public:
  const ::Pasc::Expression& file() const;
  ::Pasc::Expression* release_file();
  ::Pasc::Expression* mutable_file();
  void set_allocated_file(::Pasc::Expression* file);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.Read)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > varaccess_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* file_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_ReadLn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.ReadLn) */ {
 public:
  ProcedureStatement_ReadLn();
  virtual ~ProcedureStatement_ReadLn();

  ProcedureStatement_ReadLn(const ProcedureStatement_ReadLn& from);

  inline ProcedureStatement_ReadLn& operator=(const ProcedureStatement_ReadLn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_ReadLn(ProcedureStatement_ReadLn&& from) noexcept
    : ProcedureStatement_ReadLn() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_ReadLn& operator=(ProcedureStatement_ReadLn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_ReadLn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_ReadLn* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_ReadLn*>(
               &_ProcedureStatement_ReadLn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ProcedureStatement_ReadLn* other);
  friend void swap(ProcedureStatement_ReadLn& a, ProcedureStatement_ReadLn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_ReadLn* New() const final {
    return CreateMaybeMessage<ProcedureStatement_ReadLn>(NULL);
  }

  ProcedureStatement_ReadLn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_ReadLn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_ReadLn& from);
  void MergeFrom(const ProcedureStatement_ReadLn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_ReadLn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression varAccess = 3;
  int varaccess_size() const;
  void clear_varaccess();
  static const int kVarAccessFieldNumber = 3;
  ::Pasc::Expression* mutable_varaccess(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_varaccess();
  const ::Pasc::Expression& varaccess(int index) const;
  ::Pasc::Expression* add_varaccess();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      varaccess() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression file = 2;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_file() const;
  public:
  const ::Pasc::Expression& file() const;
  ::Pasc::Expression* release_file();
  ::Pasc::Expression* mutable_file();
  void set_allocated_file(::Pasc::Expression* file);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.ReadLn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > varaccess_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* file_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_ProcStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.ProcStmt) */ {
 public:
  ProcedureStatement_ProcStmt();
  virtual ~ProcedureStatement_ProcStmt();

  ProcedureStatement_ProcStmt(const ProcedureStatement_ProcStmt& from);

  inline ProcedureStatement_ProcStmt& operator=(const ProcedureStatement_ProcStmt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_ProcStmt(ProcedureStatement_ProcStmt&& from) noexcept
    : ProcedureStatement_ProcStmt() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_ProcStmt& operator=(ProcedureStatement_ProcStmt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_ProcStmt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_ProcStmt* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_ProcStmt*>(
               &_ProcedureStatement_ProcStmt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProcedureStatement_ProcStmt* other);
  friend void swap(ProcedureStatement_ProcStmt& a, ProcedureStatement_ProcStmt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_ProcStmt* New() const final {
    return CreateMaybeMessage<ProcedureStatement_ProcStmt>(NULL);
  }

  ProcedureStatement_ProcStmt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_ProcStmt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_ProcStmt& from);
  void MergeFrom(const ProcedureStatement_ProcStmt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_ProcStmt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression params = 2;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  ::Pasc::Expression* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_params();
  const ::Pasc::Expression& params(int index) const;
  ::Pasc::Expression* add_params();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      params() const;

  // string label = 3;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_name() const;
  public:
  const ::Pasc::Expression& name() const;
  ::Pasc::Expression* release_name();
  ::Pasc::Expression* mutable_name();
  void set_allocated_name(::Pasc::Expression* name);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.ProcStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > params_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement) */ {
 public:
  ProcedureStatement();
  virtual ~ProcedureStatement();

  ProcedureStatement(const ProcedureStatement& from);

  inline ProcedureStatement& operator=(const ProcedureStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement(ProcedureStatement&& from) noexcept
    : ProcedureStatement() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement& operator=(ProcedureStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement& default_instance();

  enum StmtCase {
    kWrt = 2,
    kWrtLn = 3,
    kRd = 4,
    kRdLn = 5,
    kPs = 6,
    STMT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement*>(
               &_ProcedureStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ProcedureStatement* other);
  friend void swap(ProcedureStatement& a, ProcedureStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement* New() const final {
    return CreateMaybeMessage<ProcedureStatement>(NULL);
  }

  ProcedureStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement& from);
  void MergeFrom(const ProcedureStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProcedureStatement_WriteLn WriteLn;
  typedef ProcedureStatement_Write Write;
  typedef ProcedureStatement_Read Read;
  typedef ProcedureStatement_ReadLn ReadLn;
  typedef ProcedureStatement_ProcStmt ProcStmt;

  typedef ProcedureStatement_PSKind PSKind;
  static const PSKind wln =
    ProcedureStatement_PSKind_wln;
  static const PSKind write =
    ProcedureStatement_PSKind_write;
  static const PSKind read =
    ProcedureStatement_PSKind_read;
  static const PSKind readLn =
    ProcedureStatement_PSKind_readLn;
  static const PSKind procStmt =
    ProcedureStatement_PSKind_procStmt;
  static inline bool PSKind_IsValid(int value) {
    return ProcedureStatement_PSKind_IsValid(value);
  }
  static const PSKind PSKind_MIN =
    ProcedureStatement_PSKind_PSKind_MIN;
  static const PSKind PSKind_MAX =
    ProcedureStatement_PSKind_PSKind_MAX;
  static const int PSKind_ARRAYSIZE =
    ProcedureStatement_PSKind_PSKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PSKind_descriptor() {
    return ProcedureStatement_PSKind_descriptor();
  }
  static inline const ::std::string& PSKind_Name(PSKind value) {
    return ProcedureStatement_PSKind_Name(value);
  }
  static inline bool PSKind_Parse(const ::std::string& name,
      PSKind* value) {
    return ProcedureStatement_PSKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.ProcedureStatement.PSKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::ProcedureStatement_PSKind kind() const;
  void set_kind(::Pasc::ProcedureStatement_PSKind value);

  // .Pasc.ProcedureStatement.Write wrt = 2;
  bool has_wrt() const;
  void clear_wrt();
  static const int kWrtFieldNumber = 2;
  private:
  const ::Pasc::ProcedureStatement_Write& _internal_wrt() const;
  public:
  const ::Pasc::ProcedureStatement_Write& wrt() const;
  ::Pasc::ProcedureStatement_Write* release_wrt();
  ::Pasc::ProcedureStatement_Write* mutable_wrt();
  void set_allocated_wrt(::Pasc::ProcedureStatement_Write* wrt);

  // .Pasc.ProcedureStatement.WriteLn wrtLn = 3;
  bool has_wrtln() const;
  void clear_wrtln();
  static const int kWrtLnFieldNumber = 3;
  private:
  const ::Pasc::ProcedureStatement_WriteLn& _internal_wrtln() const;
  public:
  const ::Pasc::ProcedureStatement_WriteLn& wrtln() const;
  ::Pasc::ProcedureStatement_WriteLn* release_wrtln();
  ::Pasc::ProcedureStatement_WriteLn* mutable_wrtln();
  void set_allocated_wrtln(::Pasc::ProcedureStatement_WriteLn* wrtln);

  // .Pasc.ProcedureStatement.Read rd = 4;
  bool has_rd() const;
  void clear_rd();
  static const int kRdFieldNumber = 4;
  private:
  const ::Pasc::ProcedureStatement_Read& _internal_rd() const;
  public:
  const ::Pasc::ProcedureStatement_Read& rd() const;
  ::Pasc::ProcedureStatement_Read* release_rd();
  ::Pasc::ProcedureStatement_Read* mutable_rd();
  void set_allocated_rd(::Pasc::ProcedureStatement_Read* rd);

  // .Pasc.ProcedureStatement.ReadLn rdLn = 5;
  bool has_rdln() const;
  void clear_rdln();
  static const int kRdLnFieldNumber = 5;
  private:
  const ::Pasc::ProcedureStatement_ReadLn& _internal_rdln() const;
  public:
  const ::Pasc::ProcedureStatement_ReadLn& rdln() const;
  ::Pasc::ProcedureStatement_ReadLn* release_rdln();
  ::Pasc::ProcedureStatement_ReadLn* mutable_rdln();
  void set_allocated_rdln(::Pasc::ProcedureStatement_ReadLn* rdln);

  // .Pasc.ProcedureStatement.ProcStmt ps = 6;
  bool has_ps() const;
  void clear_ps();
  static const int kPsFieldNumber = 6;
  private:
  const ::Pasc::ProcedureStatement_ProcStmt& _internal_ps() const;
  public:
  const ::Pasc::ProcedureStatement_ProcStmt& ps() const;
  ::Pasc::ProcedureStatement_ProcStmt* release_ps();
  ::Pasc::ProcedureStatement_ProcStmt* mutable_ps();
  void set_allocated_ps(::Pasc::ProcedureStatement_ProcStmt* ps);

  void clear_stmt();
  StmtCase stmt_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement)
 private:
  void set_has_wrt();
  void set_has_wrtln();
  void set_has_rd();
  void set_has_rdln();
  void set_has_ps();

  inline bool has_stmt() const;
  inline void clear_has_stmt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union StmtUnion {
    StmtUnion() {}
    ::Pasc::ProcedureStatement_Write* wrt_;
    ::Pasc::ProcedureStatement_WriteLn* wrtln_;
    ::Pasc::ProcedureStatement_Read* rd_;
    ::Pasc::ProcedureStatement_ReadLn* rdln_;
    ::Pasc::ProcedureStatement_ProcStmt* ps_;
  } stmt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssignStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.AssignStatement) */ {
 public:
  AssignStatement();
  virtual ~AssignStatement();

  AssignStatement(const AssignStatement& from);

  inline AssignStatement& operator=(const AssignStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssignStatement(AssignStatement&& from) noexcept
    : AssignStatement() {
    *this = ::std::move(from);
  }

  inline AssignStatement& operator=(AssignStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssignStatement* internal_default_instance() {
    return reinterpret_cast<const AssignStatement*>(
               &_AssignStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AssignStatement* other);
  friend void swap(AssignStatement& a, AssignStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssignStatement* New() const final {
    return CreateMaybeMessage<AssignStatement>(NULL);
  }

  AssignStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssignStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssignStatement& from);
  void MergeFrom(const AssignStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 3;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression variable = 1;
  bool has_variable() const;
  void clear_variable();
  static const int kVariableFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_variable() const;
  public:
  const ::Pasc::Expression& variable() const;
  ::Pasc::Expression* release_variable();
  ::Pasc::Expression* mutable_variable();
  void set_allocated_variable(::Pasc::Expression* variable);

  // .Pasc.Expression value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_value() const;
  public:
  const ::Pasc::Expression& value() const;
  ::Pasc::Expression* release_value();
  ::Pasc::Expression* mutable_value();
  void set_allocated_value(::Pasc::Expression* value);

  // @@protoc_insertion_point(class_scope:Pasc.AssignStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* variable_;
  ::Pasc::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IfStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.IfStatement) */ {
 public:
  IfStatement();
  virtual ~IfStatement();

  IfStatement(const IfStatement& from);

  inline IfStatement& operator=(const IfStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IfStatement(IfStatement&& from) noexcept
    : IfStatement() {
    *this = ::std::move(from);
  }

  inline IfStatement& operator=(IfStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IfStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfStatement* internal_default_instance() {
    return reinterpret_cast<const IfStatement*>(
               &_IfStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(IfStatement* other);
  friend void swap(IfStatement& a, IfStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IfStatement* New() const final {
    return CreateMaybeMessage<IfStatement>(NULL);
  }

  IfStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IfStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IfStatement& from);
  void MergeFrom(const IfStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 4;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression cond = 1;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_cond() const;
  public:
  const ::Pasc::Expression& cond() const;
  ::Pasc::Expression* release_cond();
  ::Pasc::Expression* mutable_cond();
  void set_allocated_cond(::Pasc::Expression* cond);

  // .Pasc.Statement truePath = 2;
  bool has_truepath() const;
  void clear_truepath();
  static const int kTruePathFieldNumber = 2;
  private:
  const ::Pasc::Statement& _internal_truepath() const;
  public:
  const ::Pasc::Statement& truepath() const;
  ::Pasc::Statement* release_truepath();
  ::Pasc::Statement* mutable_truepath();
  void set_allocated_truepath(::Pasc::Statement* truepath);

  // .Pasc.Statement elsePath = 3;
  bool has_elsepath() const;
  void clear_elsepath();
  static const int kElsePathFieldNumber = 3;
  private:
  const ::Pasc::Statement& _internal_elsepath() const;
  public:
  const ::Pasc::Statement& elsepath() const;
  ::Pasc::Statement* release_elsepath();
  ::Pasc::Statement* mutable_elsepath();
  void set_allocated_elsepath(::Pasc::Statement* elsepath);

  // @@protoc_insertion_point(class_scope:Pasc.IfStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* cond_;
  ::Pasc::Statement* truepath_;
  ::Pasc::Statement* elsepath_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReturnStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ReturnStatement) */ {
 public:
  ReturnStatement();
  virtual ~ReturnStatement();

  ReturnStatement(const ReturnStatement& from);

  inline ReturnStatement& operator=(const ReturnStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReturnStatement(ReturnStatement&& from) noexcept
    : ReturnStatement() {
    *this = ::std::move(from);
  }

  inline ReturnStatement& operator=(ReturnStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReturnStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReturnStatement* internal_default_instance() {
    return reinterpret_cast<const ReturnStatement*>(
               &_ReturnStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ReturnStatement* other);
  friend void swap(ReturnStatement& a, ReturnStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReturnStatement* New() const final {
    return CreateMaybeMessage<ReturnStatement>(NULL);
  }

  ReturnStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReturnStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReturnStatement& from);
  void MergeFrom(const ReturnStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 2;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_value() const;
  public:
  const ::Pasc::Expression& value() const;
  ::Pasc::Expression* release_value();
  ::Pasc::Expression* mutable_value();
  void set_allocated_value(::Pasc::Expression* value);

  // @@protoc_insertion_point(class_scope:Pasc.ReturnStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WhileStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.WhileStatement) */ {
 public:
  WhileStatement();
  virtual ~WhileStatement();

  WhileStatement(const WhileStatement& from);

  inline WhileStatement& operator=(const WhileStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WhileStatement(WhileStatement&& from) noexcept
    : WhileStatement() {
    *this = ::std::move(from);
  }

  inline WhileStatement& operator=(WhileStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WhileStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WhileStatement* internal_default_instance() {
    return reinterpret_cast<const WhileStatement*>(
               &_WhileStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(WhileStatement* other);
  friend void swap(WhileStatement& a, WhileStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WhileStatement* New() const final {
    return CreateMaybeMessage<WhileStatement>(NULL);
  }

  WhileStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WhileStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WhileStatement& from);
  void MergeFrom(const WhileStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WhileStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 3;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression cond = 1;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_cond() const;
  public:
  const ::Pasc::Expression& cond() const;
  ::Pasc::Expression* release_cond();
  ::Pasc::Expression* mutable_cond();
  void set_allocated_cond(::Pasc::Expression* cond);

  // .Pasc.Statement body = 2;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 2;
  private:
  const ::Pasc::Statement& _internal_body() const;
  public:
  const ::Pasc::Statement& body() const;
  ::Pasc::Statement* release_body();
  ::Pasc::Statement* mutable_body();
  void set_allocated_body(::Pasc::Statement* body);

  // @@protoc_insertion_point(class_scope:Pasc.WhileStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* cond_;
  ::Pasc::Statement* body_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompoundStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.CompoundStatement) */ {
 public:
  CompoundStatement();
  virtual ~CompoundStatement();

  CompoundStatement(const CompoundStatement& from);

  inline CompoundStatement& operator=(const CompoundStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompoundStatement(CompoundStatement&& from) noexcept
    : CompoundStatement() {
    *this = ::std::move(from);
  }

  inline CompoundStatement& operator=(CompoundStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompoundStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompoundStatement* internal_default_instance() {
    return reinterpret_cast<const CompoundStatement*>(
               &_CompoundStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CompoundStatement* other);
  friend void swap(CompoundStatement& a, CompoundStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompoundStatement* New() const final {
    return CreateMaybeMessage<CompoundStatement>(NULL);
  }

  CompoundStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CompoundStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CompoundStatement& from);
  void MergeFrom(const CompoundStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompoundStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Statement stmts = 1;
  int stmts_size() const;
  void clear_stmts();
  static const int kStmtsFieldNumber = 1;
  ::Pasc::Statement* mutable_stmts(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
      mutable_stmts();
  const ::Pasc::Statement& stmts(int index) const;
  ::Pasc::Statement* add_stmts();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
      stmts() const;

  // string label = 2;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:Pasc.CompoundStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement > stmts_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RepeatStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.RepeatStatement) */ {
 public:
  RepeatStatement();
  virtual ~RepeatStatement();

  RepeatStatement(const RepeatStatement& from);

  inline RepeatStatement& operator=(const RepeatStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RepeatStatement(RepeatStatement&& from) noexcept
    : RepeatStatement() {
    *this = ::std::move(from);
  }

  inline RepeatStatement& operator=(RepeatStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RepeatStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RepeatStatement* internal_default_instance() {
    return reinterpret_cast<const RepeatStatement*>(
               &_RepeatStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(RepeatStatement* other);
  friend void swap(RepeatStatement& a, RepeatStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RepeatStatement* New() const final {
    return CreateMaybeMessage<RepeatStatement>(NULL);
  }

  RepeatStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RepeatStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RepeatStatement& from);
  void MergeFrom(const RepeatStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Statement stmts = 1;
  int stmts_size() const;
  void clear_stmts();
  static const int kStmtsFieldNumber = 1;
  ::Pasc::Statement* mutable_stmts(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
      mutable_stmts();
  const ::Pasc::Statement& stmts(int index) const;
  ::Pasc::Statement* add_stmts();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
      stmts() const;

  // string label = 3;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression cond = 2;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_cond() const;
  public:
  const ::Pasc::Expression& cond() const;
  ::Pasc::Expression* release_cond();
  ::Pasc::Expression* mutable_cond();
  void set_allocated_cond(::Pasc::Expression* cond);

  // @@protoc_insertion_point(class_scope:Pasc.RepeatStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement > stmts_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* cond_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ForStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ForStatement) */ {
 public:
  ForStatement();
  virtual ~ForStatement();

  ForStatement(const ForStatement& from);

  inline ForStatement& operator=(const ForStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ForStatement(ForStatement&& from) noexcept
    : ForStatement() {
    *this = ::std::move(from);
  }

  inline ForStatement& operator=(ForStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ForStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ForStatement* internal_default_instance() {
    return reinterpret_cast<const ForStatement*>(
               &_ForStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ForStatement* other);
  friend void swap(ForStatement& a, ForStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ForStatement* New() const final {
    return CreateMaybeMessage<ForStatement>(NULL);
  }

  ForStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ForStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ForStatement& from);
  void MergeFrom(const ForStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 6;
  void clear_label();
  static const int kLabelFieldNumber = 6;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression ctlVar = 1;
  bool has_ctlvar() const;
  void clear_ctlvar();
  static const int kCtlVarFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_ctlvar() const;
  public:
  const ::Pasc::Expression& ctlvar() const;
  ::Pasc::Expression* release_ctlvar();
  ::Pasc::Expression* mutable_ctlvar();
  void set_allocated_ctlvar(::Pasc::Expression* ctlvar);

  // .Pasc.Expression initValue = 2;
  bool has_initvalue() const;
  void clear_initvalue();
  static const int kInitValueFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_initvalue() const;
  public:
  const ::Pasc::Expression& initvalue() const;
  ::Pasc::Expression* release_initvalue();
  ::Pasc::Expression* mutable_initvalue();
  void set_allocated_initvalue(::Pasc::Expression* initvalue);

  // .Pasc.Expression finalValue = 3;
  bool has_finalvalue() const;
  void clear_finalvalue();
  static const int kFinalValueFieldNumber = 3;
  private:
  const ::Pasc::Expression& _internal_finalvalue() const;
  public:
  const ::Pasc::Expression& finalvalue() const;
  ::Pasc::Expression* release_finalvalue();
  ::Pasc::Expression* mutable_finalvalue();
  void set_allocated_finalvalue(::Pasc::Expression* finalvalue);

  // .Pasc.Statement body = 4;
  bool has_body() const;
  void clear_body();
  static const int kBodyFieldNumber = 4;
  private:
  const ::Pasc::Statement& _internal_body() const;
  public:
  const ::Pasc::Statement& body() const;
  ::Pasc::Statement* release_body();
  ::Pasc::Statement* mutable_body();
  void set_allocated_body(::Pasc::Statement* body);

  // .Pasc.TokenKind dir = 5;
  void clear_dir();
  static const int kDirFieldNumber = 5;
  ::Pasc::TokenKind dir() const;
  void set_dir(::Pasc::TokenKind value);

  // @@protoc_insertion_point(class_scope:Pasc.ForStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* ctlvar_;
  ::Pasc::Expression* initvalue_;
  ::Pasc::Expression* finalvalue_;
  ::Pasc::Statement* body_;
  int dir_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CaseStatement_CaseListElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.CaseStatement.CaseListElement) */ {
 public:
  CaseStatement_CaseListElement();
  virtual ~CaseStatement_CaseListElement();

  CaseStatement_CaseListElement(const CaseStatement_CaseListElement& from);

  inline CaseStatement_CaseListElement& operator=(const CaseStatement_CaseListElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CaseStatement_CaseListElement(CaseStatement_CaseListElement&& from) noexcept
    : CaseStatement_CaseListElement() {
    *this = ::std::move(from);
  }

  inline CaseStatement_CaseListElement& operator=(CaseStatement_CaseListElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CaseStatement_CaseListElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CaseStatement_CaseListElement* internal_default_instance() {
    return reinterpret_cast<const CaseStatement_CaseListElement*>(
               &_CaseStatement_CaseListElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CaseStatement_CaseListElement* other);
  friend void swap(CaseStatement_CaseListElement& a, CaseStatement_CaseListElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CaseStatement_CaseListElement* New() const final {
    return CreateMaybeMessage<CaseStatement_CaseListElement>(NULL);
  }

  CaseStatement_CaseListElement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CaseStatement_CaseListElement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CaseStatement_CaseListElement& from);
  void MergeFrom(const CaseStatement_CaseListElement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaseStatement_CaseListElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression constants = 1;
  int constants_size() const;
  void clear_constants();
  static const int kConstantsFieldNumber = 1;
  ::Pasc::Expression* mutable_constants(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_constants();
  const ::Pasc::Expression& constants(int index) const;
  ::Pasc::Expression* add_constants();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      constants() const;

  // .Pasc.Statement stmt = 2;
  bool has_stmt() const;
  void clear_stmt();
  static const int kStmtFieldNumber = 2;
  private:
  const ::Pasc::Statement& _internal_stmt() const;
  public:
  const ::Pasc::Statement& stmt() const;
  ::Pasc::Statement* release_stmt();
  ::Pasc::Statement* mutable_stmt();
  void set_allocated_stmt(::Pasc::Statement* stmt);

  // @@protoc_insertion_point(class_scope:Pasc.CaseStatement.CaseListElement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > constants_;
  ::Pasc::Statement* stmt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CaseStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.CaseStatement) */ {
 public:
  CaseStatement();
  virtual ~CaseStatement();

  CaseStatement(const CaseStatement& from);

  inline CaseStatement& operator=(const CaseStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CaseStatement(CaseStatement&& from) noexcept
    : CaseStatement() {
    *this = ::std::move(from);
  }

  inline CaseStatement& operator=(CaseStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CaseStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CaseStatement* internal_default_instance() {
    return reinterpret_cast<const CaseStatement*>(
               &_CaseStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CaseStatement* other);
  friend void swap(CaseStatement& a, CaseStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CaseStatement* New() const final {
    return CreateMaybeMessage<CaseStatement>(NULL);
  }

  CaseStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CaseStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CaseStatement& from);
  void MergeFrom(const CaseStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CaseStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CaseStatement_CaseListElement CaseListElement;

  // accessors -------------------------------------------------------

  // repeated .Pasc.CaseStatement.CaseListElement cle = 2;
  int cle_size() const;
  void clear_cle();
  static const int kCleFieldNumber = 2;
  ::Pasc::CaseStatement_CaseListElement* mutable_cle(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::CaseStatement_CaseListElement >*
      mutable_cle();
  const ::Pasc::CaseStatement_CaseListElement& cle(int index) const;
  ::Pasc::CaseStatement_CaseListElement* add_cle();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::CaseStatement_CaseListElement >&
      cle() const;

  // string label = 3;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // .Pasc.Expression caseIndex = 1;
  bool has_caseindex() const;
  void clear_caseindex();
  static const int kCaseIndexFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_caseindex() const;
  public:
  const ::Pasc::Expression& caseindex() const;
  ::Pasc::Expression* release_caseindex();
  ::Pasc::Expression* mutable_caseindex();
  void set_allocated_caseindex(::Pasc::Expression* caseindex);

  // @@protoc_insertion_point(class_scope:Pasc.CaseStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::CaseStatement_CaseListElement > cle_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::Pasc::Expression* caseindex_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GoToStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.GoToStatement) */ {
 public:
  GoToStatement();
  virtual ~GoToStatement();

  GoToStatement(const GoToStatement& from);

  inline GoToStatement& operator=(const GoToStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GoToStatement(GoToStatement&& from) noexcept
    : GoToStatement() {
    *this = ::std::move(from);
  }

  inline GoToStatement& operator=(GoToStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GoToStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GoToStatement* internal_default_instance() {
    return reinterpret_cast<const GoToStatement*>(
               &_GoToStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GoToStatement* other);
  friend void swap(GoToStatement& a, GoToStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GoToStatement* New() const final {
    return CreateMaybeMessage<GoToStatement>(NULL);
  }

  GoToStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GoToStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GoToStatement& from);
  void MergeFrom(const GoToStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoToStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 1;
  void clear_label();
  static const int kLabelFieldNumber = 1;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:Pasc.GoToStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Statement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Statement) */ {
 public:
  Statement();
  virtual ~Statement();

  Statement(const Statement& from);

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(Statement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Statement& default_instance();

  enum StmtCase {
    kAssignStmt = 2,
    kProcStmt = 3,
    kIfStmt = 4,
    kRetStmt = 5,
    kWhileStmt = 6,
    kCmpdStmt = 7,
    kRptStmt = 8,
    kForStmt = 9,
    kCaseStmt = 10,
    kGotoStmt = 11,
    STMT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Statement* other);
  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Statement* New() const final {
    return CreateMaybeMessage<Statement>(NULL);
  }

  Statement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Statement_StmtKind StmtKind;
  static const StmtKind if_ =
    Statement_StmtKind_if_;
  static const StmtKind assign =
    Statement_StmtKind_assign;
  static const StmtKind procedure =
    Statement_StmtKind_procedure;
  static const StmtKind return_ =
    Statement_StmtKind_return_;
  static const StmtKind while_ =
    Statement_StmtKind_while_;
  static const StmtKind compound =
    Statement_StmtKind_compound;
  static const StmtKind repeat =
    Statement_StmtKind_repeat;
  static const StmtKind for_ =
    Statement_StmtKind_for_;
  static const StmtKind case_ =
    Statement_StmtKind_case_;
  static const StmtKind goto_ =
    Statement_StmtKind_goto_;
  static inline bool StmtKind_IsValid(int value) {
    return Statement_StmtKind_IsValid(value);
  }
  static const StmtKind StmtKind_MIN =
    Statement_StmtKind_StmtKind_MIN;
  static const StmtKind StmtKind_MAX =
    Statement_StmtKind_StmtKind_MAX;
  static const int StmtKind_ARRAYSIZE =
    Statement_StmtKind_StmtKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StmtKind_descriptor() {
    return Statement_StmtKind_descriptor();
  }
  static inline const ::std::string& StmtKind_Name(StmtKind value) {
    return Statement_StmtKind_Name(value);
  }
  static inline bool StmtKind_Parse(const ::std::string& name,
      StmtKind* value) {
    return Statement_StmtKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Statement.StmtKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Statement_StmtKind kind() const;
  void set_kind(::Pasc::Statement_StmtKind value);

  // .Pasc.AssignStatement assignStmt = 2;
  bool has_assignstmt() const;
  void clear_assignstmt();
  static const int kAssignStmtFieldNumber = 2;
  private:
  const ::Pasc::AssignStatement& _internal_assignstmt() const;
  public:
  const ::Pasc::AssignStatement& assignstmt() const;
  ::Pasc::AssignStatement* release_assignstmt();
  ::Pasc::AssignStatement* mutable_assignstmt();
  void set_allocated_assignstmt(::Pasc::AssignStatement* assignstmt);

  // .Pasc.ProcedureStatement procStmt = 3;
  bool has_procstmt() const;
  void clear_procstmt();
  static const int kProcStmtFieldNumber = 3;
  private:
  const ::Pasc::ProcedureStatement& _internal_procstmt() const;
  public:
  const ::Pasc::ProcedureStatement& procstmt() const;
  ::Pasc::ProcedureStatement* release_procstmt();
  ::Pasc::ProcedureStatement* mutable_procstmt();
  void set_allocated_procstmt(::Pasc::ProcedureStatement* procstmt);

  // .Pasc.IfStatement ifStmt = 4;
  bool has_ifstmt() const;
  void clear_ifstmt();
  static const int kIfStmtFieldNumber = 4;
  private:
  const ::Pasc::IfStatement& _internal_ifstmt() const;
  public:
  const ::Pasc::IfStatement& ifstmt() const;
  ::Pasc::IfStatement* release_ifstmt();
  ::Pasc::IfStatement* mutable_ifstmt();
  void set_allocated_ifstmt(::Pasc::IfStatement* ifstmt);

  // .Pasc.ReturnStatement retStmt = 5;
  bool has_retstmt() const;
  void clear_retstmt();
  static const int kRetStmtFieldNumber = 5;
  private:
  const ::Pasc::ReturnStatement& _internal_retstmt() const;
  public:
  const ::Pasc::ReturnStatement& retstmt() const;
  ::Pasc::ReturnStatement* release_retstmt();
  ::Pasc::ReturnStatement* mutable_retstmt();
  void set_allocated_retstmt(::Pasc::ReturnStatement* retstmt);

  // .Pasc.WhileStatement whileStmt = 6;
  bool has_whilestmt() const;
  void clear_whilestmt();
  static const int kWhileStmtFieldNumber = 6;
  private:
  const ::Pasc::WhileStatement& _internal_whilestmt() const;
  public:
  const ::Pasc::WhileStatement& whilestmt() const;
  ::Pasc::WhileStatement* release_whilestmt();
  ::Pasc::WhileStatement* mutable_whilestmt();
  void set_allocated_whilestmt(::Pasc::WhileStatement* whilestmt);

  // .Pasc.CompoundStatement cmpdStmt = 7;
  bool has_cmpdstmt() const;
  void clear_cmpdstmt();
  static const int kCmpdStmtFieldNumber = 7;
  private:
  const ::Pasc::CompoundStatement& _internal_cmpdstmt() const;
  public:
  const ::Pasc::CompoundStatement& cmpdstmt() const;
  ::Pasc::CompoundStatement* release_cmpdstmt();
  ::Pasc::CompoundStatement* mutable_cmpdstmt();
  void set_allocated_cmpdstmt(::Pasc::CompoundStatement* cmpdstmt);

  // .Pasc.RepeatStatement rptStmt = 8;
  bool has_rptstmt() const;
  void clear_rptstmt();
  static const int kRptStmtFieldNumber = 8;
  private:
  const ::Pasc::RepeatStatement& _internal_rptstmt() const;
  public:
  const ::Pasc::RepeatStatement& rptstmt() const;
  ::Pasc::RepeatStatement* release_rptstmt();
  ::Pasc::RepeatStatement* mutable_rptstmt();
  void set_allocated_rptstmt(::Pasc::RepeatStatement* rptstmt);

  // .Pasc.ForStatement forStmt = 9;
  bool has_forstmt() const;
  void clear_forstmt();
  static const int kForStmtFieldNumber = 9;
  private:
  const ::Pasc::ForStatement& _internal_forstmt() const;
  public:
  const ::Pasc::ForStatement& forstmt() const;
  ::Pasc::ForStatement* release_forstmt();
  ::Pasc::ForStatement* mutable_forstmt();
  void set_allocated_forstmt(::Pasc::ForStatement* forstmt);

  // .Pasc.CaseStatement caseStmt = 10;
  bool has_casestmt() const;
  void clear_casestmt();
  static const int kCaseStmtFieldNumber = 10;
  private:
  const ::Pasc::CaseStatement& _internal_casestmt() const;
  public:
  const ::Pasc::CaseStatement& casestmt() const;
  ::Pasc::CaseStatement* release_casestmt();
  ::Pasc::CaseStatement* mutable_casestmt();
  void set_allocated_casestmt(::Pasc::CaseStatement* casestmt);

  // .Pasc.GoToStatement gotoStmt = 11;
  bool has_gotostmt() const;
  void clear_gotostmt();
  static const int kGotoStmtFieldNumber = 11;
  private:
  const ::Pasc::GoToStatement& _internal_gotostmt() const;
  public:
  const ::Pasc::GoToStatement& gotostmt() const;
  ::Pasc::GoToStatement* release_gotostmt();
  ::Pasc::GoToStatement* mutable_gotostmt();
  void set_allocated_gotostmt(::Pasc::GoToStatement* gotostmt);

  void clear_stmt();
  StmtCase stmt_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Statement)
 private:
  void set_has_assignstmt();
  void set_has_procstmt();
  void set_has_ifstmt();
  void set_has_retstmt();
  void set_has_whilestmt();
  void set_has_cmpdstmt();
  void set_has_rptstmt();
  void set_has_forstmt();
  void set_has_casestmt();
  void set_has_gotostmt();

  inline bool has_stmt() const;
  inline void clear_has_stmt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union StmtUnion {
    StmtUnion() {}
    ::Pasc::AssignStatement* assignstmt_;
    ::Pasc::ProcedureStatement* procstmt_;
    ::Pasc::IfStatement* ifstmt_;
    ::Pasc::ReturnStatement* retstmt_;
    ::Pasc::WhileStatement* whilestmt_;
    ::Pasc::CompoundStatement* cmpdstmt_;
    ::Pasc::RepeatStatement* rptstmt_;
    ::Pasc::ForStatement* forstmt_;
    ::Pasc::CaseStatement* casestmt_;
    ::Pasc::GoToStatement* gotostmt_;
  } stmt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_proto_2fstatement_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ProcedureStatement_WriteLn

// string name = 1;
inline void ProcedureStatement_WriteLn::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_WriteLn::name() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.WriteLn.name)
  return name_.GetNoArena();
}
inline void ProcedureStatement_WriteLn::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.WriteLn.name)
}
#if LANG_CXX11
inline void ProcedureStatement_WriteLn::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.WriteLn.name)
}
#endif
inline void ProcedureStatement_WriteLn::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.WriteLn.name)
}
inline void ProcedureStatement_WriteLn::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.WriteLn.name)
}
inline ::std::string* ProcedureStatement_WriteLn::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.WriteLn.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_WriteLn::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.WriteLn.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_WriteLn::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.WriteLn.name)
}

// .Pasc.Expression file = 2;
inline bool ProcedureStatement_WriteLn::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline const ::Pasc::Expression& ProcedureStatement_WriteLn::_internal_file() const {
  return *file_;
}
inline const ::Pasc::Expression& ProcedureStatement_WriteLn::file() const {
  const ::Pasc::Expression* p = file_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.WriteLn.file)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::release_file() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.WriteLn.file)
  
  ::Pasc::Expression* temp = file_;
  file_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::mutable_file() {
  
  if (file_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    file_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.WriteLn.file)
  return file_;
}
inline void ProcedureStatement_WriteLn::set_allocated_file(::Pasc::Expression* file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(file_);
  }
  if (file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.WriteLn.file)
}

// repeated .Pasc.Expression params = 3;
inline int ProcedureStatement_WriteLn::params_size() const {
  return params_.size();
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.WriteLn.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStatement_WriteLn::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStatement.WriteLn.params)
  return &params_;
}
inline const ::Pasc::Expression& ProcedureStatement_WriteLn::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.WriteLn.params)
  return params_.Get(index);
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::add_params() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStatement.WriteLn.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStatement_WriteLn::params() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStatement.WriteLn.params)
  return params_;
}

// string label = 4;
inline void ProcedureStatement_WriteLn::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_WriteLn::label() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.WriteLn.label)
  return label_.GetNoArena();
}
inline void ProcedureStatement_WriteLn::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.WriteLn.label)
}
#if LANG_CXX11
inline void ProcedureStatement_WriteLn::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.WriteLn.label)
}
#endif
inline void ProcedureStatement_WriteLn::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.WriteLn.label)
}
inline void ProcedureStatement_WriteLn::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.WriteLn.label)
}
inline ::std::string* ProcedureStatement_WriteLn::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.WriteLn.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_WriteLn::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.WriteLn.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_WriteLn::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.WriteLn.label)
}

// -------------------------------------------------------------------

// ProcedureStatement_Write

// string name = 1;
inline void ProcedureStatement_Write::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_Write::name() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Write.name)
  return name_.GetNoArena();
}
inline void ProcedureStatement_Write::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.Write.name)
}
#if LANG_CXX11
inline void ProcedureStatement_Write::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.Write.name)
}
#endif
inline void ProcedureStatement_Write::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.Write.name)
}
inline void ProcedureStatement_Write::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.Write.name)
}
inline ::std::string* ProcedureStatement_Write::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Write.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_Write::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.Write.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_Write::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.Write.name)
}

// .Pasc.Expression file = 2;
inline bool ProcedureStatement_Write::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline const ::Pasc::Expression& ProcedureStatement_Write::_internal_file() const {
  return *file_;
}
inline const ::Pasc::Expression& ProcedureStatement_Write::file() const {
  const ::Pasc::Expression* p = file_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Write.file)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStatement_Write::release_file() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.Write.file)
  
  ::Pasc::Expression* temp = file_;
  file_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStatement_Write::mutable_file() {
  
  if (file_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    file_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Write.file)
  return file_;
}
inline void ProcedureStatement_Write::set_allocated_file(::Pasc::Expression* file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(file_);
  }
  if (file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.Write.file)
}

// repeated .Pasc.Expression params = 3;
inline int ProcedureStatement_Write::params_size() const {
  return params_.size();
}
inline ::Pasc::Expression* ProcedureStatement_Write::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Write.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStatement_Write::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStatement.Write.params)
  return &params_;
}
inline const ::Pasc::Expression& ProcedureStatement_Write::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Write.params)
  return params_.Get(index);
}
inline ::Pasc::Expression* ProcedureStatement_Write::add_params() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStatement.Write.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStatement_Write::params() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStatement.Write.params)
  return params_;
}

// string label = 4;
inline void ProcedureStatement_Write::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_Write::label() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Write.label)
  return label_.GetNoArena();
}
inline void ProcedureStatement_Write::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.Write.label)
}
#if LANG_CXX11
inline void ProcedureStatement_Write::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.Write.label)
}
#endif
inline void ProcedureStatement_Write::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.Write.label)
}
inline void ProcedureStatement_Write::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.Write.label)
}
inline ::std::string* ProcedureStatement_Write::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Write.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_Write::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.Write.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_Write::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.Write.label)
}

// -------------------------------------------------------------------

// ProcedureStatement_Read

// string name = 1;
inline void ProcedureStatement_Read::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_Read::name() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Read.name)
  return name_.GetNoArena();
}
inline void ProcedureStatement_Read::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.Read.name)
}
#if LANG_CXX11
inline void ProcedureStatement_Read::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.Read.name)
}
#endif
inline void ProcedureStatement_Read::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.Read.name)
}
inline void ProcedureStatement_Read::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.Read.name)
}
inline ::std::string* ProcedureStatement_Read::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Read.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_Read::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.Read.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_Read::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.Read.name)
}

// .Pasc.Expression file = 2;
inline bool ProcedureStatement_Read::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline const ::Pasc::Expression& ProcedureStatement_Read::_internal_file() const {
  return *file_;
}
inline const ::Pasc::Expression& ProcedureStatement_Read::file() const {
  const ::Pasc::Expression* p = file_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Read.file)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStatement_Read::release_file() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.Read.file)
  
  ::Pasc::Expression* temp = file_;
  file_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStatement_Read::mutable_file() {
  
  if (file_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    file_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Read.file)
  return file_;
}
inline void ProcedureStatement_Read::set_allocated_file(::Pasc::Expression* file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(file_);
  }
  if (file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.Read.file)
}

// repeated .Pasc.Expression varAccess = 3;
inline int ProcedureStatement_Read::varaccess_size() const {
  return varaccess_.size();
}
inline ::Pasc::Expression* ProcedureStatement_Read::mutable_varaccess(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Read.varAccess)
  return varaccess_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStatement_Read::mutable_varaccess() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStatement.Read.varAccess)
  return &varaccess_;
}
inline const ::Pasc::Expression& ProcedureStatement_Read::varaccess(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Read.varAccess)
  return varaccess_.Get(index);
}
inline ::Pasc::Expression* ProcedureStatement_Read::add_varaccess() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStatement.Read.varAccess)
  return varaccess_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStatement_Read::varaccess() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStatement.Read.varAccess)
  return varaccess_;
}

// string label = 4;
inline void ProcedureStatement_Read::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_Read::label() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.Read.label)
  return label_.GetNoArena();
}
inline void ProcedureStatement_Read::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.Read.label)
}
#if LANG_CXX11
inline void ProcedureStatement_Read::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.Read.label)
}
#endif
inline void ProcedureStatement_Read::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.Read.label)
}
inline void ProcedureStatement_Read::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.Read.label)
}
inline ::std::string* ProcedureStatement_Read::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.Read.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_Read::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.Read.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_Read::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.Read.label)
}

// -------------------------------------------------------------------

// ProcedureStatement_ReadLn

// string name = 1;
inline void ProcedureStatement_ReadLn::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_ReadLn::name() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ReadLn.name)
  return name_.GetNoArena();
}
inline void ProcedureStatement_ReadLn::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.ReadLn.name)
}
#if LANG_CXX11
inline void ProcedureStatement_ReadLn::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.ReadLn.name)
}
#endif
inline void ProcedureStatement_ReadLn::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.ReadLn.name)
}
inline void ProcedureStatement_ReadLn::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.ReadLn.name)
}
inline ::std::string* ProcedureStatement_ReadLn::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ReadLn.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_ReadLn::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ReadLn.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_ReadLn::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.ReadLn.name)
}

// .Pasc.Expression file = 2;
inline bool ProcedureStatement_ReadLn::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline const ::Pasc::Expression& ProcedureStatement_ReadLn::_internal_file() const {
  return *file_;
}
inline const ::Pasc::Expression& ProcedureStatement_ReadLn::file() const {
  const ::Pasc::Expression* p = file_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ReadLn.file)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStatement_ReadLn::release_file() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ReadLn.file)
  
  ::Pasc::Expression* temp = file_;
  file_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStatement_ReadLn::mutable_file() {
  
  if (file_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    file_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ReadLn.file)
  return file_;
}
inline void ProcedureStatement_ReadLn::set_allocated_file(::Pasc::Expression* file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(file_);
  }
  if (file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.ReadLn.file)
}

// repeated .Pasc.Expression varAccess = 3;
inline int ProcedureStatement_ReadLn::varaccess_size() const {
  return varaccess_.size();
}
inline ::Pasc::Expression* ProcedureStatement_ReadLn::mutable_varaccess(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ReadLn.varAccess)
  return varaccess_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStatement_ReadLn::mutable_varaccess() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStatement.ReadLn.varAccess)
  return &varaccess_;
}
inline const ::Pasc::Expression& ProcedureStatement_ReadLn::varaccess(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ReadLn.varAccess)
  return varaccess_.Get(index);
}
inline ::Pasc::Expression* ProcedureStatement_ReadLn::add_varaccess() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStatement.ReadLn.varAccess)
  return varaccess_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStatement_ReadLn::varaccess() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStatement.ReadLn.varAccess)
  return varaccess_;
}

// string label = 4;
inline void ProcedureStatement_ReadLn::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_ReadLn::label() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ReadLn.label)
  return label_.GetNoArena();
}
inline void ProcedureStatement_ReadLn::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.ReadLn.label)
}
#if LANG_CXX11
inline void ProcedureStatement_ReadLn::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.ReadLn.label)
}
#endif
inline void ProcedureStatement_ReadLn::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.ReadLn.label)
}
inline void ProcedureStatement_ReadLn::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.ReadLn.label)
}
inline ::std::string* ProcedureStatement_ReadLn::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ReadLn.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_ReadLn::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ReadLn.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_ReadLn::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.ReadLn.label)
}

// -------------------------------------------------------------------

// ProcedureStatement_ProcStmt

// .Pasc.Expression name = 1;
inline bool ProcedureStatement_ProcStmt::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline const ::Pasc::Expression& ProcedureStatement_ProcStmt::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Expression& ProcedureStatement_ProcStmt::name() const {
  const ::Pasc::Expression* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ProcStmt.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ProcStmt.name)
  
  ::Pasc::Expression* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ProcStmt.name)
  return name_;
}
inline void ProcedureStatement_ProcStmt::set_allocated_name(::Pasc::Expression* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(name_);
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.ProcStmt.name)
}

// repeated .Pasc.Expression params = 2;
inline int ProcedureStatement_ProcStmt::params_size() const {
  return params_.size();
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ProcStmt.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStatement_ProcStmt::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStatement.ProcStmt.params)
  return &params_;
}
inline const ::Pasc::Expression& ProcedureStatement_ProcStmt::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ProcStmt.params)
  return params_.Get(index);
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::add_params() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStatement.ProcStmt.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStatement_ProcStmt::params() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStatement.ProcStmt.params)
  return params_;
}

// string label = 3;
inline void ProcedureStatement_ProcStmt::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_ProcStmt::label() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ProcStmt.label)
  return label_.GetNoArena();
}
inline void ProcedureStatement_ProcStmt::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.ProcStmt.label)
}
#if LANG_CXX11
inline void ProcedureStatement_ProcStmt::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.ProcStmt.label)
}
#endif
inline void ProcedureStatement_ProcStmt::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.ProcStmt.label)
}
inline void ProcedureStatement_ProcStmt::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.ProcStmt.label)
}
inline ::std::string* ProcedureStatement_ProcStmt::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ProcStmt.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_ProcStmt::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ProcStmt.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_ProcStmt::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.ProcStmt.label)
}

// -------------------------------------------------------------------

// ProcedureStatement

// .Pasc.ProcedureStatement.PSKind kind = 1;
inline void ProcedureStatement::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::ProcedureStatement_PSKind ProcedureStatement::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.kind)
  return static_cast< ::Pasc::ProcedureStatement_PSKind >(kind_);
}
inline void ProcedureStatement::set_kind(::Pasc::ProcedureStatement_PSKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.kind)
}

// .Pasc.ProcedureStatement.Write wrt = 2;
inline bool ProcedureStatement::has_wrt() const {
  return stmt_case() == kWrt;
}
inline void ProcedureStatement::set_has_wrt() {
  _oneof_case_[0] = kWrt;
}
inline void ProcedureStatement::clear_wrt() {
  if (has_wrt()) {
    delete stmt_.wrt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_Write& ProcedureStatement::_internal_wrt() const {
  return *stmt_.wrt_;
}
inline ::Pasc::ProcedureStatement_Write* ProcedureStatement::release_wrt() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.wrt)
  if (has_wrt()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_Write* temp = stmt_.wrt_;
    stmt_.wrt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_Write& ProcedureStatement::wrt() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.wrt)
  return has_wrt()
      ? *stmt_.wrt_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_Write*>(&::Pasc::_ProcedureStatement_Write_default_instance_);
}
inline ::Pasc::ProcedureStatement_Write* ProcedureStatement::mutable_wrt() {
  if (!has_wrt()) {
    clear_stmt();
    set_has_wrt();
    stmt_.wrt_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_Write >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.wrt)
  return stmt_.wrt_;
}

// .Pasc.ProcedureStatement.WriteLn wrtLn = 3;
inline bool ProcedureStatement::has_wrtln() const {
  return stmt_case() == kWrtLn;
}
inline void ProcedureStatement::set_has_wrtln() {
  _oneof_case_[0] = kWrtLn;
}
inline void ProcedureStatement::clear_wrtln() {
  if (has_wrtln()) {
    delete stmt_.wrtln_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_WriteLn& ProcedureStatement::_internal_wrtln() const {
  return *stmt_.wrtln_;
}
inline ::Pasc::ProcedureStatement_WriteLn* ProcedureStatement::release_wrtln() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.wrtLn)
  if (has_wrtln()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_WriteLn* temp = stmt_.wrtln_;
    stmt_.wrtln_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_WriteLn& ProcedureStatement::wrtln() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.wrtLn)
  return has_wrtln()
      ? *stmt_.wrtln_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_WriteLn*>(&::Pasc::_ProcedureStatement_WriteLn_default_instance_);
}
inline ::Pasc::ProcedureStatement_WriteLn* ProcedureStatement::mutable_wrtln() {
  if (!has_wrtln()) {
    clear_stmt();
    set_has_wrtln();
    stmt_.wrtln_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_WriteLn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.wrtLn)
  return stmt_.wrtln_;
}

// .Pasc.ProcedureStatement.Read rd = 4;
inline bool ProcedureStatement::has_rd() const {
  return stmt_case() == kRd;
}
inline void ProcedureStatement::set_has_rd() {
  _oneof_case_[0] = kRd;
}
inline void ProcedureStatement::clear_rd() {
  if (has_rd()) {
    delete stmt_.rd_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_Read& ProcedureStatement::_internal_rd() const {
  return *stmt_.rd_;
}
inline ::Pasc::ProcedureStatement_Read* ProcedureStatement::release_rd() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.rd)
  if (has_rd()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_Read* temp = stmt_.rd_;
    stmt_.rd_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_Read& ProcedureStatement::rd() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.rd)
  return has_rd()
      ? *stmt_.rd_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_Read*>(&::Pasc::_ProcedureStatement_Read_default_instance_);
}
inline ::Pasc::ProcedureStatement_Read* ProcedureStatement::mutable_rd() {
  if (!has_rd()) {
    clear_stmt();
    set_has_rd();
    stmt_.rd_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_Read >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.rd)
  return stmt_.rd_;
}

// .Pasc.ProcedureStatement.ReadLn rdLn = 5;
inline bool ProcedureStatement::has_rdln() const {
  return stmt_case() == kRdLn;
}
inline void ProcedureStatement::set_has_rdln() {
  _oneof_case_[0] = kRdLn;
}
inline void ProcedureStatement::clear_rdln() {
  if (has_rdln()) {
    delete stmt_.rdln_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_ReadLn& ProcedureStatement::_internal_rdln() const {
  return *stmt_.rdln_;
}
inline ::Pasc::ProcedureStatement_ReadLn* ProcedureStatement::release_rdln() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.rdLn)
  if (has_rdln()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_ReadLn* temp = stmt_.rdln_;
    stmt_.rdln_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_ReadLn& ProcedureStatement::rdln() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.rdLn)
  return has_rdln()
      ? *stmt_.rdln_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_ReadLn*>(&::Pasc::_ProcedureStatement_ReadLn_default_instance_);
}
inline ::Pasc::ProcedureStatement_ReadLn* ProcedureStatement::mutable_rdln() {
  if (!has_rdln()) {
    clear_stmt();
    set_has_rdln();
    stmt_.rdln_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_ReadLn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.rdLn)
  return stmt_.rdln_;
}

// .Pasc.ProcedureStatement.ProcStmt ps = 6;
inline bool ProcedureStatement::has_ps() const {
  return stmt_case() == kPs;
}
inline void ProcedureStatement::set_has_ps() {
  _oneof_case_[0] = kPs;
}
inline void ProcedureStatement::clear_ps() {
  if (has_ps()) {
    delete stmt_.ps_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_ProcStmt& ProcedureStatement::_internal_ps() const {
  return *stmt_.ps_;
}
inline ::Pasc::ProcedureStatement_ProcStmt* ProcedureStatement::release_ps() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ps)
  if (has_ps()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_ProcStmt* temp = stmt_.ps_;
    stmt_.ps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_ProcStmt& ProcedureStatement::ps() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ps)
  return has_ps()
      ? *stmt_.ps_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_ProcStmt*>(&::Pasc::_ProcedureStatement_ProcStmt_default_instance_);
}
inline ::Pasc::ProcedureStatement_ProcStmt* ProcedureStatement::mutable_ps() {
  if (!has_ps()) {
    clear_stmt();
    set_has_ps();
    stmt_.ps_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_ProcStmt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ps)
  return stmt_.ps_;
}

inline bool ProcedureStatement::has_stmt() const {
  return stmt_case() != STMT_NOT_SET;
}
inline void ProcedureStatement::clear_has_stmt() {
  _oneof_case_[0] = STMT_NOT_SET;
}
inline ProcedureStatement::StmtCase ProcedureStatement::stmt_case() const {
  return ProcedureStatement::StmtCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AssignStatement

// .Pasc.Expression variable = 1;
inline bool AssignStatement::has_variable() const {
  return this != internal_default_instance() && variable_ != NULL;
}
inline const ::Pasc::Expression& AssignStatement::_internal_variable() const {
  return *variable_;
}
inline const ::Pasc::Expression& AssignStatement::variable() const {
  const ::Pasc::Expression* p = variable_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStatement.variable)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* AssignStatement::release_variable() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStatement.variable)
  
  ::Pasc::Expression* temp = variable_;
  variable_ = NULL;
  return temp;
}
inline ::Pasc::Expression* AssignStatement::mutable_variable() {
  
  if (variable_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    variable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStatement.variable)
  return variable_;
}
inline void AssignStatement::set_allocated_variable(::Pasc::Expression* variable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(variable_);
  }
  if (variable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      variable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, variable, submessage_arena);
    }
    
  } else {
    
  }
  variable_ = variable;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStatement.variable)
}

// .Pasc.Expression value = 2;
inline bool AssignStatement::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::Pasc::Expression& AssignStatement::_internal_value() const {
  return *value_;
}
inline const ::Pasc::Expression& AssignStatement::value() const {
  const ::Pasc::Expression* p = value_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStatement.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* AssignStatement::release_value() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStatement.value)
  
  ::Pasc::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Pasc::Expression* AssignStatement::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStatement.value)
  return value_;
}
inline void AssignStatement::set_allocated_value(::Pasc::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStatement.value)
}

// string label = 3;
inline void AssignStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AssignStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.AssignStatement.label)
  return label_.GetNoArena();
}
inline void AssignStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.AssignStatement.label)
}
#if LANG_CXX11
inline void AssignStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.AssignStatement.label)
}
#endif
inline void AssignStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.AssignStatement.label)
}
inline void AssignStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.AssignStatement.label)
}
inline ::std::string* AssignStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AssignStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AssignStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStatement.label)
}

// -------------------------------------------------------------------

// IfStatement

// .Pasc.Expression cond = 1;
inline bool IfStatement::has_cond() const {
  return this != internal_default_instance() && cond_ != NULL;
}
inline const ::Pasc::Expression& IfStatement::_internal_cond() const {
  return *cond_;
}
inline const ::Pasc::Expression& IfStatement::cond() const {
  const ::Pasc::Expression* p = cond_;
  // @@protoc_insertion_point(field_get:Pasc.IfStatement.cond)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* IfStatement::release_cond() {
  // @@protoc_insertion_point(field_release:Pasc.IfStatement.cond)
  
  ::Pasc::Expression* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline ::Pasc::Expression* IfStatement::mutable_cond() {
  
  if (cond_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStatement.cond)
  return cond_;
}
inline void IfStatement::set_allocated_cond(::Pasc::Expression* cond) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cond_);
  }
  if (cond) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cond = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    
  } else {
    
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStatement.cond)
}

// .Pasc.Statement truePath = 2;
inline bool IfStatement::has_truepath() const {
  return this != internal_default_instance() && truepath_ != NULL;
}
inline void IfStatement::clear_truepath() {
  if (GetArenaNoVirtual() == NULL && truepath_ != NULL) {
    delete truepath_;
  }
  truepath_ = NULL;
}
inline const ::Pasc::Statement& IfStatement::_internal_truepath() const {
  return *truepath_;
}
inline const ::Pasc::Statement& IfStatement::truepath() const {
  const ::Pasc::Statement* p = truepath_;
  // @@protoc_insertion_point(field_get:Pasc.IfStatement.truePath)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* IfStatement::release_truepath() {
  // @@protoc_insertion_point(field_release:Pasc.IfStatement.truePath)
  
  ::Pasc::Statement* temp = truepath_;
  truepath_ = NULL;
  return temp;
}
inline ::Pasc::Statement* IfStatement::mutable_truepath() {
  
  if (truepath_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    truepath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStatement.truePath)
  return truepath_;
}
inline void IfStatement::set_allocated_truepath(::Pasc::Statement* truepath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete truepath_;
  }
  if (truepath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      truepath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, truepath, submessage_arena);
    }
    
  } else {
    
  }
  truepath_ = truepath;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStatement.truePath)
}

// .Pasc.Statement elsePath = 3;
inline bool IfStatement::has_elsepath() const {
  return this != internal_default_instance() && elsepath_ != NULL;
}
inline void IfStatement::clear_elsepath() {
  if (GetArenaNoVirtual() == NULL && elsepath_ != NULL) {
    delete elsepath_;
  }
  elsepath_ = NULL;
}
inline const ::Pasc::Statement& IfStatement::_internal_elsepath() const {
  return *elsepath_;
}
inline const ::Pasc::Statement& IfStatement::elsepath() const {
  const ::Pasc::Statement* p = elsepath_;
  // @@protoc_insertion_point(field_get:Pasc.IfStatement.elsePath)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* IfStatement::release_elsepath() {
  // @@protoc_insertion_point(field_release:Pasc.IfStatement.elsePath)
  
  ::Pasc::Statement* temp = elsepath_;
  elsepath_ = NULL;
  return temp;
}
inline ::Pasc::Statement* IfStatement::mutable_elsepath() {
  
  if (elsepath_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    elsepath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStatement.elsePath)
  return elsepath_;
}
inline void IfStatement::set_allocated_elsepath(::Pasc::Statement* elsepath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete elsepath_;
  }
  if (elsepath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      elsepath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, elsepath, submessage_arena);
    }
    
  } else {
    
  }
  elsepath_ = elsepath;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStatement.elsePath)
}

// string label = 4;
inline void IfStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& IfStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.IfStatement.label)
  return label_.GetNoArena();
}
inline void IfStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.IfStatement.label)
}
#if LANG_CXX11
inline void IfStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.IfStatement.label)
}
#endif
inline void IfStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.IfStatement.label)
}
inline void IfStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.IfStatement.label)
}
inline ::std::string* IfStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.IfStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.IfStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStatement.label)
}

// -------------------------------------------------------------------

// ReturnStatement

// .Pasc.Expression value = 1;
inline bool ReturnStatement::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::Pasc::Expression& ReturnStatement::_internal_value() const {
  return *value_;
}
inline const ::Pasc::Expression& ReturnStatement::value() const {
  const ::Pasc::Expression* p = value_;
  // @@protoc_insertion_point(field_get:Pasc.ReturnStatement.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ReturnStatement::release_value() {
  // @@protoc_insertion_point(field_release:Pasc.ReturnStatement.value)
  
  ::Pasc::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ReturnStatement::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ReturnStatement.value)
  return value_;
}
inline void ReturnStatement::set_allocated_value(::Pasc::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ReturnStatement.value)
}

// string label = 2;
inline void ReturnStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReturnStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.ReturnStatement.label)
  return label_.GetNoArena();
}
inline void ReturnStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ReturnStatement.label)
}
#if LANG_CXX11
inline void ReturnStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ReturnStatement.label)
}
#endif
inline void ReturnStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ReturnStatement.label)
}
inline void ReturnStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ReturnStatement.label)
}
inline ::std::string* ReturnStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ReturnStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReturnStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.ReturnStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReturnStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ReturnStatement.label)
}

// -------------------------------------------------------------------

// WhileStatement

// .Pasc.Expression cond = 1;
inline bool WhileStatement::has_cond() const {
  return this != internal_default_instance() && cond_ != NULL;
}
inline const ::Pasc::Expression& WhileStatement::_internal_cond() const {
  return *cond_;
}
inline const ::Pasc::Expression& WhileStatement::cond() const {
  const ::Pasc::Expression* p = cond_;
  // @@protoc_insertion_point(field_get:Pasc.WhileStatement.cond)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* WhileStatement::release_cond() {
  // @@protoc_insertion_point(field_release:Pasc.WhileStatement.cond)
  
  ::Pasc::Expression* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline ::Pasc::Expression* WhileStatement::mutable_cond() {
  
  if (cond_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WhileStatement.cond)
  return cond_;
}
inline void WhileStatement::set_allocated_cond(::Pasc::Expression* cond) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cond_);
  }
  if (cond) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cond = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    
  } else {
    
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WhileStatement.cond)
}

// .Pasc.Statement body = 2;
inline bool WhileStatement::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void WhileStatement::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::Pasc::Statement& WhileStatement::_internal_body() const {
  return *body_;
}
inline const ::Pasc::Statement& WhileStatement::body() const {
  const ::Pasc::Statement* p = body_;
  // @@protoc_insertion_point(field_get:Pasc.WhileStatement.body)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* WhileStatement::release_body() {
  // @@protoc_insertion_point(field_release:Pasc.WhileStatement.body)
  
  ::Pasc::Statement* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::Pasc::Statement* WhileStatement::mutable_body() {
  
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WhileStatement.body)
  return body_;
}
inline void WhileStatement::set_allocated_body(::Pasc::Statement* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WhileStatement.body)
}

// string label = 3;
inline void WhileStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WhileStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.WhileStatement.label)
  return label_.GetNoArena();
}
inline void WhileStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.WhileStatement.label)
}
#if LANG_CXX11
inline void WhileStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.WhileStatement.label)
}
#endif
inline void WhileStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.WhileStatement.label)
}
inline void WhileStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.WhileStatement.label)
}
inline ::std::string* WhileStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.WhileStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WhileStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.WhileStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WhileStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.WhileStatement.label)
}

// -------------------------------------------------------------------

// CompoundStatement

// repeated .Pasc.Statement stmts = 1;
inline int CompoundStatement::stmts_size() const {
  return stmts_.size();
}
inline void CompoundStatement::clear_stmts() {
  stmts_.Clear();
}
inline ::Pasc::Statement* CompoundStatement::mutable_stmts(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.CompoundStatement.stmts)
  return stmts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
CompoundStatement::mutable_stmts() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.CompoundStatement.stmts)
  return &stmts_;
}
inline const ::Pasc::Statement& CompoundStatement::stmts(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.CompoundStatement.stmts)
  return stmts_.Get(index);
}
inline ::Pasc::Statement* CompoundStatement::add_stmts() {
  // @@protoc_insertion_point(field_add:Pasc.CompoundStatement.stmts)
  return stmts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
CompoundStatement::stmts() const {
  // @@protoc_insertion_point(field_list:Pasc.CompoundStatement.stmts)
  return stmts_;
}

// string label = 2;
inline void CompoundStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CompoundStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.CompoundStatement.label)
  return label_.GetNoArena();
}
inline void CompoundStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.CompoundStatement.label)
}
#if LANG_CXX11
inline void CompoundStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.CompoundStatement.label)
}
#endif
inline void CompoundStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.CompoundStatement.label)
}
inline void CompoundStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.CompoundStatement.label)
}
inline ::std::string* CompoundStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.CompoundStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompoundStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.CompoundStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompoundStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.CompoundStatement.label)
}

// -------------------------------------------------------------------

// RepeatStatement

// repeated .Pasc.Statement stmts = 1;
inline int RepeatStatement::stmts_size() const {
  return stmts_.size();
}
inline void RepeatStatement::clear_stmts() {
  stmts_.Clear();
}
inline ::Pasc::Statement* RepeatStatement::mutable_stmts(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.RepeatStatement.stmts)
  return stmts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
RepeatStatement::mutable_stmts() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.RepeatStatement.stmts)
  return &stmts_;
}
inline const ::Pasc::Statement& RepeatStatement::stmts(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.RepeatStatement.stmts)
  return stmts_.Get(index);
}
inline ::Pasc::Statement* RepeatStatement::add_stmts() {
  // @@protoc_insertion_point(field_add:Pasc.RepeatStatement.stmts)
  return stmts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
RepeatStatement::stmts() const {
  // @@protoc_insertion_point(field_list:Pasc.RepeatStatement.stmts)
  return stmts_;
}

// .Pasc.Expression cond = 2;
inline bool RepeatStatement::has_cond() const {
  return this != internal_default_instance() && cond_ != NULL;
}
inline const ::Pasc::Expression& RepeatStatement::_internal_cond() const {
  return *cond_;
}
inline const ::Pasc::Expression& RepeatStatement::cond() const {
  const ::Pasc::Expression* p = cond_;
  // @@protoc_insertion_point(field_get:Pasc.RepeatStatement.cond)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* RepeatStatement::release_cond() {
  // @@protoc_insertion_point(field_release:Pasc.RepeatStatement.cond)
  
  ::Pasc::Expression* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline ::Pasc::Expression* RepeatStatement::mutable_cond() {
  
  if (cond_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.RepeatStatement.cond)
  return cond_;
}
inline void RepeatStatement::set_allocated_cond(::Pasc::Expression* cond) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(cond_);
  }
  if (cond) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cond = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    
  } else {
    
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:Pasc.RepeatStatement.cond)
}

// string label = 3;
inline void RepeatStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RepeatStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.RepeatStatement.label)
  return label_.GetNoArena();
}
inline void RepeatStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.RepeatStatement.label)
}
#if LANG_CXX11
inline void RepeatStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.RepeatStatement.label)
}
#endif
inline void RepeatStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.RepeatStatement.label)
}
inline void RepeatStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.RepeatStatement.label)
}
inline ::std::string* RepeatStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.RepeatStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RepeatStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.RepeatStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RepeatStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.RepeatStatement.label)
}

// -------------------------------------------------------------------

// ForStatement

// .Pasc.Expression ctlVar = 1;
inline bool ForStatement::has_ctlvar() const {
  return this != internal_default_instance() && ctlvar_ != NULL;
}
inline const ::Pasc::Expression& ForStatement::_internal_ctlvar() const {
  return *ctlvar_;
}
inline const ::Pasc::Expression& ForStatement::ctlvar() const {
  const ::Pasc::Expression* p = ctlvar_;
  // @@protoc_insertion_point(field_get:Pasc.ForStatement.ctlVar)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ForStatement::release_ctlvar() {
  // @@protoc_insertion_point(field_release:Pasc.ForStatement.ctlVar)
  
  ::Pasc::Expression* temp = ctlvar_;
  ctlvar_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ForStatement::mutable_ctlvar() {
  
  if (ctlvar_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    ctlvar_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ForStatement.ctlVar)
  return ctlvar_;
}
inline void ForStatement::set_allocated_ctlvar(::Pasc::Expression* ctlvar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(ctlvar_);
  }
  if (ctlvar) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ctlvar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ctlvar, submessage_arena);
    }
    
  } else {
    
  }
  ctlvar_ = ctlvar;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ForStatement.ctlVar)
}

// .Pasc.Expression initValue = 2;
inline bool ForStatement::has_initvalue() const {
  return this != internal_default_instance() && initvalue_ != NULL;
}
inline const ::Pasc::Expression& ForStatement::_internal_initvalue() const {
  return *initvalue_;
}
inline const ::Pasc::Expression& ForStatement::initvalue() const {
  const ::Pasc::Expression* p = initvalue_;
  // @@protoc_insertion_point(field_get:Pasc.ForStatement.initValue)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ForStatement::release_initvalue() {
  // @@protoc_insertion_point(field_release:Pasc.ForStatement.initValue)
  
  ::Pasc::Expression* temp = initvalue_;
  initvalue_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ForStatement::mutable_initvalue() {
  
  if (initvalue_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    initvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ForStatement.initValue)
  return initvalue_;
}
inline void ForStatement::set_allocated_initvalue(::Pasc::Expression* initvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(initvalue_);
  }
  if (initvalue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      initvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, initvalue, submessage_arena);
    }
    
  } else {
    
  }
  initvalue_ = initvalue;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ForStatement.initValue)
}

// .Pasc.Expression finalValue = 3;
inline bool ForStatement::has_finalvalue() const {
  return this != internal_default_instance() && finalvalue_ != NULL;
}
inline const ::Pasc::Expression& ForStatement::_internal_finalvalue() const {
  return *finalvalue_;
}
inline const ::Pasc::Expression& ForStatement::finalvalue() const {
  const ::Pasc::Expression* p = finalvalue_;
  // @@protoc_insertion_point(field_get:Pasc.ForStatement.finalValue)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ForStatement::release_finalvalue() {
  // @@protoc_insertion_point(field_release:Pasc.ForStatement.finalValue)
  
  ::Pasc::Expression* temp = finalvalue_;
  finalvalue_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ForStatement::mutable_finalvalue() {
  
  if (finalvalue_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    finalvalue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ForStatement.finalValue)
  return finalvalue_;
}
inline void ForStatement::set_allocated_finalvalue(::Pasc::Expression* finalvalue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(finalvalue_);
  }
  if (finalvalue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      finalvalue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, finalvalue, submessage_arena);
    }
    
  } else {
    
  }
  finalvalue_ = finalvalue;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ForStatement.finalValue)
}

// .Pasc.Statement body = 4;
inline bool ForStatement::has_body() const {
  return this != internal_default_instance() && body_ != NULL;
}
inline void ForStatement::clear_body() {
  if (GetArenaNoVirtual() == NULL && body_ != NULL) {
    delete body_;
  }
  body_ = NULL;
}
inline const ::Pasc::Statement& ForStatement::_internal_body() const {
  return *body_;
}
inline const ::Pasc::Statement& ForStatement::body() const {
  const ::Pasc::Statement* p = body_;
  // @@protoc_insertion_point(field_get:Pasc.ForStatement.body)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* ForStatement::release_body() {
  // @@protoc_insertion_point(field_release:Pasc.ForStatement.body)
  
  ::Pasc::Statement* temp = body_;
  body_ = NULL;
  return temp;
}
inline ::Pasc::Statement* ForStatement::mutable_body() {
  
  if (body_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    body_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ForStatement.body)
  return body_;
}
inline void ForStatement::set_allocated_body(::Pasc::Statement* body) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete body_;
  }
  if (body) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      body = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, body, submessage_arena);
    }
    
  } else {
    
  }
  body_ = body;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ForStatement.body)
}

// .Pasc.TokenKind dir = 5;
inline void ForStatement::clear_dir() {
  dir_ = 0;
}
inline ::Pasc::TokenKind ForStatement::dir() const {
  // @@protoc_insertion_point(field_get:Pasc.ForStatement.dir)
  return static_cast< ::Pasc::TokenKind >(dir_);
}
inline void ForStatement::set_dir(::Pasc::TokenKind value) {
  
  dir_ = value;
  // @@protoc_insertion_point(field_set:Pasc.ForStatement.dir)
}

// string label = 6;
inline void ForStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ForStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.ForStatement.label)
  return label_.GetNoArena();
}
inline void ForStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ForStatement.label)
}
#if LANG_CXX11
inline void ForStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ForStatement.label)
}
#endif
inline void ForStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ForStatement.label)
}
inline void ForStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ForStatement.label)
}
inline ::std::string* ForStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ForStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ForStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.ForStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ForStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ForStatement.label)
}

// -------------------------------------------------------------------

// CaseStatement_CaseListElement

// repeated .Pasc.Expression constants = 1;
inline int CaseStatement_CaseListElement::constants_size() const {
  return constants_.size();
}
inline ::Pasc::Expression* CaseStatement_CaseListElement::mutable_constants(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.CaseStatement.CaseListElement.constants)
  return constants_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
CaseStatement_CaseListElement::mutable_constants() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.CaseStatement.CaseListElement.constants)
  return &constants_;
}
inline const ::Pasc::Expression& CaseStatement_CaseListElement::constants(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.CaseStatement.CaseListElement.constants)
  return constants_.Get(index);
}
inline ::Pasc::Expression* CaseStatement_CaseListElement::add_constants() {
  // @@protoc_insertion_point(field_add:Pasc.CaseStatement.CaseListElement.constants)
  return constants_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
CaseStatement_CaseListElement::constants() const {
  // @@protoc_insertion_point(field_list:Pasc.CaseStatement.CaseListElement.constants)
  return constants_;
}

// .Pasc.Statement stmt = 2;
inline bool CaseStatement_CaseListElement::has_stmt() const {
  return this != internal_default_instance() && stmt_ != NULL;
}
inline void CaseStatement_CaseListElement::clear_stmt() {
  if (GetArenaNoVirtual() == NULL && stmt_ != NULL) {
    delete stmt_;
  }
  stmt_ = NULL;
}
inline const ::Pasc::Statement& CaseStatement_CaseListElement::_internal_stmt() const {
  return *stmt_;
}
inline const ::Pasc::Statement& CaseStatement_CaseListElement::stmt() const {
  const ::Pasc::Statement* p = stmt_;
  // @@protoc_insertion_point(field_get:Pasc.CaseStatement.CaseListElement.stmt)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* CaseStatement_CaseListElement::release_stmt() {
  // @@protoc_insertion_point(field_release:Pasc.CaseStatement.CaseListElement.stmt)
  
  ::Pasc::Statement* temp = stmt_;
  stmt_ = NULL;
  return temp;
}
inline ::Pasc::Statement* CaseStatement_CaseListElement::mutable_stmt() {
  
  if (stmt_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    stmt_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.CaseStatement.CaseListElement.stmt)
  return stmt_;
}
inline void CaseStatement_CaseListElement::set_allocated_stmt(::Pasc::Statement* stmt) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stmt_;
  }
  if (stmt) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stmt = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stmt, submessage_arena);
    }
    
  } else {
    
  }
  stmt_ = stmt;
  // @@protoc_insertion_point(field_set_allocated:Pasc.CaseStatement.CaseListElement.stmt)
}

// -------------------------------------------------------------------

// CaseStatement

// .Pasc.Expression caseIndex = 1;
inline bool CaseStatement::has_caseindex() const {
  return this != internal_default_instance() && caseindex_ != NULL;
}
inline const ::Pasc::Expression& CaseStatement::_internal_caseindex() const {
  return *caseindex_;
}
inline const ::Pasc::Expression& CaseStatement::caseindex() const {
  const ::Pasc::Expression* p = caseindex_;
  // @@protoc_insertion_point(field_get:Pasc.CaseStatement.caseIndex)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* CaseStatement::release_caseindex() {
  // @@protoc_insertion_point(field_release:Pasc.CaseStatement.caseIndex)
  
  ::Pasc::Expression* temp = caseindex_;
  caseindex_ = NULL;
  return temp;
}
inline ::Pasc::Expression* CaseStatement::mutable_caseindex() {
  
  if (caseindex_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    caseindex_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.CaseStatement.caseIndex)
  return caseindex_;
}
inline void CaseStatement::set_allocated_caseindex(::Pasc::Expression* caseindex) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(caseindex_);
  }
  if (caseindex) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      caseindex = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, caseindex, submessage_arena);
    }
    
  } else {
    
  }
  caseindex_ = caseindex;
  // @@protoc_insertion_point(field_set_allocated:Pasc.CaseStatement.caseIndex)
}

// repeated .Pasc.CaseStatement.CaseListElement cle = 2;
inline int CaseStatement::cle_size() const {
  return cle_.size();
}
inline void CaseStatement::clear_cle() {
  cle_.Clear();
}
inline ::Pasc::CaseStatement_CaseListElement* CaseStatement::mutable_cle(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.CaseStatement.cle)
  return cle_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::CaseStatement_CaseListElement >*
CaseStatement::mutable_cle() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.CaseStatement.cle)
  return &cle_;
}
inline const ::Pasc::CaseStatement_CaseListElement& CaseStatement::cle(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.CaseStatement.cle)
  return cle_.Get(index);
}
inline ::Pasc::CaseStatement_CaseListElement* CaseStatement::add_cle() {
  // @@protoc_insertion_point(field_add:Pasc.CaseStatement.cle)
  return cle_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::CaseStatement_CaseListElement >&
CaseStatement::cle() const {
  // @@protoc_insertion_point(field_list:Pasc.CaseStatement.cle)
  return cle_;
}

// string label = 3;
inline void CaseStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CaseStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.CaseStatement.label)
  return label_.GetNoArena();
}
inline void CaseStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.CaseStatement.label)
}
#if LANG_CXX11
inline void CaseStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.CaseStatement.label)
}
#endif
inline void CaseStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.CaseStatement.label)
}
inline void CaseStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.CaseStatement.label)
}
inline ::std::string* CaseStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.CaseStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CaseStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.CaseStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CaseStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.CaseStatement.label)
}

// -------------------------------------------------------------------

// GoToStatement

// string label = 1;
inline void GoToStatement::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GoToStatement::label() const {
  // @@protoc_insertion_point(field_get:Pasc.GoToStatement.label)
  return label_.GetNoArena();
}
inline void GoToStatement::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.GoToStatement.label)
}
#if LANG_CXX11
inline void GoToStatement::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.GoToStatement.label)
}
#endif
inline void GoToStatement::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.GoToStatement.label)
}
inline void GoToStatement::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.GoToStatement.label)
}
inline ::std::string* GoToStatement::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.GoToStatement.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GoToStatement::release_label() {
  // @@protoc_insertion_point(field_release:Pasc.GoToStatement.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GoToStatement::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:Pasc.GoToStatement.label)
}

// -------------------------------------------------------------------

// Statement

// .Pasc.Statement.StmtKind kind = 1;
inline void Statement::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Statement_StmtKind Statement::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.kind)
  return static_cast< ::Pasc::Statement_StmtKind >(kind_);
}
inline void Statement::set_kind(::Pasc::Statement_StmtKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Statement.kind)
}

// .Pasc.AssignStatement assignStmt = 2;
inline bool Statement::has_assignstmt() const {
  return stmt_case() == kAssignStmt;
}
inline void Statement::set_has_assignstmt() {
  _oneof_case_[0] = kAssignStmt;
}
inline void Statement::clear_assignstmt() {
  if (has_assignstmt()) {
    delete stmt_.assignstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::AssignStatement& Statement::_internal_assignstmt() const {
  return *stmt_.assignstmt_;
}
inline ::Pasc::AssignStatement* Statement::release_assignstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.assignStmt)
  if (has_assignstmt()) {
    clear_has_stmt();
      ::Pasc::AssignStatement* temp = stmt_.assignstmt_;
    stmt_.assignstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::AssignStatement& Statement::assignstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.assignStmt)
  return has_assignstmt()
      ? *stmt_.assignstmt_
      : *reinterpret_cast< ::Pasc::AssignStatement*>(&::Pasc::_AssignStatement_default_instance_);
}
inline ::Pasc::AssignStatement* Statement::mutable_assignstmt() {
  if (!has_assignstmt()) {
    clear_stmt();
    set_has_assignstmt();
    stmt_.assignstmt_ = CreateMaybeMessage< ::Pasc::AssignStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.assignStmt)
  return stmt_.assignstmt_;
}

// .Pasc.ProcedureStatement procStmt = 3;
inline bool Statement::has_procstmt() const {
  return stmt_case() == kProcStmt;
}
inline void Statement::set_has_procstmt() {
  _oneof_case_[0] = kProcStmt;
}
inline void Statement::clear_procstmt() {
  if (has_procstmt()) {
    delete stmt_.procstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement& Statement::_internal_procstmt() const {
  return *stmt_.procstmt_;
}
inline ::Pasc::ProcedureStatement* Statement::release_procstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.procStmt)
  if (has_procstmt()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement* temp = stmt_.procstmt_;
    stmt_.procstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement& Statement::procstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.procStmt)
  return has_procstmt()
      ? *stmt_.procstmt_
      : *reinterpret_cast< ::Pasc::ProcedureStatement*>(&::Pasc::_ProcedureStatement_default_instance_);
}
inline ::Pasc::ProcedureStatement* Statement::mutable_procstmt() {
  if (!has_procstmt()) {
    clear_stmt();
    set_has_procstmt();
    stmt_.procstmt_ = CreateMaybeMessage< ::Pasc::ProcedureStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.procStmt)
  return stmt_.procstmt_;
}

// .Pasc.IfStatement ifStmt = 4;
inline bool Statement::has_ifstmt() const {
  return stmt_case() == kIfStmt;
}
inline void Statement::set_has_ifstmt() {
  _oneof_case_[0] = kIfStmt;
}
inline void Statement::clear_ifstmt() {
  if (has_ifstmt()) {
    delete stmt_.ifstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::IfStatement& Statement::_internal_ifstmt() const {
  return *stmt_.ifstmt_;
}
inline ::Pasc::IfStatement* Statement::release_ifstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.ifStmt)
  if (has_ifstmt()) {
    clear_has_stmt();
      ::Pasc::IfStatement* temp = stmt_.ifstmt_;
    stmt_.ifstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::IfStatement& Statement::ifstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.ifStmt)
  return has_ifstmt()
      ? *stmt_.ifstmt_
      : *reinterpret_cast< ::Pasc::IfStatement*>(&::Pasc::_IfStatement_default_instance_);
}
inline ::Pasc::IfStatement* Statement::mutable_ifstmt() {
  if (!has_ifstmt()) {
    clear_stmt();
    set_has_ifstmt();
    stmt_.ifstmt_ = CreateMaybeMessage< ::Pasc::IfStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.ifStmt)
  return stmt_.ifstmt_;
}

// .Pasc.ReturnStatement retStmt = 5;
inline bool Statement::has_retstmt() const {
  return stmt_case() == kRetStmt;
}
inline void Statement::set_has_retstmt() {
  _oneof_case_[0] = kRetStmt;
}
inline void Statement::clear_retstmt() {
  if (has_retstmt()) {
    delete stmt_.retstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ReturnStatement& Statement::_internal_retstmt() const {
  return *stmt_.retstmt_;
}
inline ::Pasc::ReturnStatement* Statement::release_retstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.retStmt)
  if (has_retstmt()) {
    clear_has_stmt();
      ::Pasc::ReturnStatement* temp = stmt_.retstmt_;
    stmt_.retstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ReturnStatement& Statement::retstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.retStmt)
  return has_retstmt()
      ? *stmt_.retstmt_
      : *reinterpret_cast< ::Pasc::ReturnStatement*>(&::Pasc::_ReturnStatement_default_instance_);
}
inline ::Pasc::ReturnStatement* Statement::mutable_retstmt() {
  if (!has_retstmt()) {
    clear_stmt();
    set_has_retstmt();
    stmt_.retstmt_ = CreateMaybeMessage< ::Pasc::ReturnStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.retStmt)
  return stmt_.retstmt_;
}

// .Pasc.WhileStatement whileStmt = 6;
inline bool Statement::has_whilestmt() const {
  return stmt_case() == kWhileStmt;
}
inline void Statement::set_has_whilestmt() {
  _oneof_case_[0] = kWhileStmt;
}
inline void Statement::clear_whilestmt() {
  if (has_whilestmt()) {
    delete stmt_.whilestmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::WhileStatement& Statement::_internal_whilestmt() const {
  return *stmt_.whilestmt_;
}
inline ::Pasc::WhileStatement* Statement::release_whilestmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.whileStmt)
  if (has_whilestmt()) {
    clear_has_stmt();
      ::Pasc::WhileStatement* temp = stmt_.whilestmt_;
    stmt_.whilestmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::WhileStatement& Statement::whilestmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.whileStmt)
  return has_whilestmt()
      ? *stmt_.whilestmt_
      : *reinterpret_cast< ::Pasc::WhileStatement*>(&::Pasc::_WhileStatement_default_instance_);
}
inline ::Pasc::WhileStatement* Statement::mutable_whilestmt() {
  if (!has_whilestmt()) {
    clear_stmt();
    set_has_whilestmt();
    stmt_.whilestmt_ = CreateMaybeMessage< ::Pasc::WhileStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.whileStmt)
  return stmt_.whilestmt_;
}

// .Pasc.CompoundStatement cmpdStmt = 7;
inline bool Statement::has_cmpdstmt() const {
  return stmt_case() == kCmpdStmt;
}
inline void Statement::set_has_cmpdstmt() {
  _oneof_case_[0] = kCmpdStmt;
}
inline void Statement::clear_cmpdstmt() {
  if (has_cmpdstmt()) {
    delete stmt_.cmpdstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::CompoundStatement& Statement::_internal_cmpdstmt() const {
  return *stmt_.cmpdstmt_;
}
inline ::Pasc::CompoundStatement* Statement::release_cmpdstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.cmpdStmt)
  if (has_cmpdstmt()) {
    clear_has_stmt();
      ::Pasc::CompoundStatement* temp = stmt_.cmpdstmt_;
    stmt_.cmpdstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::CompoundStatement& Statement::cmpdstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.cmpdStmt)
  return has_cmpdstmt()
      ? *stmt_.cmpdstmt_
      : *reinterpret_cast< ::Pasc::CompoundStatement*>(&::Pasc::_CompoundStatement_default_instance_);
}
inline ::Pasc::CompoundStatement* Statement::mutable_cmpdstmt() {
  if (!has_cmpdstmt()) {
    clear_stmt();
    set_has_cmpdstmt();
    stmt_.cmpdstmt_ = CreateMaybeMessage< ::Pasc::CompoundStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.cmpdStmt)
  return stmt_.cmpdstmt_;
}

// .Pasc.RepeatStatement rptStmt = 8;
inline bool Statement::has_rptstmt() const {
  return stmt_case() == kRptStmt;
}
inline void Statement::set_has_rptstmt() {
  _oneof_case_[0] = kRptStmt;
}
inline void Statement::clear_rptstmt() {
  if (has_rptstmt()) {
    delete stmt_.rptstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::RepeatStatement& Statement::_internal_rptstmt() const {
  return *stmt_.rptstmt_;
}
inline ::Pasc::RepeatStatement* Statement::release_rptstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.rptStmt)
  if (has_rptstmt()) {
    clear_has_stmt();
      ::Pasc::RepeatStatement* temp = stmt_.rptstmt_;
    stmt_.rptstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::RepeatStatement& Statement::rptstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.rptStmt)
  return has_rptstmt()
      ? *stmt_.rptstmt_
      : *reinterpret_cast< ::Pasc::RepeatStatement*>(&::Pasc::_RepeatStatement_default_instance_);
}
inline ::Pasc::RepeatStatement* Statement::mutable_rptstmt() {
  if (!has_rptstmt()) {
    clear_stmt();
    set_has_rptstmt();
    stmt_.rptstmt_ = CreateMaybeMessage< ::Pasc::RepeatStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.rptStmt)
  return stmt_.rptstmt_;
}

// .Pasc.ForStatement forStmt = 9;
inline bool Statement::has_forstmt() const {
  return stmt_case() == kForStmt;
}
inline void Statement::set_has_forstmt() {
  _oneof_case_[0] = kForStmt;
}
inline void Statement::clear_forstmt() {
  if (has_forstmt()) {
    delete stmt_.forstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ForStatement& Statement::_internal_forstmt() const {
  return *stmt_.forstmt_;
}
inline ::Pasc::ForStatement* Statement::release_forstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.forStmt)
  if (has_forstmt()) {
    clear_has_stmt();
      ::Pasc::ForStatement* temp = stmt_.forstmt_;
    stmt_.forstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ForStatement& Statement::forstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.forStmt)
  return has_forstmt()
      ? *stmt_.forstmt_
      : *reinterpret_cast< ::Pasc::ForStatement*>(&::Pasc::_ForStatement_default_instance_);
}
inline ::Pasc::ForStatement* Statement::mutable_forstmt() {
  if (!has_forstmt()) {
    clear_stmt();
    set_has_forstmt();
    stmt_.forstmt_ = CreateMaybeMessage< ::Pasc::ForStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.forStmt)
  return stmt_.forstmt_;
}

// .Pasc.CaseStatement caseStmt = 10;
inline bool Statement::has_casestmt() const {
  return stmt_case() == kCaseStmt;
}
inline void Statement::set_has_casestmt() {
  _oneof_case_[0] = kCaseStmt;
}
inline void Statement::clear_casestmt() {
  if (has_casestmt()) {
    delete stmt_.casestmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::CaseStatement& Statement::_internal_casestmt() const {
  return *stmt_.casestmt_;
}
inline ::Pasc::CaseStatement* Statement::release_casestmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.caseStmt)
  if (has_casestmt()) {
    clear_has_stmt();
      ::Pasc::CaseStatement* temp = stmt_.casestmt_;
    stmt_.casestmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::CaseStatement& Statement::casestmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.caseStmt)
  return has_casestmt()
      ? *stmt_.casestmt_
      : *reinterpret_cast< ::Pasc::CaseStatement*>(&::Pasc::_CaseStatement_default_instance_);
}
inline ::Pasc::CaseStatement* Statement::mutable_casestmt() {
  if (!has_casestmt()) {
    clear_stmt();
    set_has_casestmt();
    stmt_.casestmt_ = CreateMaybeMessage< ::Pasc::CaseStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.caseStmt)
  return stmt_.casestmt_;
}

// .Pasc.GoToStatement gotoStmt = 11;
inline bool Statement::has_gotostmt() const {
  return stmt_case() == kGotoStmt;
}
inline void Statement::set_has_gotostmt() {
  _oneof_case_[0] = kGotoStmt;
}
inline void Statement::clear_gotostmt() {
  if (has_gotostmt()) {
    delete stmt_.gotostmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::GoToStatement& Statement::_internal_gotostmt() const {
  return *stmt_.gotostmt_;
}
inline ::Pasc::GoToStatement* Statement::release_gotostmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.gotoStmt)
  if (has_gotostmt()) {
    clear_has_stmt();
      ::Pasc::GoToStatement* temp = stmt_.gotostmt_;
    stmt_.gotostmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::GoToStatement& Statement::gotostmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.gotoStmt)
  return has_gotostmt()
      ? *stmt_.gotostmt_
      : *reinterpret_cast< ::Pasc::GoToStatement*>(&::Pasc::_GoToStatement_default_instance_);
}
inline ::Pasc::GoToStatement* Statement::mutable_gotostmt() {
  if (!has_gotostmt()) {
    clear_stmt();
    set_has_gotostmt();
    stmt_.gotostmt_ = CreateMaybeMessage< ::Pasc::GoToStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.gotoStmt)
  return stmt_.gotostmt_;
}

inline bool Statement::has_stmt() const {
  return stmt_case() != STMT_NOT_SET;
}
inline void Statement::clear_has_stmt() {
  _oneof_case_[0] = STMT_NOT_SET;
}
inline Statement::StmtCase Statement::stmt_case() const {
  return Statement::StmtCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pasc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pasc::ProcedureStatement_PSKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::ProcedureStatement_PSKind>() {
  return ::Pasc::ProcedureStatement_PSKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Statement_StmtKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Statement_StmtKind>() {
  return ::Pasc::Statement_StmtKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_proto_2fstatement_2eproto
