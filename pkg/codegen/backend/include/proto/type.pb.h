// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/type.proto

#ifndef PROTOBUF_INCLUDED_proto_2ftype_2eproto
#define PROTOBUF_INCLUDED_proto_2ftype_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_proto_2ftype_2eproto 

namespace protobuf_proto_2ftype_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_proto_2ftype_2eproto
namespace Pasc {
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Type_Boolean;
class Type_BooleanDefaultTypeInternal;
extern Type_BooleanDefaultTypeInternal _Type_Boolean_default_instance_;
class Type_Char;
class Type_CharDefaultTypeInternal;
extern Type_CharDefaultTypeInternal _Type_Char_default_instance_;
class Type_Integer;
class Type_IntegerDefaultTypeInternal;
extern Type_IntegerDefaultTypeInternal _Type_Integer_default_instance_;
class Type_Real;
class Type_RealDefaultTypeInternal;
extern Type_RealDefaultTypeInternal _Type_Real_default_instance_;
class Type_String;
class Type_StringDefaultTypeInternal;
extern Type_StringDefaultTypeInternal _Type_String_default_instance_;
class Type_Void;
class Type_VoidDefaultTypeInternal;
extern Type_VoidDefaultTypeInternal _Type_Void_default_instance_;
}  // namespace Pasc
namespace google {
namespace protobuf {
template<> ::Pasc::Type* Arena::CreateMaybeMessage<::Pasc::Type>(Arena*);
template<> ::Pasc::Type_Boolean* Arena::CreateMaybeMessage<::Pasc::Type_Boolean>(Arena*);
template<> ::Pasc::Type_Char* Arena::CreateMaybeMessage<::Pasc::Type_Char>(Arena*);
template<> ::Pasc::Type_Integer* Arena::CreateMaybeMessage<::Pasc::Type_Integer>(Arena*);
template<> ::Pasc::Type_Real* Arena::CreateMaybeMessage<::Pasc::Type_Real>(Arena*);
template<> ::Pasc::Type_String* Arena::CreateMaybeMessage<::Pasc::Type_String>(Arena*);
template<> ::Pasc::Type_Void* Arena::CreateMaybeMessage<::Pasc::Type_Void>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Pasc {

enum Type_TypeKind {
  Type_TypeKind_INTEGER = 0,
  Type_TypeKind_REAL = 1,
  Type_TypeKind_BOOLEAN = 2,
  Type_TypeKind_CHAR = 3,
  Type_TypeKind_VOID = 4,
  Type_TypeKind_STR = 5,
  Type_TypeKind_Type_TypeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Type_TypeKind_Type_TypeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Type_TypeKind_IsValid(int value);
const Type_TypeKind Type_TypeKind_TypeKind_MIN = Type_TypeKind_INTEGER;
const Type_TypeKind Type_TypeKind_TypeKind_MAX = Type_TypeKind_STR;
const int Type_TypeKind_TypeKind_ARRAYSIZE = Type_TypeKind_TypeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_TypeKind_descriptor();
inline const ::std::string& Type_TypeKind_Name(Type_TypeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_TypeKind_descriptor(), value);
}
inline bool Type_TypeKind_Parse(
    const ::std::string& name, Type_TypeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type_TypeKind>(
    Type_TypeKind_descriptor(), name, value);
}
// ===================================================================

class Type_Integer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Integer) */ {
 public:
  Type_Integer();
  virtual ~Type_Integer();

  Type_Integer(const Type_Integer& from);

  inline Type_Integer& operator=(const Type_Integer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Integer(Type_Integer&& from) noexcept
    : Type_Integer() {
    *this = ::std::move(from);
  }

  inline Type_Integer& operator=(Type_Integer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Integer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Integer* internal_default_instance() {
    return reinterpret_cast<const Type_Integer*>(
               &_Type_Integer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Type_Integer* other);
  friend void swap(Type_Integer& a, Type_Integer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Integer* New() const final {
    return CreateMaybeMessage<Type_Integer>(NULL);
  }

  Type_Integer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Integer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Integer& from);
  void MergeFrom(const Type_Integer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Integer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Integer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Boolean : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Boolean) */ {
 public:
  Type_Boolean();
  virtual ~Type_Boolean();

  Type_Boolean(const Type_Boolean& from);

  inline Type_Boolean& operator=(const Type_Boolean& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Boolean(Type_Boolean&& from) noexcept
    : Type_Boolean() {
    *this = ::std::move(from);
  }

  inline Type_Boolean& operator=(Type_Boolean&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Boolean& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Boolean* internal_default_instance() {
    return reinterpret_cast<const Type_Boolean*>(
               &_Type_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Type_Boolean* other);
  friend void swap(Type_Boolean& a, Type_Boolean& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Boolean* New() const final {
    return CreateMaybeMessage<Type_Boolean>(NULL);
  }

  Type_Boolean* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Boolean>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Boolean& from);
  void MergeFrom(const Type_Boolean& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Boolean* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Boolean)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Real : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Real) */ {
 public:
  Type_Real();
  virtual ~Type_Real();

  Type_Real(const Type_Real& from);

  inline Type_Real& operator=(const Type_Real& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Real(Type_Real&& from) noexcept
    : Type_Real() {
    *this = ::std::move(from);
  }

  inline Type_Real& operator=(Type_Real&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Real& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Real* internal_default_instance() {
    return reinterpret_cast<const Type_Real*>(
               &_Type_Real_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Type_Real* other);
  friend void swap(Type_Real& a, Type_Real& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Real* New() const final {
    return CreateMaybeMessage<Type_Real>(NULL);
  }

  Type_Real* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Real>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Real& from);
  void MergeFrom(const Type_Real& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Real* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Real)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Char : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Char) */ {
 public:
  Type_Char();
  virtual ~Type_Char();

  Type_Char(const Type_Char& from);

  inline Type_Char& operator=(const Type_Char& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Char(Type_Char&& from) noexcept
    : Type_Char() {
    *this = ::std::move(from);
  }

  inline Type_Char& operator=(Type_Char&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Char& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Char* internal_default_instance() {
    return reinterpret_cast<const Type_Char*>(
               &_Type_Char_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Type_Char* other);
  friend void swap(Type_Char& a, Type_Char& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Char* New() const final {
    return CreateMaybeMessage<Type_Char>(NULL);
  }

  Type_Char* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Char>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Char& from);
  void MergeFrom(const Type_Char& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Char* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Char)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Void : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Void) */ {
 public:
  Type_Void();
  virtual ~Type_Void();

  Type_Void(const Type_Void& from);

  inline Type_Void& operator=(const Type_Void& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Void(Type_Void&& from) noexcept
    : Type_Void() {
    *this = ::std::move(from);
  }

  inline Type_Void& operator=(Type_Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Void* internal_default_instance() {
    return reinterpret_cast<const Type_Void*>(
               &_Type_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Type_Void* other);
  friend void swap(Type_Void& a, Type_Void& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Void* New() const final {
    return CreateMaybeMessage<Type_Void>(NULL);
  }

  Type_Void* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Void>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Void& from);
  void MergeFrom(const Type_Void& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Void* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Void)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_String : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.String) */ {
 public:
  Type_String();
  virtual ~Type_String();

  Type_String(const Type_String& from);

  inline Type_String& operator=(const Type_String& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_String(Type_String&& from) noexcept
    : Type_String() {
    *this = ::std::move(from);
  }

  inline Type_String& operator=(Type_String&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_String& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_String* internal_default_instance() {
    return reinterpret_cast<const Type_String*>(
               &_Type_String_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Type_String* other);
  friend void swap(Type_String& a, Type_String& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_String* New() const final {
    return CreateMaybeMessage<Type_String>(NULL);
  }

  Type_String* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_String>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_String& from);
  void MergeFrom(const Type_String& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_String* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.String)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_proto_2ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type) */ {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(Type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();

  enum TypeCase {
    kInt = 2,
    kReal = 3,
    kBool = 4,
    kChar = 5,
    kVoid = 6,
    kStr = 7,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Type* other);
  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(NULL);
  }

  Type* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_Integer Integer;
  typedef Type_Boolean Boolean;
  typedef Type_Real Real;
  typedef Type_Char Char;
  typedef Type_Void Void;
  typedef Type_String String;

  typedef Type_TypeKind TypeKind;
  static const TypeKind INTEGER =
    Type_TypeKind_INTEGER;
  static const TypeKind REAL =
    Type_TypeKind_REAL;
  static const TypeKind BOOLEAN =
    Type_TypeKind_BOOLEAN;
  static const TypeKind CHAR =
    Type_TypeKind_CHAR;
  static const TypeKind VOID =
    Type_TypeKind_VOID;
  static const TypeKind STR =
    Type_TypeKind_STR;
  static inline bool TypeKind_IsValid(int value) {
    return Type_TypeKind_IsValid(value);
  }
  static const TypeKind TypeKind_MIN =
    Type_TypeKind_TypeKind_MIN;
  static const TypeKind TypeKind_MAX =
    Type_TypeKind_TypeKind_MAX;
  static const int TypeKind_ARRAYSIZE =
    Type_TypeKind_TypeKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TypeKind_descriptor() {
    return Type_TypeKind_descriptor();
  }
  static inline const ::std::string& TypeKind_Name(TypeKind value) {
    return Type_TypeKind_Name(value);
  }
  static inline bool TypeKind_Parse(const ::std::string& name,
      TypeKind* value) {
    return Type_TypeKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Type.TypeKind tk = 1;
  void clear_tk();
  static const int kTkFieldNumber = 1;
  ::Pasc::Type_TypeKind tk() const;
  void set_tk(::Pasc::Type_TypeKind value);

  // .Pasc.Type.Integer int = 2;
  bool has_int_() const;
  void clear_int_();
  static const int kIntFieldNumber = 2;
  private:
  const ::Pasc::Type_Integer& _internal_int_() const;
  public:
  const ::Pasc::Type_Integer& int_() const;
  ::Pasc::Type_Integer* release_int_();
  ::Pasc::Type_Integer* mutable_int_();
  void set_allocated_int_(::Pasc::Type_Integer* int_);

  // .Pasc.Type.Real real = 3;
  bool has_real() const;
  void clear_real();
  static const int kRealFieldNumber = 3;
  private:
  const ::Pasc::Type_Real& _internal_real() const;
  public:
  const ::Pasc::Type_Real& real() const;
  ::Pasc::Type_Real* release_real();
  ::Pasc::Type_Real* mutable_real();
  void set_allocated_real(::Pasc::Type_Real* real);

  // .Pasc.Type.Boolean bool = 4;
  bool has_bool_() const;
  void clear_bool_();
  static const int kBoolFieldNumber = 4;
  private:
  const ::Pasc::Type_Boolean& _internal_bool_() const;
  public:
  const ::Pasc::Type_Boolean& bool_() const;
  ::Pasc::Type_Boolean* release_bool_();
  ::Pasc::Type_Boolean* mutable_bool_();
  void set_allocated_bool_(::Pasc::Type_Boolean* bool_);

  // .Pasc.Type.Char char = 5;
  bool has_char_() const;
  void clear_char_();
  static const int kCharFieldNumber = 5;
  private:
  const ::Pasc::Type_Char& _internal_char_() const;
  public:
  const ::Pasc::Type_Char& char_() const;
  ::Pasc::Type_Char* release_char_();
  ::Pasc::Type_Char* mutable_char_();
  void set_allocated_char_(::Pasc::Type_Char* char_);

  // .Pasc.Type.Void void = 6;
  bool has_void_() const;
  void clear_void_();
  static const int kVoidFieldNumber = 6;
  private:
  const ::Pasc::Type_Void& _internal_void_() const;
  public:
  const ::Pasc::Type_Void& void_() const;
  ::Pasc::Type_Void* release_void_();
  ::Pasc::Type_Void* mutable_void_();
  void set_allocated_void_(::Pasc::Type_Void* void_);

  // .Pasc.Type.String str = 7;
  bool has_str() const;
  void clear_str();
  static const int kStrFieldNumber = 7;
  private:
  const ::Pasc::Type_String& _internal_str() const;
  public:
  const ::Pasc::Type_String& str() const;
  ::Pasc::Type_String* release_str();
  ::Pasc::Type_String* mutable_str();
  void set_allocated_str(::Pasc::Type_String* str);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Type)
 private:
  void set_has_int_();
  void set_has_real();
  void set_has_bool_();
  void set_has_char_();
  void set_has_void_();
  void set_has_str();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int tk_;
  union TypeUnion {
    TypeUnion() {}
    ::Pasc::Type_Integer* int__;
    ::Pasc::Type_Real* real_;
    ::Pasc::Type_Boolean* bool__;
    ::Pasc::Type_Char* char__;
    ::Pasc::Type_Void* void__;
    ::Pasc::Type_String* str_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_proto_2ftype_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Type_Integer

// string name = 1;
inline void Type_Integer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Integer::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Integer.name)
  return name_.GetNoArena();
}
inline void Type_Integer::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Integer.name)
}
#if LANG_CXX11
inline void Type_Integer::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Integer.name)
}
#endif
inline void Type_Integer::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Integer.name)
}
inline void Type_Integer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Integer.name)
}
inline ::std::string* Type_Integer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Integer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Integer::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Integer.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Integer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Integer.name)
}

// -------------------------------------------------------------------

// Type_Boolean

// string name = 1;
inline void Type_Boolean::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Boolean::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Boolean.name)
  return name_.GetNoArena();
}
inline void Type_Boolean::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Boolean.name)
}
#if LANG_CXX11
inline void Type_Boolean::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Boolean.name)
}
#endif
inline void Type_Boolean::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Boolean.name)
}
inline void Type_Boolean::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Boolean.name)
}
inline ::std::string* Type_Boolean::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Boolean.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Boolean::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Boolean.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Boolean::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Boolean.name)
}

// -------------------------------------------------------------------

// Type_Real

// string name = 1;
inline void Type_Real::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Real::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Real.name)
  return name_.GetNoArena();
}
inline void Type_Real::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Real.name)
}
#if LANG_CXX11
inline void Type_Real::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Real.name)
}
#endif
inline void Type_Real::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Real.name)
}
inline void Type_Real::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Real.name)
}
inline ::std::string* Type_Real::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Real.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Real::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Real.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Real::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Real.name)
}

// -------------------------------------------------------------------

// Type_Char

// string name = 1;
inline void Type_Char::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Char::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Char.name)
  return name_.GetNoArena();
}
inline void Type_Char::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Char.name)
}
#if LANG_CXX11
inline void Type_Char::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Char.name)
}
#endif
inline void Type_Char::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Char.name)
}
inline void Type_Char::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Char.name)
}
inline ::std::string* Type_Char::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Char.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Char::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Char.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Char::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Char.name)
}

// -------------------------------------------------------------------

// Type_Void

// string name = 1;
inline void Type_Void::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Void::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Void.name)
  return name_.GetNoArena();
}
inline void Type_Void::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Void.name)
}
#if LANG_CXX11
inline void Type_Void::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Void.name)
}
#endif
inline void Type_Void::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Void.name)
}
inline void Type_Void::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Void.name)
}
inline ::std::string* Type_Void::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Void.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Void::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Void.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Void::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Void.name)
}

// -------------------------------------------------------------------

// Type_String

// string name = 1;
inline void Type_String::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_String::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.String.name)
  return name_.GetNoArena();
}
inline void Type_String::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.String.name)
}
#if LANG_CXX11
inline void Type_String::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.String.name)
}
#endif
inline void Type_String::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.String.name)
}
inline void Type_String::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.String.name)
}
inline ::std::string* Type_String::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.String.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_String::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.String.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_String::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.String.name)
}

// -------------------------------------------------------------------

// Type

// .Pasc.Type.TypeKind tk = 1;
inline void Type::clear_tk() {
  tk_ = 0;
}
inline ::Pasc::Type_TypeKind Type::tk() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.tk)
  return static_cast< ::Pasc::Type_TypeKind >(tk_);
}
inline void Type::set_tk(::Pasc::Type_TypeKind value) {
  
  tk_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Type.tk)
}

// .Pasc.Type.Integer int = 2;
inline bool Type::has_int_() const {
  return type_case() == kInt;
}
inline void Type::set_has_int_() {
  _oneof_case_[0] = kInt;
}
inline void Type::clear_int_() {
  if (has_int_()) {
    delete type_.int__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Integer& Type::_internal_int_() const {
  return *type_.int__;
}
inline ::Pasc::Type_Integer* Type::release_int_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.int)
  if (has_int_()) {
    clear_has_type();
      ::Pasc::Type_Integer* temp = type_.int__;
    type_.int__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Integer& Type::int_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.int)
  return has_int_()
      ? *type_.int__
      : *reinterpret_cast< ::Pasc::Type_Integer*>(&::Pasc::_Type_Integer_default_instance_);
}
inline ::Pasc::Type_Integer* Type::mutable_int_() {
  if (!has_int_()) {
    clear_type();
    set_has_int_();
    type_.int__ = CreateMaybeMessage< ::Pasc::Type_Integer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.int)
  return type_.int__;
}

// .Pasc.Type.Real real = 3;
inline bool Type::has_real() const {
  return type_case() == kReal;
}
inline void Type::set_has_real() {
  _oneof_case_[0] = kReal;
}
inline void Type::clear_real() {
  if (has_real()) {
    delete type_.real_;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Real& Type::_internal_real() const {
  return *type_.real_;
}
inline ::Pasc::Type_Real* Type::release_real() {
  // @@protoc_insertion_point(field_release:Pasc.Type.real)
  if (has_real()) {
    clear_has_type();
      ::Pasc::Type_Real* temp = type_.real_;
    type_.real_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Real& Type::real() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.real)
  return has_real()
      ? *type_.real_
      : *reinterpret_cast< ::Pasc::Type_Real*>(&::Pasc::_Type_Real_default_instance_);
}
inline ::Pasc::Type_Real* Type::mutable_real() {
  if (!has_real()) {
    clear_type();
    set_has_real();
    type_.real_ = CreateMaybeMessage< ::Pasc::Type_Real >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.real)
  return type_.real_;
}

// .Pasc.Type.Boolean bool = 4;
inline bool Type::has_bool_() const {
  return type_case() == kBool;
}
inline void Type::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void Type::clear_bool_() {
  if (has_bool_()) {
    delete type_.bool__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Boolean& Type::_internal_bool_() const {
  return *type_.bool__;
}
inline ::Pasc::Type_Boolean* Type::release_bool_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.bool)
  if (has_bool_()) {
    clear_has_type();
      ::Pasc::Type_Boolean* temp = type_.bool__;
    type_.bool__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Boolean& Type::bool_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.bool)
  return has_bool_()
      ? *type_.bool__
      : *reinterpret_cast< ::Pasc::Type_Boolean*>(&::Pasc::_Type_Boolean_default_instance_);
}
inline ::Pasc::Type_Boolean* Type::mutable_bool_() {
  if (!has_bool_()) {
    clear_type();
    set_has_bool_();
    type_.bool__ = CreateMaybeMessage< ::Pasc::Type_Boolean >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.bool)
  return type_.bool__;
}

// .Pasc.Type.Char char = 5;
inline bool Type::has_char_() const {
  return type_case() == kChar;
}
inline void Type::set_has_char_() {
  _oneof_case_[0] = kChar;
}
inline void Type::clear_char_() {
  if (has_char_()) {
    delete type_.char__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Char& Type::_internal_char_() const {
  return *type_.char__;
}
inline ::Pasc::Type_Char* Type::release_char_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.char)
  if (has_char_()) {
    clear_has_type();
      ::Pasc::Type_Char* temp = type_.char__;
    type_.char__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Char& Type::char_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.char)
  return has_char_()
      ? *type_.char__
      : *reinterpret_cast< ::Pasc::Type_Char*>(&::Pasc::_Type_Char_default_instance_);
}
inline ::Pasc::Type_Char* Type::mutable_char_() {
  if (!has_char_()) {
    clear_type();
    set_has_char_();
    type_.char__ = CreateMaybeMessage< ::Pasc::Type_Char >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.char)
  return type_.char__;
}

// .Pasc.Type.Void void = 6;
inline bool Type::has_void_() const {
  return type_case() == kVoid;
}
inline void Type::set_has_void_() {
  _oneof_case_[0] = kVoid;
}
inline void Type::clear_void_() {
  if (has_void_()) {
    delete type_.void__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Void& Type::_internal_void_() const {
  return *type_.void__;
}
inline ::Pasc::Type_Void* Type::release_void_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.void)
  if (has_void_()) {
    clear_has_type();
      ::Pasc::Type_Void* temp = type_.void__;
    type_.void__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Void& Type::void_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.void)
  return has_void_()
      ? *type_.void__
      : *reinterpret_cast< ::Pasc::Type_Void*>(&::Pasc::_Type_Void_default_instance_);
}
inline ::Pasc::Type_Void* Type::mutable_void_() {
  if (!has_void_()) {
    clear_type();
    set_has_void_();
    type_.void__ = CreateMaybeMessage< ::Pasc::Type_Void >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.void)
  return type_.void__;
}

// .Pasc.Type.String str = 7;
inline bool Type::has_str() const {
  return type_case() == kStr;
}
inline void Type::set_has_str() {
  _oneof_case_[0] = kStr;
}
inline void Type::clear_str() {
  if (has_str()) {
    delete type_.str_;
    clear_has_type();
  }
}
inline const ::Pasc::Type_String& Type::_internal_str() const {
  return *type_.str_;
}
inline ::Pasc::Type_String* Type::release_str() {
  // @@protoc_insertion_point(field_release:Pasc.Type.str)
  if (has_str()) {
    clear_has_type();
      ::Pasc::Type_String* temp = type_.str_;
    type_.str_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_String& Type::str() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.str)
  return has_str()
      ? *type_.str_
      : *reinterpret_cast< ::Pasc::Type_String*>(&::Pasc::_Type_String_default_instance_);
}
inline ::Pasc::Type_String* Type::mutable_str() {
  if (!has_str()) {
    clear_type();
    set_has_str();
    type_.str_ = CreateMaybeMessage< ::Pasc::Type_String >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.str)
  return type_.str_;
}

inline bool Type::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Type::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Type::TypeCase Type::type_case() const {
  return Type::TypeCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pasc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pasc::Type_TypeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Type_TypeKind>() {
  return ::Pasc::Type_TypeKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_proto_2ftype_2eproto
