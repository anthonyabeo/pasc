// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: program.proto

#ifndef PROTOBUF_INCLUDED_program_2eproto
#define PROTOBUF_INCLUDED_program_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_program_2eproto 

namespace protobuf_program_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_program_2eproto
namespace Pasc {
class AssignStmt;
class AssignStmtDefaultTypeInternal;
extern AssignStmtDefaultTypeInternal _AssignStmt_default_instance_;
class BinaryExpr;
class BinaryExprDefaultTypeInternal;
extern BinaryExprDefaultTypeInternal _BinaryExpr_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Boolean;
class BooleanDefaultTypeInternal;
extern BooleanDefaultTypeInternal _Boolean_default_instance_;
class Char;
class CharDefaultTypeInternal;
extern CharDefaultTypeInternal _Char_default_instance_;
class Expression;
class ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Identifier_FieldDesignator;
class Identifier_FieldDesignatorDefaultTypeInternal;
extern Identifier_FieldDesignatorDefaultTypeInternal _Identifier_FieldDesignator_default_instance_;
class Identifier_IndexedVariable;
class Identifier_IndexedVariableDefaultTypeInternal;
extern Identifier_IndexedVariableDefaultTypeInternal _Identifier_IndexedVariable_default_instance_;
class Identifier_Variable;
class Identifier_VariableDefaultTypeInternal;
extern Identifier_VariableDefaultTypeInternal _Identifier_Variable_default_instance_;
class IfStmt;
class IfStmtDefaultTypeInternal;
extern IfStmtDefaultTypeInternal _IfStmt_default_instance_;
class Integer;
class IntegerDefaultTypeInternal;
extern IntegerDefaultTypeInternal _Integer_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
class ProcedureStmt;
class ProcedureStmtDefaultTypeInternal;
extern ProcedureStmtDefaultTypeInternal _ProcedureStmt_default_instance_;
class Program;
class ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class Real;
class RealDefaultTypeInternal;
extern RealDefaultTypeInternal _Real_default_instance_;
class Statement;
class StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class UIntLiteral;
class UIntLiteralDefaultTypeInternal;
extern UIntLiteralDefaultTypeInternal _UIntLiteral_default_instance_;
class VarDeclaration;
class VarDeclarationDefaultTypeInternal;
extern VarDeclarationDefaultTypeInternal _VarDeclaration_default_instance_;
}  // namespace Pasc
namespace google {
namespace protobuf {
template<> ::Pasc::AssignStmt* Arena::CreateMaybeMessage<::Pasc::AssignStmt>(Arena*);
template<> ::Pasc::BinaryExpr* Arena::CreateMaybeMessage<::Pasc::BinaryExpr>(Arena*);
template<> ::Pasc::Block* Arena::CreateMaybeMessage<::Pasc::Block>(Arena*);
template<> ::Pasc::Boolean* Arena::CreateMaybeMessage<::Pasc::Boolean>(Arena*);
template<> ::Pasc::Char* Arena::CreateMaybeMessage<::Pasc::Char>(Arena*);
template<> ::Pasc::Expression* Arena::CreateMaybeMessage<::Pasc::Expression>(Arena*);
template<> ::Pasc::Identifier* Arena::CreateMaybeMessage<::Pasc::Identifier>(Arena*);
template<> ::Pasc::Identifier_FieldDesignator* Arena::CreateMaybeMessage<::Pasc::Identifier_FieldDesignator>(Arena*);
template<> ::Pasc::Identifier_IndexedVariable* Arena::CreateMaybeMessage<::Pasc::Identifier_IndexedVariable>(Arena*);
template<> ::Pasc::Identifier_Variable* Arena::CreateMaybeMessage<::Pasc::Identifier_Variable>(Arena*);
template<> ::Pasc::IfStmt* Arena::CreateMaybeMessage<::Pasc::IfStmt>(Arena*);
template<> ::Pasc::Integer* Arena::CreateMaybeMessage<::Pasc::Integer>(Arena*);
template<> ::Pasc::Operator* Arena::CreateMaybeMessage<::Pasc::Operator>(Arena*);
template<> ::Pasc::ProcedureStmt* Arena::CreateMaybeMessage<::Pasc::ProcedureStmt>(Arena*);
template<> ::Pasc::Program* Arena::CreateMaybeMessage<::Pasc::Program>(Arena*);
template<> ::Pasc::Real* Arena::CreateMaybeMessage<::Pasc::Real>(Arena*);
template<> ::Pasc::Statement* Arena::CreateMaybeMessage<::Pasc::Statement>(Arena*);
template<> ::Pasc::Type* Arena::CreateMaybeMessage<::Pasc::Type>(Arena*);
template<> ::Pasc::UIntLiteral* Arena::CreateMaybeMessage<::Pasc::UIntLiteral>(Arena*);
template<> ::Pasc::VarDeclaration* Arena::CreateMaybeMessage<::Pasc::VarDeclaration>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Pasc {

enum Identifier_IDKind {
  Identifier_IDKind_EntireVar = 0,
  Identifier_IDKind_IdxVar = 1,
  Identifier_IDKind_Field = 2,
  Identifier_IDKind_Identifier_IDKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Identifier_IDKind_Identifier_IDKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Identifier_IDKind_IsValid(int value);
const Identifier_IDKind Identifier_IDKind_IDKind_MIN = Identifier_IDKind_EntireVar;
const Identifier_IDKind Identifier_IDKind_IDKind_MAX = Identifier_IDKind_Field;
const int Identifier_IDKind_IDKind_ARRAYSIZE = Identifier_IDKind_IDKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Identifier_IDKind_descriptor();
inline const ::std::string& Identifier_IDKind_Name(Identifier_IDKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Identifier_IDKind_descriptor(), value);
}
inline bool Identifier_IDKind_Parse(
    const ::std::string& name, Identifier_IDKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Identifier_IDKind>(
    Identifier_IDKind_descriptor(), name, value);
}
enum Expression_ExprKind {
  Expression_ExprKind_UInt = 0,
  Expression_ExprKind_Bool = 1,
  Expression_ExprKind_Ident = 2,
  Expression_ExprKind_BinExpr = 3,
  Expression_ExprKind_Expression_ExprKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Expression_ExprKind_Expression_ExprKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Expression_ExprKind_IsValid(int value);
const Expression_ExprKind Expression_ExprKind_ExprKind_MIN = Expression_ExprKind_UInt;
const Expression_ExprKind Expression_ExprKind_ExprKind_MAX = Expression_ExprKind_BinExpr;
const int Expression_ExprKind_ExprKind_ARRAYSIZE = Expression_ExprKind_ExprKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_ExprKind_descriptor();
inline const ::std::string& Expression_ExprKind_Name(Expression_ExprKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_ExprKind_descriptor(), value);
}
inline bool Expression_ExprKind_Parse(
    const ::std::string& name, Expression_ExprKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_ExprKind>(
    Expression_ExprKind_descriptor(), name, value);
}
enum Operator_OpKind {
  Operator_OpKind_Plus = 0,
  Operator_OpKind_Minus = 1,
  Operator_OpKind_Div = 2,
  Operator_OpKind_Sub = 3,
  Operator_OpKind_Mod = 4,
  Operator_OpKind_And = 5,
  Operator_OpKind_Or = 6,
  Operator_OpKind_In = 7,
  Operator_OpKind_Equal = 8,
  Operator_OpKind_Less = 9,
  Operator_OpKind_Great = 10,
  Operator_OpKind_Operator_OpKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Operator_OpKind_Operator_OpKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Operator_OpKind_IsValid(int value);
const Operator_OpKind Operator_OpKind_OpKind_MIN = Operator_OpKind_Plus;
const Operator_OpKind Operator_OpKind_OpKind_MAX = Operator_OpKind_Great;
const int Operator_OpKind_OpKind_ARRAYSIZE = Operator_OpKind_OpKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operator_OpKind_descriptor();
inline const ::std::string& Operator_OpKind_Name(Operator_OpKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operator_OpKind_descriptor(), value);
}
inline bool Operator_OpKind_Parse(
    const ::std::string& name, Operator_OpKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operator_OpKind>(
    Operator_OpKind_descriptor(), name, value);
}
enum TokenKind {
  PROGRAM = 0,
  ASSIGN = 1,
  IDENTIFIER = 2,
  UINTLIT = 3,
  PROCEDURE = 4,
  LESS = 5,
  GREAT = 6,
  IF = 7,
  TokenKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TokenKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TokenKind_IsValid(int value);
const TokenKind TokenKind_MIN = PROGRAM;
const TokenKind TokenKind_MAX = IF;
const int TokenKind_ARRAYSIZE = TokenKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TokenKind_descriptor();
inline const ::std::string& TokenKind_Name(TokenKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TokenKind_descriptor(), value);
}
inline bool TokenKind_Parse(
    const ::std::string& name, TokenKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TokenKind>(
    TokenKind_descriptor(), name, value);
}
enum TypeKind {
  INTEGER = 0,
  REAL = 1,
  BOOLEAN = 2,
  CHAR = 3,
  TypeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TypeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TypeKind_IsValid(int value);
const TypeKind TypeKind_MIN = INTEGER;
const TypeKind TypeKind_MAX = CHAR;
const int TypeKind_ARRAYSIZE = TypeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TypeKind_descriptor();
inline const ::std::string& TypeKind_Name(TypeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TypeKind_descriptor(), value);
}
inline bool TypeKind_Parse(
    const ::std::string& name, TypeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeKind>(
    TypeKind_descriptor(), name, value);
}
// ===================================================================

class Program : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Program) */ {
 public:
  Program();
  virtual ~Program();

  Program(const Program& from);

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Program(Program&& from) noexcept
    : Program() {
    *this = ::std::move(from);
  }

  inline Program& operator=(Program&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Program& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
               &_Program_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Program* other);
  friend void swap(Program& a, Program& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Program* New() const final {
    return CreateMaybeMessage<Program>(NULL);
  }

  Program* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Program>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Program* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string params = 3;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::std::string& params(int index) const;
  ::std::string* mutable_params(int index);
  void set_params(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_params(int index, ::std::string&& value);
  #endif
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, size_t size);
  ::std::string* add_params();
  void add_params(const ::std::string& value);
  #if LANG_CXX11
  void add_params(::std::string&& value);
  #endif
  void add_params(const char* value);
  void add_params(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Pasc.Block block = 4;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 4;
  private:
  const ::Pasc::Block& _internal_block() const;
  public:
  const ::Pasc::Block& block() const;
  ::Pasc::Block* release_block();
  ::Pasc::Block* mutable_block();
  void set_allocated_block(::Pasc::Block* block);

  // .Pasc.TokenKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::TokenKind kind() const;
  void set_kind(::Pasc::TokenKind value);

  // @@protoc_insertion_point(class_scope:Pasc.Program)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Pasc::Block* block_;
  int kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(NULL);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.VarDeclaration varDeclrs = 1;
  int vardeclrs_size() const;
  void clear_vardeclrs();
  static const int kVarDeclrsFieldNumber = 1;
  ::Pasc::VarDeclaration* mutable_vardeclrs(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >*
      mutable_vardeclrs();
  const ::Pasc::VarDeclaration& vardeclrs(int index) const;
  ::Pasc::VarDeclaration* add_vardeclrs();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >&
      vardeclrs() const;

  // repeated .Pasc.Statement stmts = 2;
  int stmts_size() const;
  void clear_stmts();
  static const int kStmtsFieldNumber = 2;
  ::Pasc::Statement* mutable_stmts(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
      mutable_stmts();
  const ::Pasc::Statement& stmts(int index) const;
  ::Pasc::Statement* add_stmts();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
      stmts() const;

  // @@protoc_insertion_point(class_scope:Pasc.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration > vardeclrs_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement > stmts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarDeclaration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.VarDeclaration) */ {
 public:
  VarDeclaration();
  virtual ~VarDeclaration();

  VarDeclaration(const VarDeclaration& from);

  inline VarDeclaration& operator=(const VarDeclaration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarDeclaration(VarDeclaration&& from) noexcept
    : VarDeclaration() {
    *this = ::std::move(from);
  }

  inline VarDeclaration& operator=(VarDeclaration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarDeclaration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarDeclaration* internal_default_instance() {
    return reinterpret_cast<const VarDeclaration*>(
               &_VarDeclaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(VarDeclaration* other);
  friend void swap(VarDeclaration& a, VarDeclaration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarDeclaration* New() const final {
    return CreateMaybeMessage<VarDeclaration>(NULL);
  }

  VarDeclaration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarDeclaration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarDeclaration& from);
  void MergeFrom(const VarDeclaration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarDeclaration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_name() const;
  public:
  const ::Pasc::Expression& name() const;
  ::Pasc::Expression* release_name();
  ::Pasc::Expression* mutable_name();
  void set_allocated_name(::Pasc::Expression* name);

  // .Pasc.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::Pasc::Type& _internal_type() const;
  public:
  const ::Pasc::Type& type() const;
  ::Pasc::Type* release_type();
  ::Pasc::Type* mutable_type();
  void set_allocated_type(::Pasc::Type* type);

  // @@protoc_insertion_point(class_scope:Pasc.VarDeclaration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* name_;
  ::Pasc::Type* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssignStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.AssignStmt) */ {
 public:
  AssignStmt();
  virtual ~AssignStmt();

  AssignStmt(const AssignStmt& from);

  inline AssignStmt& operator=(const AssignStmt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssignStmt(AssignStmt&& from) noexcept
    : AssignStmt() {
    *this = ::std::move(from);
  }

  inline AssignStmt& operator=(AssignStmt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignStmt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssignStmt* internal_default_instance() {
    return reinterpret_cast<const AssignStmt*>(
               &_AssignStmt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AssignStmt* other);
  friend void swap(AssignStmt& a, AssignStmt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssignStmt* New() const final {
    return CreateMaybeMessage<AssignStmt>(NULL);
  }

  AssignStmt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssignStmt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssignStmt& from);
  void MergeFrom(const AssignStmt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignStmt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression variable = 1;
  bool has_variable() const;
  void clear_variable();
  static const int kVariableFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_variable() const;
  public:
  const ::Pasc::Expression& variable() const;
  ::Pasc::Expression* release_variable();
  ::Pasc::Expression* mutable_variable();
  void set_allocated_variable(::Pasc::Expression* variable);

  // .Pasc.Expression value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_value() const;
  public:
  const ::Pasc::Expression& value() const;
  ::Pasc::Expression* release_value();
  ::Pasc::Expression* mutable_value();
  void set_allocated_value(::Pasc::Expression* value);

  // @@protoc_insertion_point(class_scope:Pasc.AssignStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* variable_;
  ::Pasc::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStmt) */ {
 public:
  ProcedureStmt();
  virtual ~ProcedureStmt();

  ProcedureStmt(const ProcedureStmt& from);

  inline ProcedureStmt& operator=(const ProcedureStmt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStmt(ProcedureStmt&& from) noexcept
    : ProcedureStmt() {
    *this = ::std::move(from);
  }

  inline ProcedureStmt& operator=(ProcedureStmt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStmt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStmt* internal_default_instance() {
    return reinterpret_cast<const ProcedureStmt*>(
               &_ProcedureStmt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProcedureStmt* other);
  friend void swap(ProcedureStmt& a, ProcedureStmt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStmt* New() const final {
    return CreateMaybeMessage<ProcedureStmt>(NULL);
  }

  ProcedureStmt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStmt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStmt& from);
  void MergeFrom(const ProcedureStmt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStmt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression args = 2;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 2;
  ::Pasc::Expression* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_args();
  const ::Pasc::Expression& args(int index) const;
  ::Pasc::Expression* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      args() const;

  // .Pasc.Expression name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_name() const;
  public:
  const ::Pasc::Expression& name() const;
  ::Pasc::Expression* release_name();
  ::Pasc::Expression* mutable_name();
  void set_allocated_name(::Pasc::Expression* name);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > args_;
  ::Pasc::Expression* name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IfStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.IfStmt) */ {
 public:
  IfStmt();
  virtual ~IfStmt();

  IfStmt(const IfStmt& from);

  inline IfStmt& operator=(const IfStmt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IfStmt(IfStmt&& from) noexcept
    : IfStmt() {
    *this = ::std::move(from);
  }

  inline IfStmt& operator=(IfStmt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IfStmt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfStmt* internal_default_instance() {
    return reinterpret_cast<const IfStmt*>(
               &_IfStmt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(IfStmt* other);
  friend void swap(IfStmt& a, IfStmt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IfStmt* New() const final {
    return CreateMaybeMessage<IfStmt>(NULL);
  }

  IfStmt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IfStmt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IfStmt& from);
  void MergeFrom(const IfStmt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfStmt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression cond = 1;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_cond() const;
  public:
  const ::Pasc::Expression& cond() const;
  ::Pasc::Expression* release_cond();
  ::Pasc::Expression* mutable_cond();
  void set_allocated_cond(::Pasc::Expression* cond);

  // .Pasc.Statement truePath = 2;
  bool has_truepath() const;
  void clear_truepath();
  static const int kTruePathFieldNumber = 2;
  private:
  const ::Pasc::Statement& _internal_truepath() const;
  public:
  const ::Pasc::Statement& truepath() const;
  ::Pasc::Statement* release_truepath();
  ::Pasc::Statement* mutable_truepath();
  void set_allocated_truepath(::Pasc::Statement* truepath);

  // .Pasc.Statement elsePath = 3;
  bool has_elsepath() const;
  void clear_elsepath();
  static const int kElsePathFieldNumber = 3;
  private:
  const ::Pasc::Statement& _internal_elsepath() const;
  public:
  const ::Pasc::Statement& elsepath() const;
  ::Pasc::Statement* release_elsepath();
  ::Pasc::Statement* mutable_elsepath();
  void set_allocated_elsepath(::Pasc::Statement* elsepath);

  // @@protoc_insertion_point(class_scope:Pasc.IfStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* cond_;
  ::Pasc::Statement* truepath_;
  ::Pasc::Statement* elsepath_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Statement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Statement) */ {
 public:
  Statement();
  virtual ~Statement();

  Statement(const Statement& from);

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(Statement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Statement& default_instance();

  enum StmtCase {
    kAssignStmt = 2,
    kProcStmt = 3,
    kIfStmt = 4,
    STMT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Statement* other);
  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Statement* New() const final {
    return CreateMaybeMessage<Statement>(NULL);
  }

  Statement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.TokenKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::TokenKind kind() const;
  void set_kind(::Pasc::TokenKind value);

  // .Pasc.AssignStmt assignStmt = 2;
  bool has_assignstmt() const;
  void clear_assignstmt();
  static const int kAssignStmtFieldNumber = 2;
  private:
  const ::Pasc::AssignStmt& _internal_assignstmt() const;
  public:
  const ::Pasc::AssignStmt& assignstmt() const;
  ::Pasc::AssignStmt* release_assignstmt();
  ::Pasc::AssignStmt* mutable_assignstmt();
  void set_allocated_assignstmt(::Pasc::AssignStmt* assignstmt);

  // .Pasc.ProcedureStmt procStmt = 3;
  bool has_procstmt() const;
  void clear_procstmt();
  static const int kProcStmtFieldNumber = 3;
  private:
  const ::Pasc::ProcedureStmt& _internal_procstmt() const;
  public:
  const ::Pasc::ProcedureStmt& procstmt() const;
  ::Pasc::ProcedureStmt* release_procstmt();
  ::Pasc::ProcedureStmt* mutable_procstmt();
  void set_allocated_procstmt(::Pasc::ProcedureStmt* procstmt);

  // .Pasc.IfStmt ifStmt = 4;
  bool has_ifstmt() const;
  void clear_ifstmt();
  static const int kIfStmtFieldNumber = 4;
  private:
  const ::Pasc::IfStmt& _internal_ifstmt() const;
  public:
  const ::Pasc::IfStmt& ifstmt() const;
  ::Pasc::IfStmt* release_ifstmt();
  ::Pasc::IfStmt* mutable_ifstmt();
  void set_allocated_ifstmt(::Pasc::IfStmt* ifstmt);

  void clear_stmt();
  StmtCase stmt_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Statement)
 private:
  void set_has_assignstmt();
  void set_has_procstmt();
  void set_has_ifstmt();

  inline bool has_stmt() const;
  inline void clear_has_stmt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union StmtUnion {
    StmtUnion() {}
    ::Pasc::AssignStmt* assignstmt_;
    ::Pasc::ProcedureStmt* procstmt_;
    ::Pasc::IfStmt* ifstmt_;
  } stmt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_Variable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.Variable) */ {
 public:
  Identifier_Variable();
  virtual ~Identifier_Variable();

  Identifier_Variable(const Identifier_Variable& from);

  inline Identifier_Variable& operator=(const Identifier_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_Variable(Identifier_Variable&& from) noexcept
    : Identifier_Variable() {
    *this = ::std::move(from);
  }

  inline Identifier_Variable& operator=(Identifier_Variable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_Variable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_Variable* internal_default_instance() {
    return reinterpret_cast<const Identifier_Variable*>(
               &_Identifier_Variable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Identifier_Variable* other);
  friend void swap(Identifier_Variable& a, Identifier_Variable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_Variable* New() const final {
    return CreateMaybeMessage<Identifier_Variable>(NULL);
  }

  Identifier_Variable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_Variable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_Variable& from);
  void MergeFrom(const Identifier_Variable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_Variable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.Variable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_IndexedVariable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.IndexedVariable) */ {
 public:
  Identifier_IndexedVariable();
  virtual ~Identifier_IndexedVariable();

  Identifier_IndexedVariable(const Identifier_IndexedVariable& from);

  inline Identifier_IndexedVariable& operator=(const Identifier_IndexedVariable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_IndexedVariable(Identifier_IndexedVariable&& from) noexcept
    : Identifier_IndexedVariable() {
    *this = ::std::move(from);
  }

  inline Identifier_IndexedVariable& operator=(Identifier_IndexedVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_IndexedVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_IndexedVariable* internal_default_instance() {
    return reinterpret_cast<const Identifier_IndexedVariable*>(
               &_Identifier_IndexedVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Identifier_IndexedVariable* other);
  friend void swap(Identifier_IndexedVariable& a, Identifier_IndexedVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_IndexedVariable* New() const final {
    return CreateMaybeMessage<Identifier_IndexedVariable>(NULL);
  }

  Identifier_IndexedVariable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_IndexedVariable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_IndexedVariable& from);
  void MergeFrom(const Identifier_IndexedVariable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_IndexedVariable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.IndexedVariable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_FieldDesignator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.FieldDesignator) */ {
 public:
  Identifier_FieldDesignator();
  virtual ~Identifier_FieldDesignator();

  Identifier_FieldDesignator(const Identifier_FieldDesignator& from);

  inline Identifier_FieldDesignator& operator=(const Identifier_FieldDesignator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_FieldDesignator(Identifier_FieldDesignator&& from) noexcept
    : Identifier_FieldDesignator() {
    *this = ::std::move(from);
  }

  inline Identifier_FieldDesignator& operator=(Identifier_FieldDesignator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_FieldDesignator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_FieldDesignator* internal_default_instance() {
    return reinterpret_cast<const Identifier_FieldDesignator*>(
               &_Identifier_FieldDesignator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Identifier_FieldDesignator* other);
  friend void swap(Identifier_FieldDesignator& a, Identifier_FieldDesignator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_FieldDesignator* New() const final {
    return CreateMaybeMessage<Identifier_FieldDesignator>(NULL);
  }

  Identifier_FieldDesignator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_FieldDesignator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_FieldDesignator& from);
  void MergeFrom(const Identifier_FieldDesignator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_FieldDesignator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.FieldDesignator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  enum ValueCase {
    kVar = 2,
    kIv = 3,
    kFld = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(NULL);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Identifier_Variable Variable;
  typedef Identifier_IndexedVariable IndexedVariable;
  typedef Identifier_FieldDesignator FieldDesignator;

  typedef Identifier_IDKind IDKind;
  static const IDKind EntireVar =
    Identifier_IDKind_EntireVar;
  static const IDKind IdxVar =
    Identifier_IDKind_IdxVar;
  static const IDKind Field =
    Identifier_IDKind_Field;
  static inline bool IDKind_IsValid(int value) {
    return Identifier_IDKind_IsValid(value);
  }
  static const IDKind IDKind_MIN =
    Identifier_IDKind_IDKind_MIN;
  static const IDKind IDKind_MAX =
    Identifier_IDKind_IDKind_MAX;
  static const int IDKind_ARRAYSIZE =
    Identifier_IDKind_IDKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IDKind_descriptor() {
    return Identifier_IDKind_descriptor();
  }
  static inline const ::std::string& IDKind_Name(IDKind value) {
    return Identifier_IDKind_Name(value);
  }
  static inline bool IDKind_Parse(const ::std::string& name,
      IDKind* value) {
    return Identifier_IDKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Identifier.IDKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Identifier_IDKind kind() const;
  void set_kind(::Pasc::Identifier_IDKind value);

  // .Pasc.Identifier.Variable var = 2;
  bool has_var() const;
  void clear_var();
  static const int kVarFieldNumber = 2;
  private:
  const ::Pasc::Identifier_Variable& _internal_var() const;
  public:
  const ::Pasc::Identifier_Variable& var() const;
  ::Pasc::Identifier_Variable* release_var();
  ::Pasc::Identifier_Variable* mutable_var();
  void set_allocated_var(::Pasc::Identifier_Variable* var);

  // .Pasc.Identifier.IndexedVariable iv = 3;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 3;
  private:
  const ::Pasc::Identifier_IndexedVariable& _internal_iv() const;
  public:
  const ::Pasc::Identifier_IndexedVariable& iv() const;
  ::Pasc::Identifier_IndexedVariable* release_iv();
  ::Pasc::Identifier_IndexedVariable* mutable_iv();
  void set_allocated_iv(::Pasc::Identifier_IndexedVariable* iv);

  // .Pasc.Identifier.FieldDesignator fld = 4;
  bool has_fld() const;
  void clear_fld();
  static const int kFldFieldNumber = 4;
  private:
  const ::Pasc::Identifier_FieldDesignator& _internal_fld() const;
  public:
  const ::Pasc::Identifier_FieldDesignator& fld() const;
  ::Pasc::Identifier_FieldDesignator* release_fld();
  ::Pasc::Identifier_FieldDesignator* mutable_fld();
  void set_allocated_fld(::Pasc::Identifier_FieldDesignator* fld);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Identifier)
 private:
  void set_has_var();
  void set_has_iv();
  void set_has_fld();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union ValueUnion {
    ValueUnion() {}
    ::Pasc::Identifier_Variable* var_;
    ::Pasc::Identifier_IndexedVariable* iv_;
    ::Pasc::Identifier_FieldDesignator* fld_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(Expression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  enum ExprCase {
    kId = 2,
    kUint = 3,
    kBe = 4,
    EXPR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Expression* other);
  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression* New() const final {
    return CreateMaybeMessage<Expression>(NULL);
  }

  Expression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_ExprKind ExprKind;
  static const ExprKind UInt =
    Expression_ExprKind_UInt;
  static const ExprKind Bool =
    Expression_ExprKind_Bool;
  static const ExprKind Ident =
    Expression_ExprKind_Ident;
  static const ExprKind BinExpr =
    Expression_ExprKind_BinExpr;
  static inline bool ExprKind_IsValid(int value) {
    return Expression_ExprKind_IsValid(value);
  }
  static const ExprKind ExprKind_MIN =
    Expression_ExprKind_ExprKind_MIN;
  static const ExprKind ExprKind_MAX =
    Expression_ExprKind_ExprKind_MAX;
  static const int ExprKind_ARRAYSIZE =
    Expression_ExprKind_ExprKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExprKind_descriptor() {
    return Expression_ExprKind_descriptor();
  }
  static inline const ::std::string& ExprKind_Name(ExprKind value) {
    return Expression_ExprKind_Name(value);
  }
  static inline bool ExprKind_Parse(const ::std::string& name,
      ExprKind* value) {
    return Expression_ExprKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Expression.ExprKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Expression_ExprKind kind() const;
  void set_kind(::Pasc::Expression_ExprKind value);

  // .Pasc.Identifier id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  private:
  const ::Pasc::Identifier& _internal_id() const;
  public:
  const ::Pasc::Identifier& id() const;
  ::Pasc::Identifier* release_id();
  ::Pasc::Identifier* mutable_id();
  void set_allocated_id(::Pasc::Identifier* id);

  // .Pasc.UIntLiteral uint = 3;
  bool has_uint() const;
  void clear_uint();
  static const int kUintFieldNumber = 3;
  private:
  const ::Pasc::UIntLiteral& _internal_uint() const;
  public:
  const ::Pasc::UIntLiteral& uint() const;
  ::Pasc::UIntLiteral* release_uint();
  ::Pasc::UIntLiteral* mutable_uint();
  void set_allocated_uint(::Pasc::UIntLiteral* uint);

  // .Pasc.BinaryExpr be = 4;
  bool has_be() const;
  void clear_be();
  static const int kBeFieldNumber = 4;
  private:
  const ::Pasc::BinaryExpr& _internal_be() const;
  public:
  const ::Pasc::BinaryExpr& be() const;
  ::Pasc::BinaryExpr* release_be();
  ::Pasc::BinaryExpr* mutable_be();
  void set_allocated_be(::Pasc::BinaryExpr* be);

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Expression)
 private:
  void set_has_id();
  void set_has_uint();
  void set_has_be();

  inline bool has_expr() const;
  inline void clear_has_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union ExprUnion {
    ExprUnion() {}
    ::Pasc::Identifier* id_;
    ::Pasc::UIntLiteral* uint_;
    ::Pasc::BinaryExpr* be_;
  } expr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinaryExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.BinaryExpr) */ {
 public:
  BinaryExpr();
  virtual ~BinaryExpr();

  BinaryExpr(const BinaryExpr& from);

  inline BinaryExpr& operator=(const BinaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinaryExpr(BinaryExpr&& from) noexcept
    : BinaryExpr() {
    *this = ::std::move(from);
  }

  inline BinaryExpr& operator=(BinaryExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryExpr*>(
               &_BinaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(BinaryExpr* other);
  friend void swap(BinaryExpr& a, BinaryExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinaryExpr* New() const final {
    return CreateMaybeMessage<BinaryExpr>(NULL);
  }

  BinaryExpr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinaryExpr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinaryExpr& from);
  void MergeFrom(const BinaryExpr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_left() const;
  public:
  const ::Pasc::Expression& left() const;
  ::Pasc::Expression* release_left();
  ::Pasc::Expression* mutable_left();
  void set_allocated_left(::Pasc::Expression* left);

  // .Pasc.Expression right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_right() const;
  public:
  const ::Pasc::Expression& right() const;
  ::Pasc::Expression* release_right();
  ::Pasc::Expression* mutable_right();
  void set_allocated_right(::Pasc::Expression* right);

  // .Pasc.Operator op = 3;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 3;
  private:
  const ::Pasc::Operator& _internal_op() const;
  public:
  const ::Pasc::Operator& op() const;
  ::Pasc::Operator* release_op();
  ::Pasc::Operator* mutable_op();
  void set_allocated_op(::Pasc::Operator* op);

  // @@protoc_insertion_point(class_scope:Pasc.BinaryExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* left_;
  ::Pasc::Expression* right_;
  ::Pasc::Operator* op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UIntLiteral : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.UIntLiteral) */ {
 public:
  UIntLiteral();
  virtual ~UIntLiteral();

  UIntLiteral(const UIntLiteral& from);

  inline UIntLiteral& operator=(const UIntLiteral& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UIntLiteral(UIntLiteral&& from) noexcept
    : UIntLiteral() {
    *this = ::std::move(from);
  }

  inline UIntLiteral& operator=(UIntLiteral&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UIntLiteral& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UIntLiteral* internal_default_instance() {
    return reinterpret_cast<const UIntLiteral*>(
               &_UIntLiteral_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(UIntLiteral* other);
  friend void swap(UIntLiteral& a, UIntLiteral& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UIntLiteral* New() const final {
    return CreateMaybeMessage<UIntLiteral>(NULL);
  }

  UIntLiteral* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UIntLiteral>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UIntLiteral& from);
  void MergeFrom(const UIntLiteral& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIntLiteral* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Pasc.UIntLiteral)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type) */ {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(Type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();

  enum TypeCase {
    kInt = 2,
    kReal = 3,
    kBool = 4,
    kChar = 5,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Type* other);
  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(NULL);
  }

  Type* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.TypeKind tk = 1;
  void clear_tk();
  static const int kTkFieldNumber = 1;
  ::Pasc::TypeKind tk() const;
  void set_tk(::Pasc::TypeKind value);

  // .Pasc.Integer int = 2;
  bool has_int_() const;
  void clear_int_();
  static const int kIntFieldNumber = 2;
  private:
  const ::Pasc::Integer& _internal_int_() const;
  public:
  const ::Pasc::Integer& int_() const;
  ::Pasc::Integer* release_int_();
  ::Pasc::Integer* mutable_int_();
  void set_allocated_int_(::Pasc::Integer* int_);

  // .Pasc.Real real = 3;
  bool has_real() const;
  void clear_real();
  static const int kRealFieldNumber = 3;
  private:
  const ::Pasc::Real& _internal_real() const;
  public:
  const ::Pasc::Real& real() const;
  ::Pasc::Real* release_real();
  ::Pasc::Real* mutable_real();
  void set_allocated_real(::Pasc::Real* real);

  // .Pasc.Boolean bool = 4;
  bool has_bool_() const;
  void clear_bool_();
  static const int kBoolFieldNumber = 4;
  private:
  const ::Pasc::Boolean& _internal_bool_() const;
  public:
  const ::Pasc::Boolean& bool_() const;
  ::Pasc::Boolean* release_bool_();
  ::Pasc::Boolean* mutable_bool_();
  void set_allocated_bool_(::Pasc::Boolean* bool_);

  // .Pasc.Char char = 5;
  bool has_char_() const;
  void clear_char_();
  static const int kCharFieldNumber = 5;
  private:
  const ::Pasc::Char& _internal_char_() const;
  public:
  const ::Pasc::Char& char_() const;
  ::Pasc::Char* release_char_();
  ::Pasc::Char* mutable_char_();
  void set_allocated_char_(::Pasc::Char* char_);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Type)
 private:
  void set_has_int_();
  void set_has_real();
  void set_has_bool_();
  void set_has_char_();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int tk_;
  union TypeUnion {
    TypeUnion() {}
    ::Pasc::Integer* int__;
    ::Pasc::Real* real_;
    ::Pasc::Boolean* bool__;
    ::Pasc::Char* char__;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Integer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Integer) */ {
 public:
  Integer();
  virtual ~Integer();

  Integer(const Integer& from);

  inline Integer& operator=(const Integer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Integer(Integer&& from) noexcept
    : Integer() {
    *this = ::std::move(from);
  }

  inline Integer& operator=(Integer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Integer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Integer* internal_default_instance() {
    return reinterpret_cast<const Integer*>(
               &_Integer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(Integer* other);
  friend void swap(Integer& a, Integer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Integer* New() const final {
    return CreateMaybeMessage<Integer>(NULL);
  }

  Integer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Integer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Integer& from);
  void MergeFrom(const Integer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Integer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Integer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Boolean : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Boolean) */ {
 public:
  Boolean();
  virtual ~Boolean();

  Boolean(const Boolean& from);

  inline Boolean& operator=(const Boolean& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Boolean(Boolean&& from) noexcept
    : Boolean() {
    *this = ::std::move(from);
  }

  inline Boolean& operator=(Boolean&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Boolean& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Boolean* internal_default_instance() {
    return reinterpret_cast<const Boolean*>(
               &_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Boolean* other);
  friend void swap(Boolean& a, Boolean& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Boolean* New() const final {
    return CreateMaybeMessage<Boolean>(NULL);
  }

  Boolean* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Boolean>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Boolean& from);
  void MergeFrom(const Boolean& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Boolean* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Boolean)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Real : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Real) */ {
 public:
  Real();
  virtual ~Real();

  Real(const Real& from);

  inline Real& operator=(const Real& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Real(Real&& from) noexcept
    : Real() {
    *this = ::std::move(from);
  }

  inline Real& operator=(Real&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Real& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Real* internal_default_instance() {
    return reinterpret_cast<const Real*>(
               &_Real_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Real* other);
  friend void swap(Real& a, Real& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Real* New() const final {
    return CreateMaybeMessage<Real>(NULL);
  }

  Real* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Real>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Real& from);
  void MergeFrom(const Real& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Real* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Real)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Char : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Char) */ {
 public:
  Char();
  virtual ~Char();

  Char(const Char& from);

  inline Char& operator=(const Char& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Char(Char&& from) noexcept
    : Char() {
    *this = ::std::move(from);
  }

  inline Char& operator=(Char&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Char& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Char* internal_default_instance() {
    return reinterpret_cast<const Char*>(
               &_Char_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Char* other);
  friend void swap(Char& a, Char& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Char* New() const final {
    return CreateMaybeMessage<Char>(NULL);
  }

  Char* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Char>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Char& from);
  void MergeFrom(const Char& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Char* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Char)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Operator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Operator) */ {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(Operator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Operator* other);
  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operator* New() const final {
    return CreateMaybeMessage<Operator>(NULL);
  }

  Operator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Operator_OpKind OpKind;
  static const OpKind Plus =
    Operator_OpKind_Plus;
  static const OpKind Minus =
    Operator_OpKind_Minus;
  static const OpKind Div =
    Operator_OpKind_Div;
  static const OpKind Sub =
    Operator_OpKind_Sub;
  static const OpKind Mod =
    Operator_OpKind_Mod;
  static const OpKind And =
    Operator_OpKind_And;
  static const OpKind Or =
    Operator_OpKind_Or;
  static const OpKind In =
    Operator_OpKind_In;
  static const OpKind Equal =
    Operator_OpKind_Equal;
  static const OpKind Less =
    Operator_OpKind_Less;
  static const OpKind Great =
    Operator_OpKind_Great;
  static inline bool OpKind_IsValid(int value) {
    return Operator_OpKind_IsValid(value);
  }
  static const OpKind OpKind_MIN =
    Operator_OpKind_OpKind_MIN;
  static const OpKind OpKind_MAX =
    Operator_OpKind_OpKind_MAX;
  static const int OpKind_ARRAYSIZE =
    Operator_OpKind_OpKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpKind_descriptor() {
    return Operator_OpKind_descriptor();
  }
  static inline const ::std::string& OpKind_Name(OpKind value) {
    return Operator_OpKind_Name(value);
  }
  static inline bool OpKind_Parse(const ::std::string& name,
      OpKind* value) {
    return Operator_OpKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Operator.OpKind op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::Pasc::Operator_OpKind op() const;
  void set_op(::Pasc::Operator_OpKind value);

  // @@protoc_insertion_point(class_scope:Pasc.Operator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Program

// .Pasc.TokenKind kind = 1;
inline void Program::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::TokenKind Program::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Program.kind)
  return static_cast< ::Pasc::TokenKind >(kind_);
}
inline void Program::set_kind(::Pasc::TokenKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Program.kind)
}

// string name = 2;
inline void Program::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Program::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Program.name)
  return name_.GetNoArena();
}
inline void Program::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Program.name)
}
#if LANG_CXX11
inline void Program::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Program.name)
}
#endif
inline void Program::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Program.name)
}
inline void Program::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Program.name)
}
inline ::std::string* Program::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Program.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Program::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Program.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Program::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Program.name)
}

// repeated string params = 3;
inline int Program::params_size() const {
  return params_.size();
}
inline void Program::clear_params() {
  params_.Clear();
}
inline const ::std::string& Program::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Program.params)
  return params_.Get(index);
}
inline ::std::string* Program::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Program.params)
  return params_.Mutable(index);
}
inline void Program::set_params(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Pasc.Program.params)
  params_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Program::set_params(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Pasc.Program.params)
  params_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Program::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Pasc.Program.params)
}
inline void Program::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pasc.Program.params)
}
inline ::std::string* Program::add_params() {
  // @@protoc_insertion_point(field_add_mutable:Pasc.Program.params)
  return params_.Add();
}
inline void Program::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Pasc.Program.params)
}
#if LANG_CXX11
inline void Program::add_params(::std::string&& value) {
  params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Pasc.Program.params)
}
#endif
inline void Program::add_params(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Pasc.Program.params)
}
inline void Program::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Pasc.Program.params)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Program::params() const {
  // @@protoc_insertion_point(field_list:Pasc.Program.params)
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Program::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Program.params)
  return &params_;
}

// .Pasc.Block block = 4;
inline bool Program::has_block() const {
  return this != internal_default_instance() && block_ != NULL;
}
inline void Program::clear_block() {
  if (GetArenaNoVirtual() == NULL && block_ != NULL) {
    delete block_;
  }
  block_ = NULL;
}
inline const ::Pasc::Block& Program::_internal_block() const {
  return *block_;
}
inline const ::Pasc::Block& Program::block() const {
  const ::Pasc::Block* p = block_;
  // @@protoc_insertion_point(field_get:Pasc.Program.block)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Block*>(
      &::Pasc::_Block_default_instance_);
}
inline ::Pasc::Block* Program::release_block() {
  // @@protoc_insertion_point(field_release:Pasc.Program.block)
  
  ::Pasc::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::Pasc::Block* Program::mutable_block() {
  
  if (block_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Program.block)
  return block_;
}
inline void Program::set_allocated_block(::Pasc::Block* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:Pasc.Program.block)
}

// -------------------------------------------------------------------

// Block

// repeated .Pasc.VarDeclaration varDeclrs = 1;
inline int Block::vardeclrs_size() const {
  return vardeclrs_.size();
}
inline void Block::clear_vardeclrs() {
  vardeclrs_.Clear();
}
inline ::Pasc::VarDeclaration* Block::mutable_vardeclrs(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Block.varDeclrs)
  return vardeclrs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >*
Block::mutable_vardeclrs() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Block.varDeclrs)
  return &vardeclrs_;
}
inline const ::Pasc::VarDeclaration& Block::vardeclrs(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Block.varDeclrs)
  return vardeclrs_.Get(index);
}
inline ::Pasc::VarDeclaration* Block::add_vardeclrs() {
  // @@protoc_insertion_point(field_add:Pasc.Block.varDeclrs)
  return vardeclrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >&
Block::vardeclrs() const {
  // @@protoc_insertion_point(field_list:Pasc.Block.varDeclrs)
  return vardeclrs_;
}

// repeated .Pasc.Statement stmts = 2;
inline int Block::stmts_size() const {
  return stmts_.size();
}
inline void Block::clear_stmts() {
  stmts_.Clear();
}
inline ::Pasc::Statement* Block::mutable_stmts(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Block.stmts)
  return stmts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
Block::mutable_stmts() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Block.stmts)
  return &stmts_;
}
inline const ::Pasc::Statement& Block::stmts(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Block.stmts)
  return stmts_.Get(index);
}
inline ::Pasc::Statement* Block::add_stmts() {
  // @@protoc_insertion_point(field_add:Pasc.Block.stmts)
  return stmts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
Block::stmts() const {
  // @@protoc_insertion_point(field_list:Pasc.Block.stmts)
  return stmts_;
}

// -------------------------------------------------------------------

// VarDeclaration

// .Pasc.Expression name = 1;
inline bool VarDeclaration::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void VarDeclaration::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Expression& VarDeclaration::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Expression& VarDeclaration::name() const {
  const ::Pasc::Expression* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.VarDeclaration.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* VarDeclaration::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.VarDeclaration.name)
  
  ::Pasc::Expression* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Expression* VarDeclaration::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.VarDeclaration.name)
  return name_;
}
inline void VarDeclaration::set_allocated_name(::Pasc::Expression* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.VarDeclaration.name)
}

// .Pasc.Type type = 2;
inline bool VarDeclaration::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void VarDeclaration::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}
inline const ::Pasc::Type& VarDeclaration::_internal_type() const {
  return *type_;
}
inline const ::Pasc::Type& VarDeclaration::type() const {
  const ::Pasc::Type* p = type_;
  // @@protoc_insertion_point(field_get:Pasc.VarDeclaration.type)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* VarDeclaration::release_type() {
  // @@protoc_insertion_point(field_release:Pasc.VarDeclaration.type)
  
  ::Pasc::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::Pasc::Type* VarDeclaration::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.VarDeclaration.type)
  return type_;
}
inline void VarDeclaration::set_allocated_type(::Pasc::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Pasc.VarDeclaration.type)
}

// -------------------------------------------------------------------

// AssignStmt

// .Pasc.Expression variable = 1;
inline bool AssignStmt::has_variable() const {
  return this != internal_default_instance() && variable_ != NULL;
}
inline void AssignStmt::clear_variable() {
  if (GetArenaNoVirtual() == NULL && variable_ != NULL) {
    delete variable_;
  }
  variable_ = NULL;
}
inline const ::Pasc::Expression& AssignStmt::_internal_variable() const {
  return *variable_;
}
inline const ::Pasc::Expression& AssignStmt::variable() const {
  const ::Pasc::Expression* p = variable_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStmt.variable)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* AssignStmt::release_variable() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStmt.variable)
  
  ::Pasc::Expression* temp = variable_;
  variable_ = NULL;
  return temp;
}
inline ::Pasc::Expression* AssignStmt::mutable_variable() {
  
  if (variable_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    variable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStmt.variable)
  return variable_;
}
inline void AssignStmt::set_allocated_variable(::Pasc::Expression* variable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete variable_;
  }
  if (variable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      variable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, variable, submessage_arena);
    }
    
  } else {
    
  }
  variable_ = variable;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStmt.variable)
}

// .Pasc.Expression value = 2;
inline bool AssignStmt::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void AssignStmt::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::Pasc::Expression& AssignStmt::_internal_value() const {
  return *value_;
}
inline const ::Pasc::Expression& AssignStmt::value() const {
  const ::Pasc::Expression* p = value_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStmt.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* AssignStmt::release_value() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStmt.value)
  
  ::Pasc::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Pasc::Expression* AssignStmt::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStmt.value)
  return value_;
}
inline void AssignStmt::set_allocated_value(::Pasc::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStmt.value)
}

// -------------------------------------------------------------------

// ProcedureStmt

// .Pasc.Expression name = 1;
inline bool ProcedureStmt::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void ProcedureStmt::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Expression& ProcedureStmt::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Expression& ProcedureStmt::name() const {
  const ::Pasc::Expression* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStmt.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStmt::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStmt.name)
  
  ::Pasc::Expression* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStmt::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStmt.name)
  return name_;
}
inline void ProcedureStmt::set_allocated_name(::Pasc::Expression* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStmt.name)
}

// repeated .Pasc.Expression args = 2;
inline int ProcedureStmt::args_size() const {
  return args_.size();
}
inline void ProcedureStmt::clear_args() {
  args_.Clear();
}
inline ::Pasc::Expression* ProcedureStmt::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStmt.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStmt::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStmt.args)
  return &args_;
}
inline const ::Pasc::Expression& ProcedureStmt::args(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStmt.args)
  return args_.Get(index);
}
inline ::Pasc::Expression* ProcedureStmt::add_args() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStmt.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStmt::args() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStmt.args)
  return args_;
}

// -------------------------------------------------------------------

// IfStmt

// .Pasc.Expression cond = 1;
inline bool IfStmt::has_cond() const {
  return this != internal_default_instance() && cond_ != NULL;
}
inline void IfStmt::clear_cond() {
  if (GetArenaNoVirtual() == NULL && cond_ != NULL) {
    delete cond_;
  }
  cond_ = NULL;
}
inline const ::Pasc::Expression& IfStmt::_internal_cond() const {
  return *cond_;
}
inline const ::Pasc::Expression& IfStmt::cond() const {
  const ::Pasc::Expression* p = cond_;
  // @@protoc_insertion_point(field_get:Pasc.IfStmt.cond)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* IfStmt::release_cond() {
  // @@protoc_insertion_point(field_release:Pasc.IfStmt.cond)
  
  ::Pasc::Expression* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline ::Pasc::Expression* IfStmt::mutable_cond() {
  
  if (cond_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStmt.cond)
  return cond_;
}
inline void IfStmt::set_allocated_cond(::Pasc::Expression* cond) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cond_;
  }
  if (cond) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cond = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    
  } else {
    
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStmt.cond)
}

// .Pasc.Statement truePath = 2;
inline bool IfStmt::has_truepath() const {
  return this != internal_default_instance() && truepath_ != NULL;
}
inline void IfStmt::clear_truepath() {
  if (GetArenaNoVirtual() == NULL && truepath_ != NULL) {
    delete truepath_;
  }
  truepath_ = NULL;
}
inline const ::Pasc::Statement& IfStmt::_internal_truepath() const {
  return *truepath_;
}
inline const ::Pasc::Statement& IfStmt::truepath() const {
  const ::Pasc::Statement* p = truepath_;
  // @@protoc_insertion_point(field_get:Pasc.IfStmt.truePath)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* IfStmt::release_truepath() {
  // @@protoc_insertion_point(field_release:Pasc.IfStmt.truePath)
  
  ::Pasc::Statement* temp = truepath_;
  truepath_ = NULL;
  return temp;
}
inline ::Pasc::Statement* IfStmt::mutable_truepath() {
  
  if (truepath_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    truepath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStmt.truePath)
  return truepath_;
}
inline void IfStmt::set_allocated_truepath(::Pasc::Statement* truepath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete truepath_;
  }
  if (truepath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      truepath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, truepath, submessage_arena);
    }
    
  } else {
    
  }
  truepath_ = truepath;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStmt.truePath)
}

// .Pasc.Statement elsePath = 3;
inline bool IfStmt::has_elsepath() const {
  return this != internal_default_instance() && elsepath_ != NULL;
}
inline void IfStmt::clear_elsepath() {
  if (GetArenaNoVirtual() == NULL && elsepath_ != NULL) {
    delete elsepath_;
  }
  elsepath_ = NULL;
}
inline const ::Pasc::Statement& IfStmt::_internal_elsepath() const {
  return *elsepath_;
}
inline const ::Pasc::Statement& IfStmt::elsepath() const {
  const ::Pasc::Statement* p = elsepath_;
  // @@protoc_insertion_point(field_get:Pasc.IfStmt.elsePath)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* IfStmt::release_elsepath() {
  // @@protoc_insertion_point(field_release:Pasc.IfStmt.elsePath)
  
  ::Pasc::Statement* temp = elsepath_;
  elsepath_ = NULL;
  return temp;
}
inline ::Pasc::Statement* IfStmt::mutable_elsepath() {
  
  if (elsepath_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    elsepath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStmt.elsePath)
  return elsepath_;
}
inline void IfStmt::set_allocated_elsepath(::Pasc::Statement* elsepath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete elsepath_;
  }
  if (elsepath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      elsepath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, elsepath, submessage_arena);
    }
    
  } else {
    
  }
  elsepath_ = elsepath;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStmt.elsePath)
}

// -------------------------------------------------------------------

// Statement

// .Pasc.TokenKind kind = 1;
inline void Statement::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::TokenKind Statement::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.kind)
  return static_cast< ::Pasc::TokenKind >(kind_);
}
inline void Statement::set_kind(::Pasc::TokenKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Statement.kind)
}

// .Pasc.AssignStmt assignStmt = 2;
inline bool Statement::has_assignstmt() const {
  return stmt_case() == kAssignStmt;
}
inline void Statement::set_has_assignstmt() {
  _oneof_case_[0] = kAssignStmt;
}
inline void Statement::clear_assignstmt() {
  if (has_assignstmt()) {
    delete stmt_.assignstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::AssignStmt& Statement::_internal_assignstmt() const {
  return *stmt_.assignstmt_;
}
inline ::Pasc::AssignStmt* Statement::release_assignstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.assignStmt)
  if (has_assignstmt()) {
    clear_has_stmt();
      ::Pasc::AssignStmt* temp = stmt_.assignstmt_;
    stmt_.assignstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::AssignStmt& Statement::assignstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.assignStmt)
  return has_assignstmt()
      ? *stmt_.assignstmt_
      : *reinterpret_cast< ::Pasc::AssignStmt*>(&::Pasc::_AssignStmt_default_instance_);
}
inline ::Pasc::AssignStmt* Statement::mutable_assignstmt() {
  if (!has_assignstmt()) {
    clear_stmt();
    set_has_assignstmt();
    stmt_.assignstmt_ = CreateMaybeMessage< ::Pasc::AssignStmt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.assignStmt)
  return stmt_.assignstmt_;
}

// .Pasc.ProcedureStmt procStmt = 3;
inline bool Statement::has_procstmt() const {
  return stmt_case() == kProcStmt;
}
inline void Statement::set_has_procstmt() {
  _oneof_case_[0] = kProcStmt;
}
inline void Statement::clear_procstmt() {
  if (has_procstmt()) {
    delete stmt_.procstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStmt& Statement::_internal_procstmt() const {
  return *stmt_.procstmt_;
}
inline ::Pasc::ProcedureStmt* Statement::release_procstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.procStmt)
  if (has_procstmt()) {
    clear_has_stmt();
      ::Pasc::ProcedureStmt* temp = stmt_.procstmt_;
    stmt_.procstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStmt& Statement::procstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.procStmt)
  return has_procstmt()
      ? *stmt_.procstmt_
      : *reinterpret_cast< ::Pasc::ProcedureStmt*>(&::Pasc::_ProcedureStmt_default_instance_);
}
inline ::Pasc::ProcedureStmt* Statement::mutable_procstmt() {
  if (!has_procstmt()) {
    clear_stmt();
    set_has_procstmt();
    stmt_.procstmt_ = CreateMaybeMessage< ::Pasc::ProcedureStmt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.procStmt)
  return stmt_.procstmt_;
}

// .Pasc.IfStmt ifStmt = 4;
inline bool Statement::has_ifstmt() const {
  return stmt_case() == kIfStmt;
}
inline void Statement::set_has_ifstmt() {
  _oneof_case_[0] = kIfStmt;
}
inline void Statement::clear_ifstmt() {
  if (has_ifstmt()) {
    delete stmt_.ifstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::IfStmt& Statement::_internal_ifstmt() const {
  return *stmt_.ifstmt_;
}
inline ::Pasc::IfStmt* Statement::release_ifstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.ifStmt)
  if (has_ifstmt()) {
    clear_has_stmt();
      ::Pasc::IfStmt* temp = stmt_.ifstmt_;
    stmt_.ifstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::IfStmt& Statement::ifstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.ifStmt)
  return has_ifstmt()
      ? *stmt_.ifstmt_
      : *reinterpret_cast< ::Pasc::IfStmt*>(&::Pasc::_IfStmt_default_instance_);
}
inline ::Pasc::IfStmt* Statement::mutable_ifstmt() {
  if (!has_ifstmt()) {
    clear_stmt();
    set_has_ifstmt();
    stmt_.ifstmt_ = CreateMaybeMessage< ::Pasc::IfStmt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.ifStmt)
  return stmt_.ifstmt_;
}

inline bool Statement::has_stmt() const {
  return stmt_case() != STMT_NOT_SET;
}
inline void Statement::clear_has_stmt() {
  _oneof_case_[0] = STMT_NOT_SET;
}
inline Statement::StmtCase Statement::stmt_case() const {
  return Statement::StmtCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Identifier_Variable

// string name = 1;
inline void Identifier_Variable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier_Variable::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.Variable.name)
  return name_.GetNoArena();
}
inline void Identifier_Variable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Identifier.Variable.name)
}
#if LANG_CXX11
inline void Identifier_Variable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Identifier.Variable.name)
}
#endif
inline void Identifier_Variable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Identifier.Variable.name)
}
inline void Identifier_Variable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Identifier.Variable.name)
}
inline ::std::string* Identifier_Variable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.Variable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier_Variable::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.Variable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier_Variable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Identifier.Variable.name)
}

// -------------------------------------------------------------------

// Identifier_IndexedVariable

// -------------------------------------------------------------------

// Identifier_FieldDesignator

// -------------------------------------------------------------------

// Identifier

// .Pasc.Identifier.IDKind kind = 1;
inline void Identifier::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Identifier_IDKind Identifier::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.kind)
  return static_cast< ::Pasc::Identifier_IDKind >(kind_);
}
inline void Identifier::set_kind(::Pasc::Identifier_IDKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Identifier.kind)
}

// .Pasc.Identifier.Variable var = 2;
inline bool Identifier::has_var() const {
  return value_case() == kVar;
}
inline void Identifier::set_has_var() {
  _oneof_case_[0] = kVar;
}
inline void Identifier::clear_var() {
  if (has_var()) {
    delete value_.var_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_Variable& Identifier::_internal_var() const {
  return *value_.var_;
}
inline ::Pasc::Identifier_Variable* Identifier::release_var() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.var)
  if (has_var()) {
    clear_has_value();
      ::Pasc::Identifier_Variable* temp = value_.var_;
    value_.var_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_Variable& Identifier::var() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.var)
  return has_var()
      ? *value_.var_
      : *reinterpret_cast< ::Pasc::Identifier_Variable*>(&::Pasc::_Identifier_Variable_default_instance_);
}
inline ::Pasc::Identifier_Variable* Identifier::mutable_var() {
  if (!has_var()) {
    clear_value();
    set_has_var();
    value_.var_ = CreateMaybeMessage< ::Pasc::Identifier_Variable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.var)
  return value_.var_;
}

// .Pasc.Identifier.IndexedVariable iv = 3;
inline bool Identifier::has_iv() const {
  return value_case() == kIv;
}
inline void Identifier::set_has_iv() {
  _oneof_case_[0] = kIv;
}
inline void Identifier::clear_iv() {
  if (has_iv()) {
    delete value_.iv_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_IndexedVariable& Identifier::_internal_iv() const {
  return *value_.iv_;
}
inline ::Pasc::Identifier_IndexedVariable* Identifier::release_iv() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.iv)
  if (has_iv()) {
    clear_has_value();
      ::Pasc::Identifier_IndexedVariable* temp = value_.iv_;
    value_.iv_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_IndexedVariable& Identifier::iv() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.iv)
  return has_iv()
      ? *value_.iv_
      : *reinterpret_cast< ::Pasc::Identifier_IndexedVariable*>(&::Pasc::_Identifier_IndexedVariable_default_instance_);
}
inline ::Pasc::Identifier_IndexedVariable* Identifier::mutable_iv() {
  if (!has_iv()) {
    clear_value();
    set_has_iv();
    value_.iv_ = CreateMaybeMessage< ::Pasc::Identifier_IndexedVariable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.iv)
  return value_.iv_;
}

// .Pasc.Identifier.FieldDesignator fld = 4;
inline bool Identifier::has_fld() const {
  return value_case() == kFld;
}
inline void Identifier::set_has_fld() {
  _oneof_case_[0] = kFld;
}
inline void Identifier::clear_fld() {
  if (has_fld()) {
    delete value_.fld_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_FieldDesignator& Identifier::_internal_fld() const {
  return *value_.fld_;
}
inline ::Pasc::Identifier_FieldDesignator* Identifier::release_fld() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.fld)
  if (has_fld()) {
    clear_has_value();
      ::Pasc::Identifier_FieldDesignator* temp = value_.fld_;
    value_.fld_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_FieldDesignator& Identifier::fld() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.fld)
  return has_fld()
      ? *value_.fld_
      : *reinterpret_cast< ::Pasc::Identifier_FieldDesignator*>(&::Pasc::_Identifier_FieldDesignator_default_instance_);
}
inline ::Pasc::Identifier_FieldDesignator* Identifier::mutable_fld() {
  if (!has_fld()) {
    clear_value();
    set_has_fld();
    value_.fld_ = CreateMaybeMessage< ::Pasc::Identifier_FieldDesignator >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.fld)
  return value_.fld_;
}

inline bool Identifier::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Identifier::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Identifier::ValueCase Identifier::value_case() const {
  return Identifier::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression

// .Pasc.Expression.ExprKind kind = 1;
inline void Expression::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Expression_ExprKind Expression::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.kind)
  return static_cast< ::Pasc::Expression_ExprKind >(kind_);
}
inline void Expression::set_kind(::Pasc::Expression_ExprKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Expression.kind)
}

// .Pasc.Identifier id = 2;
inline bool Expression::has_id() const {
  return expr_case() == kId;
}
inline void Expression::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void Expression::clear_id() {
  if (has_id()) {
    delete expr_.id_;
    clear_has_expr();
  }
}
inline const ::Pasc::Identifier& Expression::_internal_id() const {
  return *expr_.id_;
}
inline ::Pasc::Identifier* Expression::release_id() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.id)
  if (has_id()) {
    clear_has_expr();
      ::Pasc::Identifier* temp = expr_.id_;
    expr_.id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier& Expression::id() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.id)
  return has_id()
      ? *expr_.id_
      : *reinterpret_cast< ::Pasc::Identifier*>(&::Pasc::_Identifier_default_instance_);
}
inline ::Pasc::Identifier* Expression::mutable_id() {
  if (!has_id()) {
    clear_expr();
    set_has_id();
    expr_.id_ = CreateMaybeMessage< ::Pasc::Identifier >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.id)
  return expr_.id_;
}

// .Pasc.UIntLiteral uint = 3;
inline bool Expression::has_uint() const {
  return expr_case() == kUint;
}
inline void Expression::set_has_uint() {
  _oneof_case_[0] = kUint;
}
inline void Expression::clear_uint() {
  if (has_uint()) {
    delete expr_.uint_;
    clear_has_expr();
  }
}
inline const ::Pasc::UIntLiteral& Expression::_internal_uint() const {
  return *expr_.uint_;
}
inline ::Pasc::UIntLiteral* Expression::release_uint() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.uint)
  if (has_uint()) {
    clear_has_expr();
      ::Pasc::UIntLiteral* temp = expr_.uint_;
    expr_.uint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::UIntLiteral& Expression::uint() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.uint)
  return has_uint()
      ? *expr_.uint_
      : *reinterpret_cast< ::Pasc::UIntLiteral*>(&::Pasc::_UIntLiteral_default_instance_);
}
inline ::Pasc::UIntLiteral* Expression::mutable_uint() {
  if (!has_uint()) {
    clear_expr();
    set_has_uint();
    expr_.uint_ = CreateMaybeMessage< ::Pasc::UIntLiteral >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.uint)
  return expr_.uint_;
}

// .Pasc.BinaryExpr be = 4;
inline bool Expression::has_be() const {
  return expr_case() == kBe;
}
inline void Expression::set_has_be() {
  _oneof_case_[0] = kBe;
}
inline void Expression::clear_be() {
  if (has_be()) {
    delete expr_.be_;
    clear_has_expr();
  }
}
inline const ::Pasc::BinaryExpr& Expression::_internal_be() const {
  return *expr_.be_;
}
inline ::Pasc::BinaryExpr* Expression::release_be() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.be)
  if (has_be()) {
    clear_has_expr();
      ::Pasc::BinaryExpr* temp = expr_.be_;
    expr_.be_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::BinaryExpr& Expression::be() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.be)
  return has_be()
      ? *expr_.be_
      : *reinterpret_cast< ::Pasc::BinaryExpr*>(&::Pasc::_BinaryExpr_default_instance_);
}
inline ::Pasc::BinaryExpr* Expression::mutable_be() {
  if (!has_be()) {
    clear_expr();
    set_has_be();
    expr_.be_ = CreateMaybeMessage< ::Pasc::BinaryExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.be)
  return expr_.be_;
}

inline bool Expression::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void Expression::clear_has_expr() {
  _oneof_case_[0] = EXPR_NOT_SET;
}
inline Expression::ExprCase Expression::expr_case() const {
  return Expression::ExprCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinaryExpr

// .Pasc.Expression left = 1;
inline bool BinaryExpr::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void BinaryExpr::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::Pasc::Expression& BinaryExpr::_internal_left() const {
  return *left_;
}
inline const ::Pasc::Expression& BinaryExpr::left() const {
  const ::Pasc::Expression* p = left_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.left)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* BinaryExpr::release_left() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.left)
  
  ::Pasc::Expression* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::Pasc::Expression* BinaryExpr::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.left)
  return left_;
}
inline void BinaryExpr::set_allocated_left(::Pasc::Expression* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.left)
}

// .Pasc.Expression right = 2;
inline bool BinaryExpr::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void BinaryExpr::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::Pasc::Expression& BinaryExpr::_internal_right() const {
  return *right_;
}
inline const ::Pasc::Expression& BinaryExpr::right() const {
  const ::Pasc::Expression* p = right_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.right)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* BinaryExpr::release_right() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.right)
  
  ::Pasc::Expression* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::Pasc::Expression* BinaryExpr::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.right)
  return right_;
}
inline void BinaryExpr::set_allocated_right(::Pasc::Expression* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.right)
}

// .Pasc.Operator op = 3;
inline bool BinaryExpr::has_op() const {
  return this != internal_default_instance() && op_ != NULL;
}
inline void BinaryExpr::clear_op() {
  if (GetArenaNoVirtual() == NULL && op_ != NULL) {
    delete op_;
  }
  op_ = NULL;
}
inline const ::Pasc::Operator& BinaryExpr::_internal_op() const {
  return *op_;
}
inline const ::Pasc::Operator& BinaryExpr::op() const {
  const ::Pasc::Operator* p = op_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.op)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Operator*>(
      &::Pasc::_Operator_default_instance_);
}
inline ::Pasc::Operator* BinaryExpr::release_op() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.op)
  
  ::Pasc::Operator* temp = op_;
  op_ = NULL;
  return temp;
}
inline ::Pasc::Operator* BinaryExpr::mutable_op() {
  
  if (op_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Operator>(GetArenaNoVirtual());
    op_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.op)
  return op_;
}
inline void BinaryExpr::set_allocated_op(::Pasc::Operator* op) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete op_;
  }
  if (op) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      op = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.op)
}

// -------------------------------------------------------------------

// UIntLiteral

// int32 value = 1;
inline void UIntLiteral::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 UIntLiteral::value() const {
  // @@protoc_insertion_point(field_get:Pasc.UIntLiteral.value)
  return value_;
}
inline void UIntLiteral::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Pasc.UIntLiteral.value)
}

// -------------------------------------------------------------------

// Type

// .Pasc.TypeKind tk = 1;
inline void Type::clear_tk() {
  tk_ = 0;
}
inline ::Pasc::TypeKind Type::tk() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.tk)
  return static_cast< ::Pasc::TypeKind >(tk_);
}
inline void Type::set_tk(::Pasc::TypeKind value) {
  
  tk_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Type.tk)
}

// .Pasc.Integer int = 2;
inline bool Type::has_int_() const {
  return type_case() == kInt;
}
inline void Type::set_has_int_() {
  _oneof_case_[0] = kInt;
}
inline void Type::clear_int_() {
  if (has_int_()) {
    delete type_.int__;
    clear_has_type();
  }
}
inline const ::Pasc::Integer& Type::_internal_int_() const {
  return *type_.int__;
}
inline ::Pasc::Integer* Type::release_int_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.int)
  if (has_int_()) {
    clear_has_type();
      ::Pasc::Integer* temp = type_.int__;
    type_.int__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Integer& Type::int_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.int)
  return has_int_()
      ? *type_.int__
      : *reinterpret_cast< ::Pasc::Integer*>(&::Pasc::_Integer_default_instance_);
}
inline ::Pasc::Integer* Type::mutable_int_() {
  if (!has_int_()) {
    clear_type();
    set_has_int_();
    type_.int__ = CreateMaybeMessage< ::Pasc::Integer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.int)
  return type_.int__;
}

// .Pasc.Real real = 3;
inline bool Type::has_real() const {
  return type_case() == kReal;
}
inline void Type::set_has_real() {
  _oneof_case_[0] = kReal;
}
inline void Type::clear_real() {
  if (has_real()) {
    delete type_.real_;
    clear_has_type();
  }
}
inline const ::Pasc::Real& Type::_internal_real() const {
  return *type_.real_;
}
inline ::Pasc::Real* Type::release_real() {
  // @@protoc_insertion_point(field_release:Pasc.Type.real)
  if (has_real()) {
    clear_has_type();
      ::Pasc::Real* temp = type_.real_;
    type_.real_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Real& Type::real() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.real)
  return has_real()
      ? *type_.real_
      : *reinterpret_cast< ::Pasc::Real*>(&::Pasc::_Real_default_instance_);
}
inline ::Pasc::Real* Type::mutable_real() {
  if (!has_real()) {
    clear_type();
    set_has_real();
    type_.real_ = CreateMaybeMessage< ::Pasc::Real >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.real)
  return type_.real_;
}

// .Pasc.Boolean bool = 4;
inline bool Type::has_bool_() const {
  return type_case() == kBool;
}
inline void Type::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void Type::clear_bool_() {
  if (has_bool_()) {
    delete type_.bool__;
    clear_has_type();
  }
}
inline const ::Pasc::Boolean& Type::_internal_bool_() const {
  return *type_.bool__;
}
inline ::Pasc::Boolean* Type::release_bool_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.bool)
  if (has_bool_()) {
    clear_has_type();
      ::Pasc::Boolean* temp = type_.bool__;
    type_.bool__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Boolean& Type::bool_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.bool)
  return has_bool_()
      ? *type_.bool__
      : *reinterpret_cast< ::Pasc::Boolean*>(&::Pasc::_Boolean_default_instance_);
}
inline ::Pasc::Boolean* Type::mutable_bool_() {
  if (!has_bool_()) {
    clear_type();
    set_has_bool_();
    type_.bool__ = CreateMaybeMessage< ::Pasc::Boolean >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.bool)
  return type_.bool__;
}

// .Pasc.Char char = 5;
inline bool Type::has_char_() const {
  return type_case() == kChar;
}
inline void Type::set_has_char_() {
  _oneof_case_[0] = kChar;
}
inline void Type::clear_char_() {
  if (has_char_()) {
    delete type_.char__;
    clear_has_type();
  }
}
inline const ::Pasc::Char& Type::_internal_char_() const {
  return *type_.char__;
}
inline ::Pasc::Char* Type::release_char_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.char)
  if (has_char_()) {
    clear_has_type();
      ::Pasc::Char* temp = type_.char__;
    type_.char__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Char& Type::char_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.char)
  return has_char_()
      ? *type_.char__
      : *reinterpret_cast< ::Pasc::Char*>(&::Pasc::_Char_default_instance_);
}
inline ::Pasc::Char* Type::mutable_char_() {
  if (!has_char_()) {
    clear_type();
    set_has_char_();
    type_.char__ = CreateMaybeMessage< ::Pasc::Char >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.char)
  return type_.char__;
}

inline bool Type::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Type::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Type::TypeCase Type::type_case() const {
  return Type::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Integer

// string name = 1;
inline void Integer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Integer::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Integer.name)
  return name_.GetNoArena();
}
inline void Integer::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Integer.name)
}
#if LANG_CXX11
inline void Integer::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Integer.name)
}
#endif
inline void Integer::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Integer.name)
}
inline void Integer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Integer.name)
}
inline ::std::string* Integer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Integer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Integer::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Integer.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Integer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Integer.name)
}

// -------------------------------------------------------------------

// Boolean

// string name = 1;
inline void Boolean::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Boolean::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Boolean.name)
  return name_.GetNoArena();
}
inline void Boolean::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Boolean.name)
}
#if LANG_CXX11
inline void Boolean::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Boolean.name)
}
#endif
inline void Boolean::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Boolean.name)
}
inline void Boolean::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Boolean.name)
}
inline ::std::string* Boolean::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Boolean.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Boolean::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Boolean.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Boolean::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Boolean.name)
}

// -------------------------------------------------------------------

// Real

// string name = 1;
inline void Real::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Real::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Real.name)
  return name_.GetNoArena();
}
inline void Real::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Real.name)
}
#if LANG_CXX11
inline void Real::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Real.name)
}
#endif
inline void Real::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Real.name)
}
inline void Real::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Real.name)
}
inline ::std::string* Real::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Real.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Real::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Real.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Real::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Real.name)
}

// -------------------------------------------------------------------

// Char

// string name = 1;
inline void Char::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Char::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Char.name)
  return name_.GetNoArena();
}
inline void Char::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Char.name)
}
#if LANG_CXX11
inline void Char::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Char.name)
}
#endif
inline void Char::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Char.name)
}
inline void Char::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Char.name)
}
inline ::std::string* Char::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Char.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Char::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Char.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Char::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Char.name)
}

// -------------------------------------------------------------------

// Operator

// .Pasc.Operator.OpKind op = 1;
inline void Operator::clear_op() {
  op_ = 0;
}
inline ::Pasc::Operator_OpKind Operator::op() const {
  // @@protoc_insertion_point(field_get:Pasc.Operator.op)
  return static_cast< ::Pasc::Operator_OpKind >(op_);
}
inline void Operator::set_op(::Pasc::Operator_OpKind value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Operator.op)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pasc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pasc::Identifier_IDKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Identifier_IDKind>() {
  return ::Pasc::Identifier_IDKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Expression_ExprKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Expression_ExprKind>() {
  return ::Pasc::Expression_ExprKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Operator_OpKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Operator_OpKind>() {
  return ::Pasc::Operator_OpKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::TokenKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::TokenKind>() {
  return ::Pasc::TokenKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::TypeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::TypeKind>() {
  return ::Pasc::TypeKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_program_2eproto
