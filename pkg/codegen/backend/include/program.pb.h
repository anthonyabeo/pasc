// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: program.proto

#ifndef PROTOBUF_INCLUDED_program_2eproto
#define PROTOBUF_INCLUDED_program_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_program_2eproto 

namespace protobuf_program_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[37];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_program_2eproto
namespace Pasc {
class AssignStatement;
class AssignStatementDefaultTypeInternal;
extern AssignStatementDefaultTypeInternal _AssignStatement_default_instance_;
class BinaryExpr;
class BinaryExprDefaultTypeInternal;
extern BinaryExprDefaultTypeInternal _BinaryExpr_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Callable;
class CallableDefaultTypeInternal;
extern CallableDefaultTypeInternal _Callable_default_instance_;
class Expression;
class ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class FormalParameter;
class FormalParameterDefaultTypeInternal;
extern FormalParameterDefaultTypeInternal _FormalParameter_default_instance_;
class FuncCall;
class FuncCallDefaultTypeInternal;
extern FuncCallDefaultTypeInternal _FuncCall_default_instance_;
class FuncDeclaration;
class FuncDeclarationDefaultTypeInternal;
extern FuncDeclarationDefaultTypeInternal _FuncDeclaration_default_instance_;
class FuncHeading;
class FuncHeadingDefaultTypeInternal;
extern FuncHeadingDefaultTypeInternal _FuncHeading_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Identifier_FieldDesignator;
class Identifier_FieldDesignatorDefaultTypeInternal;
extern Identifier_FieldDesignatorDefaultTypeInternal _Identifier_FieldDesignator_default_instance_;
class Identifier_IndexedVariable;
class Identifier_IndexedVariableDefaultTypeInternal;
extern Identifier_IndexedVariableDefaultTypeInternal _Identifier_IndexedVariable_default_instance_;
class Identifier_Variable;
class Identifier_VariableDefaultTypeInternal;
extern Identifier_VariableDefaultTypeInternal _Identifier_Variable_default_instance_;
class IfStatement;
class IfStatementDefaultTypeInternal;
extern IfStatementDefaultTypeInternal _IfStatement_default_instance_;
class Operator;
class OperatorDefaultTypeInternal;
extern OperatorDefaultTypeInternal _Operator_default_instance_;
class ProcDeclaration;
class ProcDeclarationDefaultTypeInternal;
extern ProcDeclarationDefaultTypeInternal _ProcDeclaration_default_instance_;
class ProcHeading;
class ProcHeadingDefaultTypeInternal;
extern ProcHeadingDefaultTypeInternal _ProcHeading_default_instance_;
class ProcedureStatement;
class ProcedureStatementDefaultTypeInternal;
extern ProcedureStatementDefaultTypeInternal _ProcedureStatement_default_instance_;
class ProcedureStatement_ProcStmt;
class ProcedureStatement_ProcStmtDefaultTypeInternal;
extern ProcedureStatement_ProcStmtDefaultTypeInternal _ProcedureStatement_ProcStmt_default_instance_;
class ProcedureStatement_Read;
class ProcedureStatement_ReadDefaultTypeInternal;
extern ProcedureStatement_ReadDefaultTypeInternal _ProcedureStatement_Read_default_instance_;
class ProcedureStatement_ReadLn;
class ProcedureStatement_ReadLnDefaultTypeInternal;
extern ProcedureStatement_ReadLnDefaultTypeInternal _ProcedureStatement_ReadLn_default_instance_;
class ProcedureStatement_Write;
class ProcedureStatement_WriteDefaultTypeInternal;
extern ProcedureStatement_WriteDefaultTypeInternal _ProcedureStatement_Write_default_instance_;
class ProcedureStatement_WriteLn;
class ProcedureStatement_WriteLnDefaultTypeInternal;
extern ProcedureStatement_WriteLnDefaultTypeInternal _ProcedureStatement_WriteLn_default_instance_;
class Program;
class ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class ReturnStatement;
class ReturnStatementDefaultTypeInternal;
extern ReturnStatementDefaultTypeInternal _ReturnStatement_default_instance_;
class Statement;
class StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class Type_Boolean;
class Type_BooleanDefaultTypeInternal;
extern Type_BooleanDefaultTypeInternal _Type_Boolean_default_instance_;
class Type_Char;
class Type_CharDefaultTypeInternal;
extern Type_CharDefaultTypeInternal _Type_Char_default_instance_;
class Type_Integer;
class Type_IntegerDefaultTypeInternal;
extern Type_IntegerDefaultTypeInternal _Type_Integer_default_instance_;
class Type_Real;
class Type_RealDefaultTypeInternal;
extern Type_RealDefaultTypeInternal _Type_Real_default_instance_;
class Type_Void;
class Type_VoidDefaultTypeInternal;
extern Type_VoidDefaultTypeInternal _Type_Void_default_instance_;
class UIntLiteral;
class UIntLiteralDefaultTypeInternal;
extern UIntLiteralDefaultTypeInternal _UIntLiteral_default_instance_;
class ValueParam;
class ValueParamDefaultTypeInternal;
extern ValueParamDefaultTypeInternal _ValueParam_default_instance_;
class VarDeclaration;
class VarDeclarationDefaultTypeInternal;
extern VarDeclarationDefaultTypeInternal _VarDeclaration_default_instance_;
class VariableParam;
class VariableParamDefaultTypeInternal;
extern VariableParamDefaultTypeInternal _VariableParam_default_instance_;
class WriteParameter;
class WriteParameterDefaultTypeInternal;
extern WriteParameterDefaultTypeInternal _WriteParameter_default_instance_;
}  // namespace Pasc
namespace google {
namespace protobuf {
template<> ::Pasc::AssignStatement* Arena::CreateMaybeMessage<::Pasc::AssignStatement>(Arena*);
template<> ::Pasc::BinaryExpr* Arena::CreateMaybeMessage<::Pasc::BinaryExpr>(Arena*);
template<> ::Pasc::Block* Arena::CreateMaybeMessage<::Pasc::Block>(Arena*);
template<> ::Pasc::Callable* Arena::CreateMaybeMessage<::Pasc::Callable>(Arena*);
template<> ::Pasc::Expression* Arena::CreateMaybeMessage<::Pasc::Expression>(Arena*);
template<> ::Pasc::FormalParameter* Arena::CreateMaybeMessage<::Pasc::FormalParameter>(Arena*);
template<> ::Pasc::FuncCall* Arena::CreateMaybeMessage<::Pasc::FuncCall>(Arena*);
template<> ::Pasc::FuncDeclaration* Arena::CreateMaybeMessage<::Pasc::FuncDeclaration>(Arena*);
template<> ::Pasc::FuncHeading* Arena::CreateMaybeMessage<::Pasc::FuncHeading>(Arena*);
template<> ::Pasc::Identifier* Arena::CreateMaybeMessage<::Pasc::Identifier>(Arena*);
template<> ::Pasc::Identifier_FieldDesignator* Arena::CreateMaybeMessage<::Pasc::Identifier_FieldDesignator>(Arena*);
template<> ::Pasc::Identifier_IndexedVariable* Arena::CreateMaybeMessage<::Pasc::Identifier_IndexedVariable>(Arena*);
template<> ::Pasc::Identifier_Variable* Arena::CreateMaybeMessage<::Pasc::Identifier_Variable>(Arena*);
template<> ::Pasc::IfStatement* Arena::CreateMaybeMessage<::Pasc::IfStatement>(Arena*);
template<> ::Pasc::Operator* Arena::CreateMaybeMessage<::Pasc::Operator>(Arena*);
template<> ::Pasc::ProcDeclaration* Arena::CreateMaybeMessage<::Pasc::ProcDeclaration>(Arena*);
template<> ::Pasc::ProcHeading* Arena::CreateMaybeMessage<::Pasc::ProcHeading>(Arena*);
template<> ::Pasc::ProcedureStatement* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement>(Arena*);
template<> ::Pasc::ProcedureStatement_ProcStmt* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_ProcStmt>(Arena*);
template<> ::Pasc::ProcedureStatement_Read* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_Read>(Arena*);
template<> ::Pasc::ProcedureStatement_ReadLn* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_ReadLn>(Arena*);
template<> ::Pasc::ProcedureStatement_Write* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_Write>(Arena*);
template<> ::Pasc::ProcedureStatement_WriteLn* Arena::CreateMaybeMessage<::Pasc::ProcedureStatement_WriteLn>(Arena*);
template<> ::Pasc::Program* Arena::CreateMaybeMessage<::Pasc::Program>(Arena*);
template<> ::Pasc::ReturnStatement* Arena::CreateMaybeMessage<::Pasc::ReturnStatement>(Arena*);
template<> ::Pasc::Statement* Arena::CreateMaybeMessage<::Pasc::Statement>(Arena*);
template<> ::Pasc::Type* Arena::CreateMaybeMessage<::Pasc::Type>(Arena*);
template<> ::Pasc::Type_Boolean* Arena::CreateMaybeMessage<::Pasc::Type_Boolean>(Arena*);
template<> ::Pasc::Type_Char* Arena::CreateMaybeMessage<::Pasc::Type_Char>(Arena*);
template<> ::Pasc::Type_Integer* Arena::CreateMaybeMessage<::Pasc::Type_Integer>(Arena*);
template<> ::Pasc::Type_Real* Arena::CreateMaybeMessage<::Pasc::Type_Real>(Arena*);
template<> ::Pasc::Type_Void* Arena::CreateMaybeMessage<::Pasc::Type_Void>(Arena*);
template<> ::Pasc::UIntLiteral* Arena::CreateMaybeMessage<::Pasc::UIntLiteral>(Arena*);
template<> ::Pasc::ValueParam* Arena::CreateMaybeMessage<::Pasc::ValueParam>(Arena*);
template<> ::Pasc::VarDeclaration* Arena::CreateMaybeMessage<::Pasc::VarDeclaration>(Arena*);
template<> ::Pasc::VariableParam* Arena::CreateMaybeMessage<::Pasc::VariableParam>(Arena*);
template<> ::Pasc::WriteParameter* Arena::CreateMaybeMessage<::Pasc::WriteParameter>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Pasc {

enum Callable_CallKind {
  Callable_CallKind_Func = 0,
  Callable_CallKind_Proc = 1,
  Callable_CallKind_Callable_CallKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Callable_CallKind_Callable_CallKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Callable_CallKind_IsValid(int value);
const Callable_CallKind Callable_CallKind_CallKind_MIN = Callable_CallKind_Func;
const Callable_CallKind Callable_CallKind_CallKind_MAX = Callable_CallKind_Proc;
const int Callable_CallKind_CallKind_ARRAYSIZE = Callable_CallKind_CallKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Callable_CallKind_descriptor();
inline const ::std::string& Callable_CallKind_Name(Callable_CallKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Callable_CallKind_descriptor(), value);
}
inline bool Callable_CallKind_Parse(
    const ::std::string& name, Callable_CallKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Callable_CallKind>(
    Callable_CallKind_descriptor(), name, value);
}
enum FormalParameter_FPKind {
  FormalParameter_FPKind_FuncHead = 0,
  FormalParameter_FPKind_ProcHead = 1,
  FormalParameter_FPKind_VarParam = 2,
  FormalParameter_FPKind_ValueParam = 3,
  FormalParameter_FPKind_FormalParameter_FPKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  FormalParameter_FPKind_FormalParameter_FPKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool FormalParameter_FPKind_IsValid(int value);
const FormalParameter_FPKind FormalParameter_FPKind_FPKind_MIN = FormalParameter_FPKind_FuncHead;
const FormalParameter_FPKind FormalParameter_FPKind_FPKind_MAX = FormalParameter_FPKind_ValueParam;
const int FormalParameter_FPKind_FPKind_ARRAYSIZE = FormalParameter_FPKind_FPKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* FormalParameter_FPKind_descriptor();
inline const ::std::string& FormalParameter_FPKind_Name(FormalParameter_FPKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    FormalParameter_FPKind_descriptor(), value);
}
inline bool FormalParameter_FPKind_Parse(
    const ::std::string& name, FormalParameter_FPKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FormalParameter_FPKind>(
    FormalParameter_FPKind_descriptor(), name, value);
}
enum ProcedureStatement_PSKind {
  ProcedureStatement_PSKind_wln = 0,
  ProcedureStatement_PSKind_write = 1,
  ProcedureStatement_PSKind_read = 2,
  ProcedureStatement_PSKind_readLn = 3,
  ProcedureStatement_PSKind_procStmt = 4,
  ProcedureStatement_PSKind_ProcedureStatement_PSKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ProcedureStatement_PSKind_ProcedureStatement_PSKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ProcedureStatement_PSKind_IsValid(int value);
const ProcedureStatement_PSKind ProcedureStatement_PSKind_PSKind_MIN = ProcedureStatement_PSKind_wln;
const ProcedureStatement_PSKind ProcedureStatement_PSKind_PSKind_MAX = ProcedureStatement_PSKind_procStmt;
const int ProcedureStatement_PSKind_PSKind_ARRAYSIZE = ProcedureStatement_PSKind_PSKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcedureStatement_PSKind_descriptor();
inline const ::std::string& ProcedureStatement_PSKind_Name(ProcedureStatement_PSKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcedureStatement_PSKind_descriptor(), value);
}
inline bool ProcedureStatement_PSKind_Parse(
    const ::std::string& name, ProcedureStatement_PSKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcedureStatement_PSKind>(
    ProcedureStatement_PSKind_descriptor(), name, value);
}
enum Statement_StmtKind {
  Statement_StmtKind_if_ = 0,
  Statement_StmtKind_assign = 1,
  Statement_StmtKind_procedure = 2,
  Statement_StmtKind_return_ = 3,
  Statement_StmtKind_Statement_StmtKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Statement_StmtKind_Statement_StmtKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Statement_StmtKind_IsValid(int value);
const Statement_StmtKind Statement_StmtKind_StmtKind_MIN = Statement_StmtKind_if_;
const Statement_StmtKind Statement_StmtKind_StmtKind_MAX = Statement_StmtKind_return_;
const int Statement_StmtKind_StmtKind_ARRAYSIZE = Statement_StmtKind_StmtKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Statement_StmtKind_descriptor();
inline const ::std::string& Statement_StmtKind_Name(Statement_StmtKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Statement_StmtKind_descriptor(), value);
}
inline bool Statement_StmtKind_Parse(
    const ::std::string& name, Statement_StmtKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Statement_StmtKind>(
    Statement_StmtKind_descriptor(), name, value);
}
enum Identifier_IDKind {
  Identifier_IDKind_EntireVar = 0,
  Identifier_IDKind_IdxVar = 1,
  Identifier_IDKind_Field = 2,
  Identifier_IDKind_Identifier_IDKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Identifier_IDKind_Identifier_IDKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Identifier_IDKind_IsValid(int value);
const Identifier_IDKind Identifier_IDKind_IDKind_MIN = Identifier_IDKind_EntireVar;
const Identifier_IDKind Identifier_IDKind_IDKind_MAX = Identifier_IDKind_Field;
const int Identifier_IDKind_IDKind_ARRAYSIZE = Identifier_IDKind_IDKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Identifier_IDKind_descriptor();
inline const ::std::string& Identifier_IDKind_Name(Identifier_IDKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Identifier_IDKind_descriptor(), value);
}
inline bool Identifier_IDKind_Parse(
    const ::std::string& name, Identifier_IDKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Identifier_IDKind>(
    Identifier_IDKind_descriptor(), name, value);
}
enum Expression_ExprKind {
  Expression_ExprKind_UInt = 0,
  Expression_ExprKind_Bool = 1,
  Expression_ExprKind_Ident = 2,
  Expression_ExprKind_BinExpr = 3,
  Expression_ExprKind_WriteParam = 4,
  Expression_ExprKind_FCall = 5,
  Expression_ExprKind_Expression_ExprKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Expression_ExprKind_Expression_ExprKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Expression_ExprKind_IsValid(int value);
const Expression_ExprKind Expression_ExprKind_ExprKind_MIN = Expression_ExprKind_UInt;
const Expression_ExprKind Expression_ExprKind_ExprKind_MAX = Expression_ExprKind_FCall;
const int Expression_ExprKind_ExprKind_ARRAYSIZE = Expression_ExprKind_ExprKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expression_ExprKind_descriptor();
inline const ::std::string& Expression_ExprKind_Name(Expression_ExprKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expression_ExprKind_descriptor(), value);
}
inline bool Expression_ExprKind_Parse(
    const ::std::string& name, Expression_ExprKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expression_ExprKind>(
    Expression_ExprKind_descriptor(), name, value);
}
enum Type_TypeKind {
  Type_TypeKind_INTEGER = 0,
  Type_TypeKind_REAL = 1,
  Type_TypeKind_BOOLEAN = 2,
  Type_TypeKind_CHAR = 3,
  Type_TypeKind_VOID = 4,
  Type_TypeKind_Type_TypeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Type_TypeKind_Type_TypeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Type_TypeKind_IsValid(int value);
const Type_TypeKind Type_TypeKind_TypeKind_MIN = Type_TypeKind_INTEGER;
const Type_TypeKind Type_TypeKind_TypeKind_MAX = Type_TypeKind_VOID;
const int Type_TypeKind_TypeKind_ARRAYSIZE = Type_TypeKind_TypeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_TypeKind_descriptor();
inline const ::std::string& Type_TypeKind_Name(Type_TypeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_TypeKind_descriptor(), value);
}
inline bool Type_TypeKind_Parse(
    const ::std::string& name, Type_TypeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type_TypeKind>(
    Type_TypeKind_descriptor(), name, value);
}
enum Operator_OpKind {
  Operator_OpKind_Plus = 0,
  Operator_OpKind_Minus = 1,
  Operator_OpKind_Div = 2,
  Operator_OpKind_Sub = 3,
  Operator_OpKind_Mod = 4,
  Operator_OpKind_And = 5,
  Operator_OpKind_Or = 6,
  Operator_OpKind_In = 7,
  Operator_OpKind_Equal = 8,
  Operator_OpKind_Less = 9,
  Operator_OpKind_Great = 10,
  Operator_OpKind_Operator_OpKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Operator_OpKind_Operator_OpKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Operator_OpKind_IsValid(int value);
const Operator_OpKind Operator_OpKind_OpKind_MIN = Operator_OpKind_Plus;
const Operator_OpKind Operator_OpKind_OpKind_MAX = Operator_OpKind_Great;
const int Operator_OpKind_OpKind_ARRAYSIZE = Operator_OpKind_OpKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operator_OpKind_descriptor();
inline const ::std::string& Operator_OpKind_Name(Operator_OpKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operator_OpKind_descriptor(), value);
}
inline bool Operator_OpKind_Parse(
    const ::std::string& name, Operator_OpKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operator_OpKind>(
    Operator_OpKind_descriptor(), name, value);
}
enum TokenKind {
  PROGRAM = 0,
  ASSIGN = 1,
  IDENTIFIER = 2,
  UINTLIT = 3,
  PROCEDURE = 4,
  LESS = 5,
  GREAT = 6,
  IF = 7,
  TokenKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TokenKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TokenKind_IsValid(int value);
const TokenKind TokenKind_MIN = PROGRAM;
const TokenKind TokenKind_MAX = IF;
const int TokenKind_ARRAYSIZE = TokenKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TokenKind_descriptor();
inline const ::std::string& TokenKind_Name(TokenKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TokenKind_descriptor(), value);
}
inline bool TokenKind_Parse(
    const ::std::string& name, TokenKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TokenKind>(
    TokenKind_descriptor(), name, value);
}
// ===================================================================

class Program : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Program) */ {
 public:
  Program();
  virtual ~Program();

  Program(const Program& from);

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Program(Program&& from) noexcept
    : Program() {
    *this = ::std::move(from);
  }

  inline Program& operator=(Program&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Program& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
               &_Program_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Program* other);
  friend void swap(Program& a, Program& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Program* New() const final {
    return CreateMaybeMessage<Program>(NULL);
  }

  Program* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Program>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Program* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string params = 3;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::std::string& params(int index) const;
  ::std::string* mutable_params(int index);
  void set_params(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_params(int index, ::std::string&& value);
  #endif
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, size_t size);
  ::std::string* add_params();
  void add_params(const ::std::string& value);
  #if LANG_CXX11
  void add_params(::std::string&& value);
  #endif
  void add_params(const char* value);
  void add_params(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Pasc.Block block = 4;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 4;
  private:
  const ::Pasc::Block& _internal_block() const;
  public:
  const ::Pasc::Block& block() const;
  ::Pasc::Block* release_block();
  ::Pasc::Block* mutable_block();
  void set_allocated_block(::Pasc::Block* block);

  // .Pasc.TokenKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::TokenKind kind() const;
  void set_kind(::Pasc::TokenKind value);

  // @@protoc_insertion_point(class_scope:Pasc.Program)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Pasc::Block* block_;
  int kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(NULL);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.VarDeclaration varDecl = 1;
  int vardecl_size() const;
  void clear_vardecl();
  static const int kVarDeclFieldNumber = 1;
  ::Pasc::VarDeclaration* mutable_vardecl(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >*
      mutable_vardecl();
  const ::Pasc::VarDeclaration& vardecl(int index) const;
  ::Pasc::VarDeclaration* add_vardecl();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >&
      vardecl() const;

  // repeated .Pasc.Statement stmts = 2;
  int stmts_size() const;
  void clear_stmts();
  static const int kStmtsFieldNumber = 2;
  ::Pasc::Statement* mutable_stmts(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
      mutable_stmts();
  const ::Pasc::Statement& stmts(int index) const;
  ::Pasc::Statement* add_stmts();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
      stmts() const;

  // repeated .Pasc.Callable callables = 3;
  int callables_size() const;
  void clear_callables();
  static const int kCallablesFieldNumber = 3;
  ::Pasc::Callable* mutable_callables(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Callable >*
      mutable_callables();
  const ::Pasc::Callable& callables(int index) const;
  ::Pasc::Callable* add_callables();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Callable >&
      callables() const;

  // @@protoc_insertion_point(class_scope:Pasc.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration > vardecl_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement > stmts_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Callable > callables_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Callable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Callable) */ {
 public:
  Callable();
  virtual ~Callable();

  Callable(const Callable& from);

  inline Callable& operator=(const Callable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Callable(Callable&& from) noexcept
    : Callable() {
    *this = ::std::move(from);
  }

  inline Callable& operator=(Callable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Callable& default_instance();

  enum CallCase {
    kFuncDecl = 2,
    kProcDecl = 3,
    CALL_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Callable* internal_default_instance() {
    return reinterpret_cast<const Callable*>(
               &_Callable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Callable* other);
  friend void swap(Callable& a, Callable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Callable* New() const final {
    return CreateMaybeMessage<Callable>(NULL);
  }

  Callable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Callable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Callable& from);
  void MergeFrom(const Callable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Callable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Callable_CallKind CallKind;
  static const CallKind Func =
    Callable_CallKind_Func;
  static const CallKind Proc =
    Callable_CallKind_Proc;
  static inline bool CallKind_IsValid(int value) {
    return Callable_CallKind_IsValid(value);
  }
  static const CallKind CallKind_MIN =
    Callable_CallKind_CallKind_MIN;
  static const CallKind CallKind_MAX =
    Callable_CallKind_CallKind_MAX;
  static const int CallKind_ARRAYSIZE =
    Callable_CallKind_CallKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CallKind_descriptor() {
    return Callable_CallKind_descriptor();
  }
  static inline const ::std::string& CallKind_Name(CallKind value) {
    return Callable_CallKind_Name(value);
  }
  static inline bool CallKind_Parse(const ::std::string& name,
      CallKind* value) {
    return Callable_CallKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Callable.CallKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Callable_CallKind kind() const;
  void set_kind(::Pasc::Callable_CallKind value);

  // .Pasc.FuncDeclaration funcDecl = 2;
  bool has_funcdecl() const;
  void clear_funcdecl();
  static const int kFuncDeclFieldNumber = 2;
  private:
  const ::Pasc::FuncDeclaration& _internal_funcdecl() const;
  public:
  const ::Pasc::FuncDeclaration& funcdecl() const;
  ::Pasc::FuncDeclaration* release_funcdecl();
  ::Pasc::FuncDeclaration* mutable_funcdecl();
  void set_allocated_funcdecl(::Pasc::FuncDeclaration* funcdecl);

  // .Pasc.ProcDeclaration procDecl = 3;
  bool has_procdecl() const;
  void clear_procdecl();
  static const int kProcDeclFieldNumber = 3;
  private:
  const ::Pasc::ProcDeclaration& _internal_procdecl() const;
  public:
  const ::Pasc::ProcDeclaration& procdecl() const;
  ::Pasc::ProcDeclaration* release_procdecl();
  ::Pasc::ProcDeclaration* mutable_procdecl();
  void set_allocated_procdecl(::Pasc::ProcDeclaration* procdecl);

  void clear_call();
  CallCase call_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Callable)
 private:
  void set_has_funcdecl();
  void set_has_procdecl();

  inline bool has_call() const;
  inline void clear_has_call();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union CallUnion {
    CallUnion() {}
    ::Pasc::FuncDeclaration* funcdecl_;
    ::Pasc::ProcDeclaration* procdecl_;
  } call_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FormalParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.FormalParameter) */ {
 public:
  FormalParameter();
  virtual ~FormalParameter();

  FormalParameter(const FormalParameter& from);

  inline FormalParameter& operator=(const FormalParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FormalParameter(FormalParameter&& from) noexcept
    : FormalParameter() {
    *this = ::std::move(from);
  }

  inline FormalParameter& operator=(FormalParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FormalParameter& default_instance();

  enum FpCase {
    kFHead = 2,
    kPHead = 3,
    kVParam = 4,
    kValParam = 5,
    FP_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FormalParameter* internal_default_instance() {
    return reinterpret_cast<const FormalParameter*>(
               &_FormalParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FormalParameter* other);
  friend void swap(FormalParameter& a, FormalParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FormalParameter* New() const final {
    return CreateMaybeMessage<FormalParameter>(NULL);
  }

  FormalParameter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FormalParameter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FormalParameter& from);
  void MergeFrom(const FormalParameter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormalParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FormalParameter_FPKind FPKind;
  static const FPKind FuncHead =
    FormalParameter_FPKind_FuncHead;
  static const FPKind ProcHead =
    FormalParameter_FPKind_ProcHead;
  static const FPKind VarParam =
    FormalParameter_FPKind_VarParam;
  static const FPKind ValueParam =
    FormalParameter_FPKind_ValueParam;
  static inline bool FPKind_IsValid(int value) {
    return FormalParameter_FPKind_IsValid(value);
  }
  static const FPKind FPKind_MIN =
    FormalParameter_FPKind_FPKind_MIN;
  static const FPKind FPKind_MAX =
    FormalParameter_FPKind_FPKind_MAX;
  static const int FPKind_ARRAYSIZE =
    FormalParameter_FPKind_FPKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FPKind_descriptor() {
    return FormalParameter_FPKind_descriptor();
  }
  static inline const ::std::string& FPKind_Name(FPKind value) {
    return FormalParameter_FPKind_Name(value);
  }
  static inline bool FPKind_Parse(const ::std::string& name,
      FPKind* value) {
    return FormalParameter_FPKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.FormalParameter.FPKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::FormalParameter_FPKind kind() const;
  void set_kind(::Pasc::FormalParameter_FPKind value);

  // .Pasc.FuncHeading fHead = 2;
  bool has_fhead() const;
  void clear_fhead();
  static const int kFHeadFieldNumber = 2;
  private:
  const ::Pasc::FuncHeading& _internal_fhead() const;
  public:
  const ::Pasc::FuncHeading& fhead() const;
  ::Pasc::FuncHeading* release_fhead();
  ::Pasc::FuncHeading* mutable_fhead();
  void set_allocated_fhead(::Pasc::FuncHeading* fhead);

  // .Pasc.ProcHeading pHead = 3;
  bool has_phead() const;
  void clear_phead();
  static const int kPHeadFieldNumber = 3;
  private:
  const ::Pasc::ProcHeading& _internal_phead() const;
  public:
  const ::Pasc::ProcHeading& phead() const;
  ::Pasc::ProcHeading* release_phead();
  ::Pasc::ProcHeading* mutable_phead();
  void set_allocated_phead(::Pasc::ProcHeading* phead);

  // .Pasc.VariableParam vParam = 4;
  bool has_vparam() const;
  void clear_vparam();
  static const int kVParamFieldNumber = 4;
  private:
  const ::Pasc::VariableParam& _internal_vparam() const;
  public:
  const ::Pasc::VariableParam& vparam() const;
  ::Pasc::VariableParam* release_vparam();
  ::Pasc::VariableParam* mutable_vparam();
  void set_allocated_vparam(::Pasc::VariableParam* vparam);

  // .Pasc.ValueParam valParam = 5;
  bool has_valparam() const;
  void clear_valparam();
  static const int kValParamFieldNumber = 5;
  private:
  const ::Pasc::ValueParam& _internal_valparam() const;
  public:
  const ::Pasc::ValueParam& valparam() const;
  ::Pasc::ValueParam* release_valparam();
  ::Pasc::ValueParam* mutable_valparam();
  void set_allocated_valparam(::Pasc::ValueParam* valparam);

  void clear_fp();
  FpCase fp_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.FormalParameter)
 private:
  void set_has_fhead();
  void set_has_phead();
  void set_has_vparam();
  void set_has_valparam();

  inline bool has_fp() const;
  inline void clear_has_fp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union FpUnion {
    FpUnion() {}
    ::Pasc::FuncHeading* fhead_;
    ::Pasc::ProcHeading* phead_;
    ::Pasc::VariableParam* vparam_;
    ::Pasc::ValueParam* valparam_;
  } fp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VariableParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.VariableParam) */ {
 public:
  VariableParam();
  virtual ~VariableParam();

  VariableParam(const VariableParam& from);

  inline VariableParam& operator=(const VariableParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VariableParam(VariableParam&& from) noexcept
    : VariableParam() {
    *this = ::std::move(from);
  }

  inline VariableParam& operator=(VariableParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VariableParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VariableParam* internal_default_instance() {
    return reinterpret_cast<const VariableParam*>(
               &_VariableParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(VariableParam* other);
  friend void swap(VariableParam& a, VariableParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VariableParam* New() const final {
    return CreateMaybeMessage<VariableParam>(NULL);
  }

  VariableParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VariableParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VariableParam& from);
  void MergeFrom(const VariableParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VariableParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // .Pasc.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::Pasc::Type& _internal_type() const;
  public:
  const ::Pasc::Type& type() const;
  ::Pasc::Type* release_type();
  ::Pasc::Type* mutable_type();
  void set_allocated_type(::Pasc::Type* type);

  // @@protoc_insertion_point(class_scope:Pasc.VariableParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::Pasc::Type* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValueParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ValueParam) */ {
 public:
  ValueParam();
  virtual ~ValueParam();

  ValueParam(const ValueParam& from);

  inline ValueParam& operator=(const ValueParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ValueParam(ValueParam&& from) noexcept
    : ValueParam() {
    *this = ::std::move(from);
  }

  inline ValueParam& operator=(ValueParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValueParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValueParam* internal_default_instance() {
    return reinterpret_cast<const ValueParam*>(
               &_ValueParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ValueParam* other);
  friend void swap(ValueParam& a, ValueParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ValueParam* New() const final {
    return CreateMaybeMessage<ValueParam>(NULL);
  }

  ValueParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ValueParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ValueParam& from);
  void MergeFrom(const ValueParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 1;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // .Pasc.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::Pasc::Type& _internal_type() const;
  public:
  const ::Pasc::Type& type() const;
  ::Pasc::Type* release_type();
  ::Pasc::Type* mutable_type();
  void set_allocated_type(::Pasc::Type* type);

  // @@protoc_insertion_point(class_scope:Pasc.ValueParam)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::Pasc::Type* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FuncHeading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.FuncHeading) */ {
 public:
  FuncHeading();
  virtual ~FuncHeading();

  FuncHeading(const FuncHeading& from);

  inline FuncHeading& operator=(const FuncHeading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FuncHeading(FuncHeading&& from) noexcept
    : FuncHeading() {
    *this = ::std::move(from);
  }

  inline FuncHeading& operator=(FuncHeading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FuncHeading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FuncHeading* internal_default_instance() {
    return reinterpret_cast<const FuncHeading*>(
               &_FuncHeading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FuncHeading* other);
  friend void swap(FuncHeading& a, FuncHeading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FuncHeading* New() const final {
    return CreateMaybeMessage<FuncHeading>(NULL);
  }

  FuncHeading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FuncHeading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FuncHeading& from);
  void MergeFrom(const FuncHeading& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FuncHeading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.FormalParameter params = 2;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  ::Pasc::FormalParameter* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >*
      mutable_params();
  const ::Pasc::FormalParameter& params(int index) const;
  ::Pasc::FormalParameter* add_params();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >&
      params() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Pasc.Type returnType = 3;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 3;
  private:
  const ::Pasc::Type& _internal_returntype() const;
  public:
  const ::Pasc::Type& returntype() const;
  ::Pasc::Type* release_returntype();
  ::Pasc::Type* mutable_returntype();
  void set_allocated_returntype(::Pasc::Type* returntype);

  // @@protoc_insertion_point(class_scope:Pasc.FuncHeading)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter > params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Pasc::Type* returntype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcHeading : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcHeading) */ {
 public:
  ProcHeading();
  virtual ~ProcHeading();

  ProcHeading(const ProcHeading& from);

  inline ProcHeading& operator=(const ProcHeading& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcHeading(ProcHeading&& from) noexcept
    : ProcHeading() {
    *this = ::std::move(from);
  }

  inline ProcHeading& operator=(ProcHeading&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcHeading& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcHeading* internal_default_instance() {
    return reinterpret_cast<const ProcHeading*>(
               &_ProcHeading_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ProcHeading* other);
  friend void swap(ProcHeading& a, ProcHeading& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcHeading* New() const final {
    return CreateMaybeMessage<ProcHeading>(NULL);
  }

  ProcHeading* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcHeading>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcHeading& from);
  void MergeFrom(const ProcHeading& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcHeading* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.FormalParameter params = 2;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  ::Pasc::FormalParameter* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >*
      mutable_params();
  const ::Pasc::FormalParameter& params(int index) const;
  ::Pasc::FormalParameter* add_params();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >&
      params() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Pasc.Type returnType = 3;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 3;
  private:
  const ::Pasc::Type& _internal_returntype() const;
  public:
  const ::Pasc::Type& returntype() const;
  ::Pasc::Type* release_returntype();
  ::Pasc::Type* mutable_returntype();
  void set_allocated_returntype(::Pasc::Type* returntype);

  // @@protoc_insertion_point(class_scope:Pasc.ProcHeading)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter > params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Pasc::Type* returntype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FuncDeclaration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.FuncDeclaration) */ {
 public:
  FuncDeclaration();
  virtual ~FuncDeclaration();

  FuncDeclaration(const FuncDeclaration& from);

  inline FuncDeclaration& operator=(const FuncDeclaration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FuncDeclaration(FuncDeclaration&& from) noexcept
    : FuncDeclaration() {
    *this = ::std::move(from);
  }

  inline FuncDeclaration& operator=(FuncDeclaration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FuncDeclaration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FuncDeclaration* internal_default_instance() {
    return reinterpret_cast<const FuncDeclaration*>(
               &_FuncDeclaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(FuncDeclaration* other);
  friend void swap(FuncDeclaration& a, FuncDeclaration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FuncDeclaration* New() const final {
    return CreateMaybeMessage<FuncDeclaration>(NULL);
  }

  FuncDeclaration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FuncDeclaration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FuncDeclaration& from);
  void MergeFrom(const FuncDeclaration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FuncDeclaration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dir = 3;
  void clear_dir();
  static const int kDirFieldNumber = 3;
  const ::std::string& dir() const;
  void set_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_dir(::std::string&& value);
  #endif
  void set_dir(const char* value);
  void set_dir(const char* value, size_t size);
  ::std::string* mutable_dir();
  ::std::string* release_dir();
  void set_allocated_dir(::std::string* dir);

  // .Pasc.FuncHeading funcHeading = 1;
  bool has_funcheading() const;
  void clear_funcheading();
  static const int kFuncHeadingFieldNumber = 1;
  private:
  const ::Pasc::FuncHeading& _internal_funcheading() const;
  public:
  const ::Pasc::FuncHeading& funcheading() const;
  ::Pasc::FuncHeading* release_funcheading();
  ::Pasc::FuncHeading* mutable_funcheading();
  void set_allocated_funcheading(::Pasc::FuncHeading* funcheading);

  // .Pasc.Block blk = 2;
  bool has_blk() const;
  void clear_blk();
  static const int kBlkFieldNumber = 2;
  private:
  const ::Pasc::Block& _internal_blk() const;
  public:
  const ::Pasc::Block& blk() const;
  ::Pasc::Block* release_blk();
  ::Pasc::Block* mutable_blk();
  void set_allocated_blk(::Pasc::Block* blk);

  // @@protoc_insertion_point(class_scope:Pasc.FuncDeclaration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dir_;
  ::Pasc::FuncHeading* funcheading_;
  ::Pasc::Block* blk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcDeclaration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcDeclaration) */ {
 public:
  ProcDeclaration();
  virtual ~ProcDeclaration();

  ProcDeclaration(const ProcDeclaration& from);

  inline ProcDeclaration& operator=(const ProcDeclaration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcDeclaration(ProcDeclaration&& from) noexcept
    : ProcDeclaration() {
    *this = ::std::move(from);
  }

  inline ProcDeclaration& operator=(ProcDeclaration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcDeclaration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcDeclaration* internal_default_instance() {
    return reinterpret_cast<const ProcDeclaration*>(
               &_ProcDeclaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ProcDeclaration* other);
  friend void swap(ProcDeclaration& a, ProcDeclaration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcDeclaration* New() const final {
    return CreateMaybeMessage<ProcDeclaration>(NULL);
  }

  ProcDeclaration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcDeclaration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcDeclaration& from);
  void MergeFrom(const ProcDeclaration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcDeclaration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string dir = 3;
  void clear_dir();
  static const int kDirFieldNumber = 3;
  const ::std::string& dir() const;
  void set_dir(const ::std::string& value);
  #if LANG_CXX11
  void set_dir(::std::string&& value);
  #endif
  void set_dir(const char* value);
  void set_dir(const char* value, size_t size);
  ::std::string* mutable_dir();
  ::std::string* release_dir();
  void set_allocated_dir(::std::string* dir);

  // .Pasc.ProcHeading procHead = 1;
  bool has_prochead() const;
  void clear_prochead();
  static const int kProcHeadFieldNumber = 1;
  private:
  const ::Pasc::ProcHeading& _internal_prochead() const;
  public:
  const ::Pasc::ProcHeading& prochead() const;
  ::Pasc::ProcHeading* release_prochead();
  ::Pasc::ProcHeading* mutable_prochead();
  void set_allocated_prochead(::Pasc::ProcHeading* prochead);

  // .Pasc.Block blk = 2;
  bool has_blk() const;
  void clear_blk();
  static const int kBlkFieldNumber = 2;
  private:
  const ::Pasc::Block& _internal_blk() const;
  public:
  const ::Pasc::Block& blk() const;
  ::Pasc::Block* release_blk();
  ::Pasc::Block* mutable_blk();
  void set_allocated_blk(::Pasc::Block* blk);

  // @@protoc_insertion_point(class_scope:Pasc.ProcDeclaration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr dir_;
  ::Pasc::ProcHeading* prochead_;
  ::Pasc::Block* blk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarDeclaration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.VarDeclaration) */ {
 public:
  VarDeclaration();
  virtual ~VarDeclaration();

  VarDeclaration(const VarDeclaration& from);

  inline VarDeclaration& operator=(const VarDeclaration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarDeclaration(VarDeclaration&& from) noexcept
    : VarDeclaration() {
    *this = ::std::move(from);
  }

  inline VarDeclaration& operator=(VarDeclaration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarDeclaration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarDeclaration* internal_default_instance() {
    return reinterpret_cast<const VarDeclaration*>(
               &_VarDeclaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(VarDeclaration* other);
  friend void swap(VarDeclaration& a, VarDeclaration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarDeclaration* New() const final {
    return CreateMaybeMessage<VarDeclaration>(NULL);
  }

  VarDeclaration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarDeclaration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarDeclaration& from);
  void MergeFrom(const VarDeclaration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarDeclaration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_name() const;
  public:
  const ::Pasc::Expression& name() const;
  ::Pasc::Expression* release_name();
  ::Pasc::Expression* mutable_name();
  void set_allocated_name(::Pasc::Expression* name);

  // .Pasc.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::Pasc::Type& _internal_type() const;
  public:
  const ::Pasc::Type& type() const;
  ::Pasc::Type* release_type();
  ::Pasc::Type* mutable_type();
  void set_allocated_type(::Pasc::Type* type);

  // @@protoc_insertion_point(class_scope:Pasc.VarDeclaration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* name_;
  ::Pasc::Type* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_WriteLn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.WriteLn) */ {
 public:
  ProcedureStatement_WriteLn();
  virtual ~ProcedureStatement_WriteLn();

  ProcedureStatement_WriteLn(const ProcedureStatement_WriteLn& from);

  inline ProcedureStatement_WriteLn& operator=(const ProcedureStatement_WriteLn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_WriteLn(ProcedureStatement_WriteLn&& from) noexcept
    : ProcedureStatement_WriteLn() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_WriteLn& operator=(ProcedureStatement_WriteLn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_WriteLn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_WriteLn* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_WriteLn*>(
               &_ProcedureStatement_WriteLn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ProcedureStatement_WriteLn* other);
  friend void swap(ProcedureStatement_WriteLn& a, ProcedureStatement_WriteLn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_WriteLn* New() const final {
    return CreateMaybeMessage<ProcedureStatement_WriteLn>(NULL);
  }

  ProcedureStatement_WriteLn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_WriteLn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_WriteLn& from);
  void MergeFrom(const ProcedureStatement_WriteLn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_WriteLn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression params = 3;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  ::Pasc::Expression* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_params();
  const ::Pasc::Expression& params(int index) const;
  ::Pasc::Expression* add_params();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      params() const;

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Pasc.Expression file = 2;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_file() const;
  public:
  const ::Pasc::Expression& file() const;
  ::Pasc::Expression* release_file();
  ::Pasc::Expression* mutable_file();
  void set_allocated_file(::Pasc::Expression* file);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.WriteLn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Pasc::Expression* file_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_Write : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.Write) */ {
 public:
  ProcedureStatement_Write();
  virtual ~ProcedureStatement_Write();

  ProcedureStatement_Write(const ProcedureStatement_Write& from);

  inline ProcedureStatement_Write& operator=(const ProcedureStatement_Write& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_Write(ProcedureStatement_Write&& from) noexcept
    : ProcedureStatement_Write() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_Write& operator=(ProcedureStatement_Write&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_Write& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_Write* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_Write*>(
               &_ProcedureStatement_Write_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ProcedureStatement_Write* other);
  friend void swap(ProcedureStatement_Write& a, ProcedureStatement_Write& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_Write* New() const final {
    return CreateMaybeMessage<ProcedureStatement_Write>(NULL);
  }

  ProcedureStatement_Write* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_Write>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_Write& from);
  void MergeFrom(const ProcedureStatement_Write& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_Write* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.Write)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_Read : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.Read) */ {
 public:
  ProcedureStatement_Read();
  virtual ~ProcedureStatement_Read();

  ProcedureStatement_Read(const ProcedureStatement_Read& from);

  inline ProcedureStatement_Read& operator=(const ProcedureStatement_Read& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_Read(ProcedureStatement_Read&& from) noexcept
    : ProcedureStatement_Read() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_Read& operator=(ProcedureStatement_Read&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_Read& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_Read* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_Read*>(
               &_ProcedureStatement_Read_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ProcedureStatement_Read* other);
  friend void swap(ProcedureStatement_Read& a, ProcedureStatement_Read& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_Read* New() const final {
    return CreateMaybeMessage<ProcedureStatement_Read>(NULL);
  }

  ProcedureStatement_Read* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_Read>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_Read& from);
  void MergeFrom(const ProcedureStatement_Read& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_Read* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.Read)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_ReadLn : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.ReadLn) */ {
 public:
  ProcedureStatement_ReadLn();
  virtual ~ProcedureStatement_ReadLn();

  ProcedureStatement_ReadLn(const ProcedureStatement_ReadLn& from);

  inline ProcedureStatement_ReadLn& operator=(const ProcedureStatement_ReadLn& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_ReadLn(ProcedureStatement_ReadLn&& from) noexcept
    : ProcedureStatement_ReadLn() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_ReadLn& operator=(ProcedureStatement_ReadLn&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_ReadLn& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_ReadLn* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_ReadLn*>(
               &_ProcedureStatement_ReadLn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ProcedureStatement_ReadLn* other);
  friend void swap(ProcedureStatement_ReadLn& a, ProcedureStatement_ReadLn& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_ReadLn* New() const final {
    return CreateMaybeMessage<ProcedureStatement_ReadLn>(NULL);
  }

  ProcedureStatement_ReadLn* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_ReadLn>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_ReadLn& from);
  void MergeFrom(const ProcedureStatement_ReadLn& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_ReadLn* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.ReadLn)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement_ProcStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement.ProcStmt) */ {
 public:
  ProcedureStatement_ProcStmt();
  virtual ~ProcedureStatement_ProcStmt();

  ProcedureStatement_ProcStmt(const ProcedureStatement_ProcStmt& from);

  inline ProcedureStatement_ProcStmt& operator=(const ProcedureStatement_ProcStmt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement_ProcStmt(ProcedureStatement_ProcStmt&& from) noexcept
    : ProcedureStatement_ProcStmt() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement_ProcStmt& operator=(ProcedureStatement_ProcStmt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement_ProcStmt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement_ProcStmt* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement_ProcStmt*>(
               &_ProcedureStatement_ProcStmt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ProcedureStatement_ProcStmt* other);
  friend void swap(ProcedureStatement_ProcStmt& a, ProcedureStatement_ProcStmt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement_ProcStmt* New() const final {
    return CreateMaybeMessage<ProcedureStatement_ProcStmt>(NULL);
  }

  ProcedureStatement_ProcStmt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement_ProcStmt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement_ProcStmt& from);
  void MergeFrom(const ProcedureStatement_ProcStmt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement_ProcStmt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression params = 2;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  ::Pasc::Expression* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_params();
  const ::Pasc::Expression& params(int index) const;
  ::Pasc::Expression* add_params();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      params() const;

  // .Pasc.Expression name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_name() const;
  public:
  const ::Pasc::Expression& name() const;
  ::Pasc::Expression* release_name();
  ::Pasc::Expression* mutable_name();
  void set_allocated_name(::Pasc::Expression* name);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement.ProcStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > params_;
  ::Pasc::Expression* name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStatement) */ {
 public:
  ProcedureStatement();
  virtual ~ProcedureStatement();

  ProcedureStatement(const ProcedureStatement& from);

  inline ProcedureStatement& operator=(const ProcedureStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStatement(ProcedureStatement&& from) noexcept
    : ProcedureStatement() {
    *this = ::std::move(from);
  }

  inline ProcedureStatement& operator=(ProcedureStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatement& default_instance();

  enum StmtCase {
    kWrt = 2,
    kWrtLn = 3,
    kRd = 4,
    kRdLn = 5,
    kPs = 6,
    STMT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStatement* internal_default_instance() {
    return reinterpret_cast<const ProcedureStatement*>(
               &_ProcedureStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ProcedureStatement* other);
  friend void swap(ProcedureStatement& a, ProcedureStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStatement* New() const final {
    return CreateMaybeMessage<ProcedureStatement>(NULL);
  }

  ProcedureStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStatement& from);
  void MergeFrom(const ProcedureStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ProcedureStatement_WriteLn WriteLn;
  typedef ProcedureStatement_Write Write;
  typedef ProcedureStatement_Read Read;
  typedef ProcedureStatement_ReadLn ReadLn;
  typedef ProcedureStatement_ProcStmt ProcStmt;

  typedef ProcedureStatement_PSKind PSKind;
  static const PSKind wln =
    ProcedureStatement_PSKind_wln;
  static const PSKind write =
    ProcedureStatement_PSKind_write;
  static const PSKind read =
    ProcedureStatement_PSKind_read;
  static const PSKind readLn =
    ProcedureStatement_PSKind_readLn;
  static const PSKind procStmt =
    ProcedureStatement_PSKind_procStmt;
  static inline bool PSKind_IsValid(int value) {
    return ProcedureStatement_PSKind_IsValid(value);
  }
  static const PSKind PSKind_MIN =
    ProcedureStatement_PSKind_PSKind_MIN;
  static const PSKind PSKind_MAX =
    ProcedureStatement_PSKind_PSKind_MAX;
  static const int PSKind_ARRAYSIZE =
    ProcedureStatement_PSKind_PSKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PSKind_descriptor() {
    return ProcedureStatement_PSKind_descriptor();
  }
  static inline const ::std::string& PSKind_Name(PSKind value) {
    return ProcedureStatement_PSKind_Name(value);
  }
  static inline bool PSKind_Parse(const ::std::string& name,
      PSKind* value) {
    return ProcedureStatement_PSKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.ProcedureStatement.PSKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::ProcedureStatement_PSKind kind() const;
  void set_kind(::Pasc::ProcedureStatement_PSKind value);

  // .Pasc.ProcedureStatement.Write wrt = 2;
  bool has_wrt() const;
  void clear_wrt();
  static const int kWrtFieldNumber = 2;
  private:
  const ::Pasc::ProcedureStatement_Write& _internal_wrt() const;
  public:
  const ::Pasc::ProcedureStatement_Write& wrt() const;
  ::Pasc::ProcedureStatement_Write* release_wrt();
  ::Pasc::ProcedureStatement_Write* mutable_wrt();
  void set_allocated_wrt(::Pasc::ProcedureStatement_Write* wrt);

  // .Pasc.ProcedureStatement.WriteLn wrtLn = 3;
  bool has_wrtln() const;
  void clear_wrtln();
  static const int kWrtLnFieldNumber = 3;
  private:
  const ::Pasc::ProcedureStatement_WriteLn& _internal_wrtln() const;
  public:
  const ::Pasc::ProcedureStatement_WriteLn& wrtln() const;
  ::Pasc::ProcedureStatement_WriteLn* release_wrtln();
  ::Pasc::ProcedureStatement_WriteLn* mutable_wrtln();
  void set_allocated_wrtln(::Pasc::ProcedureStatement_WriteLn* wrtln);

  // .Pasc.ProcedureStatement.Read rd = 4;
  bool has_rd() const;
  void clear_rd();
  static const int kRdFieldNumber = 4;
  private:
  const ::Pasc::ProcedureStatement_Read& _internal_rd() const;
  public:
  const ::Pasc::ProcedureStatement_Read& rd() const;
  ::Pasc::ProcedureStatement_Read* release_rd();
  ::Pasc::ProcedureStatement_Read* mutable_rd();
  void set_allocated_rd(::Pasc::ProcedureStatement_Read* rd);

  // .Pasc.ProcedureStatement.ReadLn rdLn = 5;
  bool has_rdln() const;
  void clear_rdln();
  static const int kRdLnFieldNumber = 5;
  private:
  const ::Pasc::ProcedureStatement_ReadLn& _internal_rdln() const;
  public:
  const ::Pasc::ProcedureStatement_ReadLn& rdln() const;
  ::Pasc::ProcedureStatement_ReadLn* release_rdln();
  ::Pasc::ProcedureStatement_ReadLn* mutable_rdln();
  void set_allocated_rdln(::Pasc::ProcedureStatement_ReadLn* rdln);

  // .Pasc.ProcedureStatement.ProcStmt ps = 6;
  bool has_ps() const;
  void clear_ps();
  static const int kPsFieldNumber = 6;
  private:
  const ::Pasc::ProcedureStatement_ProcStmt& _internal_ps() const;
  public:
  const ::Pasc::ProcedureStatement_ProcStmt& ps() const;
  ::Pasc::ProcedureStatement_ProcStmt* release_ps();
  ::Pasc::ProcedureStatement_ProcStmt* mutable_ps();
  void set_allocated_ps(::Pasc::ProcedureStatement_ProcStmt* ps);

  void clear_stmt();
  StmtCase stmt_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStatement)
 private:
  void set_has_wrt();
  void set_has_wrtln();
  void set_has_rd();
  void set_has_rdln();
  void set_has_ps();

  inline bool has_stmt() const;
  inline void clear_has_stmt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union StmtUnion {
    StmtUnion() {}
    ::Pasc::ProcedureStatement_Write* wrt_;
    ::Pasc::ProcedureStatement_WriteLn* wrtln_;
    ::Pasc::ProcedureStatement_Read* rd_;
    ::Pasc::ProcedureStatement_ReadLn* rdln_;
    ::Pasc::ProcedureStatement_ProcStmt* ps_;
  } stmt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssignStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.AssignStatement) */ {
 public:
  AssignStatement();
  virtual ~AssignStatement();

  AssignStatement(const AssignStatement& from);

  inline AssignStatement& operator=(const AssignStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssignStatement(AssignStatement&& from) noexcept
    : AssignStatement() {
    *this = ::std::move(from);
  }

  inline AssignStatement& operator=(AssignStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssignStatement* internal_default_instance() {
    return reinterpret_cast<const AssignStatement*>(
               &_AssignStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(AssignStatement* other);
  friend void swap(AssignStatement& a, AssignStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssignStatement* New() const final {
    return CreateMaybeMessage<AssignStatement>(NULL);
  }

  AssignStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssignStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssignStatement& from);
  void MergeFrom(const AssignStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression variable = 1;
  bool has_variable() const;
  void clear_variable();
  static const int kVariableFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_variable() const;
  public:
  const ::Pasc::Expression& variable() const;
  ::Pasc::Expression* release_variable();
  ::Pasc::Expression* mutable_variable();
  void set_allocated_variable(::Pasc::Expression* variable);

  // .Pasc.Expression value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_value() const;
  public:
  const ::Pasc::Expression& value() const;
  ::Pasc::Expression* release_value();
  ::Pasc::Expression* mutable_value();
  void set_allocated_value(::Pasc::Expression* value);

  // @@protoc_insertion_point(class_scope:Pasc.AssignStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* variable_;
  ::Pasc::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IfStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.IfStatement) */ {
 public:
  IfStatement();
  virtual ~IfStatement();

  IfStatement(const IfStatement& from);

  inline IfStatement& operator=(const IfStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IfStatement(IfStatement&& from) noexcept
    : IfStatement() {
    *this = ::std::move(from);
  }

  inline IfStatement& operator=(IfStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const IfStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfStatement* internal_default_instance() {
    return reinterpret_cast<const IfStatement*>(
               &_IfStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(IfStatement* other);
  friend void swap(IfStatement& a, IfStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IfStatement* New() const final {
    return CreateMaybeMessage<IfStatement>(NULL);
  }

  IfStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IfStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IfStatement& from);
  void MergeFrom(const IfStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression cond = 1;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_cond() const;
  public:
  const ::Pasc::Expression& cond() const;
  ::Pasc::Expression* release_cond();
  ::Pasc::Expression* mutable_cond();
  void set_allocated_cond(::Pasc::Expression* cond);

  // .Pasc.Statement truePath = 2;
  bool has_truepath() const;
  void clear_truepath();
  static const int kTruePathFieldNumber = 2;
  private:
  const ::Pasc::Statement& _internal_truepath() const;
  public:
  const ::Pasc::Statement& truepath() const;
  ::Pasc::Statement* release_truepath();
  ::Pasc::Statement* mutable_truepath();
  void set_allocated_truepath(::Pasc::Statement* truepath);

  // .Pasc.Statement elsePath = 3;
  bool has_elsepath() const;
  void clear_elsepath();
  static const int kElsePathFieldNumber = 3;
  private:
  const ::Pasc::Statement& _internal_elsepath() const;
  public:
  const ::Pasc::Statement& elsepath() const;
  ::Pasc::Statement* release_elsepath();
  ::Pasc::Statement* mutable_elsepath();
  void set_allocated_elsepath(::Pasc::Statement* elsepath);

  // @@protoc_insertion_point(class_scope:Pasc.IfStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* cond_;
  ::Pasc::Statement* truepath_;
  ::Pasc::Statement* elsepath_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReturnStatement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ReturnStatement) */ {
 public:
  ReturnStatement();
  virtual ~ReturnStatement();

  ReturnStatement(const ReturnStatement& from);

  inline ReturnStatement& operator=(const ReturnStatement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReturnStatement(ReturnStatement&& from) noexcept
    : ReturnStatement() {
    *this = ::std::move(from);
  }

  inline ReturnStatement& operator=(ReturnStatement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReturnStatement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReturnStatement* internal_default_instance() {
    return reinterpret_cast<const ReturnStatement*>(
               &_ReturnStatement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ReturnStatement* other);
  friend void swap(ReturnStatement& a, ReturnStatement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReturnStatement* New() const final {
    return CreateMaybeMessage<ReturnStatement>(NULL);
  }

  ReturnStatement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReturnStatement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReturnStatement& from);
  void MergeFrom(const ReturnStatement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReturnStatement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_value() const;
  public:
  const ::Pasc::Expression& value() const;
  ::Pasc::Expression* release_value();
  ::Pasc::Expression* mutable_value();
  void set_allocated_value(::Pasc::Expression* value);

  // @@protoc_insertion_point(class_scope:Pasc.ReturnStatement)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Statement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Statement) */ {
 public:
  Statement();
  virtual ~Statement();

  Statement(const Statement& from);

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(Statement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Statement& default_instance();

  enum StmtCase {
    kAssignStmt = 2,
    kProcStmt = 3,
    kIfStmt = 4,
    kRetStmt = 5,
    STMT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Statement* other);
  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Statement* New() const final {
    return CreateMaybeMessage<Statement>(NULL);
  }

  Statement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Statement_StmtKind StmtKind;
  static const StmtKind if_ =
    Statement_StmtKind_if_;
  static const StmtKind assign =
    Statement_StmtKind_assign;
  static const StmtKind procedure =
    Statement_StmtKind_procedure;
  static const StmtKind return_ =
    Statement_StmtKind_return_;
  static inline bool StmtKind_IsValid(int value) {
    return Statement_StmtKind_IsValid(value);
  }
  static const StmtKind StmtKind_MIN =
    Statement_StmtKind_StmtKind_MIN;
  static const StmtKind StmtKind_MAX =
    Statement_StmtKind_StmtKind_MAX;
  static const int StmtKind_ARRAYSIZE =
    Statement_StmtKind_StmtKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StmtKind_descriptor() {
    return Statement_StmtKind_descriptor();
  }
  static inline const ::std::string& StmtKind_Name(StmtKind value) {
    return Statement_StmtKind_Name(value);
  }
  static inline bool StmtKind_Parse(const ::std::string& name,
      StmtKind* value) {
    return Statement_StmtKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Statement.StmtKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Statement_StmtKind kind() const;
  void set_kind(::Pasc::Statement_StmtKind value);

  // .Pasc.AssignStatement assignStmt = 2;
  bool has_assignstmt() const;
  void clear_assignstmt();
  static const int kAssignStmtFieldNumber = 2;
  private:
  const ::Pasc::AssignStatement& _internal_assignstmt() const;
  public:
  const ::Pasc::AssignStatement& assignstmt() const;
  ::Pasc::AssignStatement* release_assignstmt();
  ::Pasc::AssignStatement* mutable_assignstmt();
  void set_allocated_assignstmt(::Pasc::AssignStatement* assignstmt);

  // .Pasc.ProcedureStatement procStmt = 3;
  bool has_procstmt() const;
  void clear_procstmt();
  static const int kProcStmtFieldNumber = 3;
  private:
  const ::Pasc::ProcedureStatement& _internal_procstmt() const;
  public:
  const ::Pasc::ProcedureStatement& procstmt() const;
  ::Pasc::ProcedureStatement* release_procstmt();
  ::Pasc::ProcedureStatement* mutable_procstmt();
  void set_allocated_procstmt(::Pasc::ProcedureStatement* procstmt);

  // .Pasc.IfStatement ifStmt = 4;
  bool has_ifstmt() const;
  void clear_ifstmt();
  static const int kIfStmtFieldNumber = 4;
  private:
  const ::Pasc::IfStatement& _internal_ifstmt() const;
  public:
  const ::Pasc::IfStatement& ifstmt() const;
  ::Pasc::IfStatement* release_ifstmt();
  ::Pasc::IfStatement* mutable_ifstmt();
  void set_allocated_ifstmt(::Pasc::IfStatement* ifstmt);

  // .Pasc.ReturnStatement retStmt = 5;
  bool has_retstmt() const;
  void clear_retstmt();
  static const int kRetStmtFieldNumber = 5;
  private:
  const ::Pasc::ReturnStatement& _internal_retstmt() const;
  public:
  const ::Pasc::ReturnStatement& retstmt() const;
  ::Pasc::ReturnStatement* release_retstmt();
  ::Pasc::ReturnStatement* mutable_retstmt();
  void set_allocated_retstmt(::Pasc::ReturnStatement* retstmt);

  void clear_stmt();
  StmtCase stmt_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Statement)
 private:
  void set_has_assignstmt();
  void set_has_procstmt();
  void set_has_ifstmt();
  void set_has_retstmt();

  inline bool has_stmt() const;
  inline void clear_has_stmt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union StmtUnion {
    StmtUnion() {}
    ::Pasc::AssignStatement* assignstmt_;
    ::Pasc::ProcedureStatement* procstmt_;
    ::Pasc::IfStatement* ifstmt_;
    ::Pasc::ReturnStatement* retstmt_;
  } stmt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_Variable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.Variable) */ {
 public:
  Identifier_Variable();
  virtual ~Identifier_Variable();

  Identifier_Variable(const Identifier_Variable& from);

  inline Identifier_Variable& operator=(const Identifier_Variable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_Variable(Identifier_Variable&& from) noexcept
    : Identifier_Variable() {
    *this = ::std::move(from);
  }

  inline Identifier_Variable& operator=(Identifier_Variable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_Variable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_Variable* internal_default_instance() {
    return reinterpret_cast<const Identifier_Variable*>(
               &_Identifier_Variable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(Identifier_Variable* other);
  friend void swap(Identifier_Variable& a, Identifier_Variable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_Variable* New() const final {
    return CreateMaybeMessage<Identifier_Variable>(NULL);
  }

  Identifier_Variable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_Variable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_Variable& from);
  void MergeFrom(const Identifier_Variable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_Variable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.Variable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_IndexedVariable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.IndexedVariable) */ {
 public:
  Identifier_IndexedVariable();
  virtual ~Identifier_IndexedVariable();

  Identifier_IndexedVariable(const Identifier_IndexedVariable& from);

  inline Identifier_IndexedVariable& operator=(const Identifier_IndexedVariable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_IndexedVariable(Identifier_IndexedVariable&& from) noexcept
    : Identifier_IndexedVariable() {
    *this = ::std::move(from);
  }

  inline Identifier_IndexedVariable& operator=(Identifier_IndexedVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_IndexedVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_IndexedVariable* internal_default_instance() {
    return reinterpret_cast<const Identifier_IndexedVariable*>(
               &_Identifier_IndexedVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(Identifier_IndexedVariable* other);
  friend void swap(Identifier_IndexedVariable& a, Identifier_IndexedVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_IndexedVariable* New() const final {
    return CreateMaybeMessage<Identifier_IndexedVariable>(NULL);
  }

  Identifier_IndexedVariable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_IndexedVariable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_IndexedVariable& from);
  void MergeFrom(const Identifier_IndexedVariable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_IndexedVariable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.IndexedVariable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier_FieldDesignator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier.FieldDesignator) */ {
 public:
  Identifier_FieldDesignator();
  virtual ~Identifier_FieldDesignator();

  Identifier_FieldDesignator(const Identifier_FieldDesignator& from);

  inline Identifier_FieldDesignator& operator=(const Identifier_FieldDesignator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier_FieldDesignator(Identifier_FieldDesignator&& from) noexcept
    : Identifier_FieldDesignator() {
    *this = ::std::move(from);
  }

  inline Identifier_FieldDesignator& operator=(Identifier_FieldDesignator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier_FieldDesignator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier_FieldDesignator* internal_default_instance() {
    return reinterpret_cast<const Identifier_FieldDesignator*>(
               &_Identifier_FieldDesignator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(Identifier_FieldDesignator* other);
  friend void swap(Identifier_FieldDesignator& a, Identifier_FieldDesignator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier_FieldDesignator* New() const final {
    return CreateMaybeMessage<Identifier_FieldDesignator>(NULL);
  }

  Identifier_FieldDesignator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier_FieldDesignator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier_FieldDesignator& from);
  void MergeFrom(const Identifier_FieldDesignator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier_FieldDesignator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Pasc.Identifier.FieldDesignator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  enum ValueCase {
    kVar = 2,
    kIv = 3,
    kFld = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(NULL);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Identifier_Variable Variable;
  typedef Identifier_IndexedVariable IndexedVariable;
  typedef Identifier_FieldDesignator FieldDesignator;

  typedef Identifier_IDKind IDKind;
  static const IDKind EntireVar =
    Identifier_IDKind_EntireVar;
  static const IDKind IdxVar =
    Identifier_IDKind_IdxVar;
  static const IDKind Field =
    Identifier_IDKind_Field;
  static inline bool IDKind_IsValid(int value) {
    return Identifier_IDKind_IsValid(value);
  }
  static const IDKind IDKind_MIN =
    Identifier_IDKind_IDKind_MIN;
  static const IDKind IDKind_MAX =
    Identifier_IDKind_IDKind_MAX;
  static const int IDKind_ARRAYSIZE =
    Identifier_IDKind_IDKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IDKind_descriptor() {
    return Identifier_IDKind_descriptor();
  }
  static inline const ::std::string& IDKind_Name(IDKind value) {
    return Identifier_IDKind_Name(value);
  }
  static inline bool IDKind_Parse(const ::std::string& name,
      IDKind* value) {
    return Identifier_IDKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Identifier.IDKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Identifier_IDKind kind() const;
  void set_kind(::Pasc::Identifier_IDKind value);

  // .Pasc.Identifier.Variable var = 2;
  bool has_var() const;
  void clear_var();
  static const int kVarFieldNumber = 2;
  private:
  const ::Pasc::Identifier_Variable& _internal_var() const;
  public:
  const ::Pasc::Identifier_Variable& var() const;
  ::Pasc::Identifier_Variable* release_var();
  ::Pasc::Identifier_Variable* mutable_var();
  void set_allocated_var(::Pasc::Identifier_Variable* var);

  // .Pasc.Identifier.IndexedVariable iv = 3;
  bool has_iv() const;
  void clear_iv();
  static const int kIvFieldNumber = 3;
  private:
  const ::Pasc::Identifier_IndexedVariable& _internal_iv() const;
  public:
  const ::Pasc::Identifier_IndexedVariable& iv() const;
  ::Pasc::Identifier_IndexedVariable* release_iv();
  ::Pasc::Identifier_IndexedVariable* mutable_iv();
  void set_allocated_iv(::Pasc::Identifier_IndexedVariable* iv);

  // .Pasc.Identifier.FieldDesignator fld = 4;
  bool has_fld() const;
  void clear_fld();
  static const int kFldFieldNumber = 4;
  private:
  const ::Pasc::Identifier_FieldDesignator& _internal_fld() const;
  public:
  const ::Pasc::Identifier_FieldDesignator& fld() const;
  ::Pasc::Identifier_FieldDesignator* release_fld();
  ::Pasc::Identifier_FieldDesignator* mutable_fld();
  void set_allocated_fld(::Pasc::Identifier_FieldDesignator* fld);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Identifier)
 private:
  void set_has_var();
  void set_has_iv();
  void set_has_fld();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union ValueUnion {
    ValueUnion() {}
    ::Pasc::Identifier_Variable* var_;
    ::Pasc::Identifier_IndexedVariable* iv_;
    ::Pasc::Identifier_FieldDesignator* fld_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(Expression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  enum ExprCase {
    kId = 2,
    kUint = 3,
    kBe = 4,
    kWp = 5,
    kFc = 6,
    EXPR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(Expression* other);
  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression* New() const final {
    return CreateMaybeMessage<Expression>(NULL);
  }

  Expression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Expression_ExprKind ExprKind;
  static const ExprKind UInt =
    Expression_ExprKind_UInt;
  static const ExprKind Bool =
    Expression_ExprKind_Bool;
  static const ExprKind Ident =
    Expression_ExprKind_Ident;
  static const ExprKind BinExpr =
    Expression_ExprKind_BinExpr;
  static const ExprKind WriteParam =
    Expression_ExprKind_WriteParam;
  static const ExprKind FCall =
    Expression_ExprKind_FCall;
  static inline bool ExprKind_IsValid(int value) {
    return Expression_ExprKind_IsValid(value);
  }
  static const ExprKind ExprKind_MIN =
    Expression_ExprKind_ExprKind_MIN;
  static const ExprKind ExprKind_MAX =
    Expression_ExprKind_ExprKind_MAX;
  static const int ExprKind_ARRAYSIZE =
    Expression_ExprKind_ExprKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ExprKind_descriptor() {
    return Expression_ExprKind_descriptor();
  }
  static inline const ::std::string& ExprKind_Name(ExprKind value) {
    return Expression_ExprKind_Name(value);
  }
  static inline bool ExprKind_Parse(const ::std::string& name,
      ExprKind* value) {
    return Expression_ExprKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Expression.ExprKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::Expression_ExprKind kind() const;
  void set_kind(::Pasc::Expression_ExprKind value);

  // .Pasc.Identifier id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  private:
  const ::Pasc::Identifier& _internal_id() const;
  public:
  const ::Pasc::Identifier& id() const;
  ::Pasc::Identifier* release_id();
  ::Pasc::Identifier* mutable_id();
  void set_allocated_id(::Pasc::Identifier* id);

  // .Pasc.UIntLiteral uint = 3;
  bool has_uint() const;
  void clear_uint();
  static const int kUintFieldNumber = 3;
  private:
  const ::Pasc::UIntLiteral& _internal_uint() const;
  public:
  const ::Pasc::UIntLiteral& uint() const;
  ::Pasc::UIntLiteral* release_uint();
  ::Pasc::UIntLiteral* mutable_uint();
  void set_allocated_uint(::Pasc::UIntLiteral* uint);

  // .Pasc.BinaryExpr be = 4;
  bool has_be() const;
  void clear_be();
  static const int kBeFieldNumber = 4;
  private:
  const ::Pasc::BinaryExpr& _internal_be() const;
  public:
  const ::Pasc::BinaryExpr& be() const;
  ::Pasc::BinaryExpr* release_be();
  ::Pasc::BinaryExpr* mutable_be();
  void set_allocated_be(::Pasc::BinaryExpr* be);

  // .Pasc.WriteParameter wp = 5;
  bool has_wp() const;
  void clear_wp();
  static const int kWpFieldNumber = 5;
  private:
  const ::Pasc::WriteParameter& _internal_wp() const;
  public:
  const ::Pasc::WriteParameter& wp() const;
  ::Pasc::WriteParameter* release_wp();
  ::Pasc::WriteParameter* mutable_wp();
  void set_allocated_wp(::Pasc::WriteParameter* wp);

  // .Pasc.FuncCall fc = 6;
  bool has_fc() const;
  void clear_fc();
  static const int kFcFieldNumber = 6;
  private:
  const ::Pasc::FuncCall& _internal_fc() const;
  public:
  const ::Pasc::FuncCall& fc() const;
  ::Pasc::FuncCall* release_fc();
  ::Pasc::FuncCall* mutable_fc();
  void set_allocated_fc(::Pasc::FuncCall* fc);

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Expression)
 private:
  void set_has_id();
  void set_has_uint();
  void set_has_be();
  void set_has_wp();
  void set_has_fc();

  inline bool has_expr() const;
  inline void clear_has_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union ExprUnion {
    ExprUnion() {}
    ::Pasc::Identifier* id_;
    ::Pasc::UIntLiteral* uint_;
    ::Pasc::BinaryExpr* be_;
    ::Pasc::WriteParameter* wp_;
    ::Pasc::FuncCall* fc_;
  } expr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.WriteParameter) */ {
 public:
  WriteParameter();
  virtual ~WriteParameter();

  WriteParameter(const WriteParameter& from);

  inline WriteParameter& operator=(const WriteParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteParameter(WriteParameter&& from) noexcept
    : WriteParameter() {
    *this = ::std::move(from);
  }

  inline WriteParameter& operator=(WriteParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteParameter* internal_default_instance() {
    return reinterpret_cast<const WriteParameter*>(
               &_WriteParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(WriteParameter* other);
  friend void swap(WriteParameter& a, WriteParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteParameter* New() const final {
    return CreateMaybeMessage<WriteParameter>(NULL);
  }

  WriteParameter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteParameter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteParameter& from);
  void MergeFrom(const WriteParameter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression e = 1;
  bool has_e() const;
  void clear_e();
  static const int kEFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_e() const;
  public:
  const ::Pasc::Expression& e() const;
  ::Pasc::Expression* release_e();
  ::Pasc::Expression* mutable_e();
  void set_allocated_e(::Pasc::Expression* e);

  // .Pasc.Expression totalWidth = 2;
  bool has_totalwidth() const;
  void clear_totalwidth();
  static const int kTotalWidthFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_totalwidth() const;
  public:
  const ::Pasc::Expression& totalwidth() const;
  ::Pasc::Expression* release_totalwidth();
  ::Pasc::Expression* mutable_totalwidth();
  void set_allocated_totalwidth(::Pasc::Expression* totalwidth);

  // .Pasc.Expression fracDigits = 3;
  bool has_fracdigits() const;
  void clear_fracdigits();
  static const int kFracDigitsFieldNumber = 3;
  private:
  const ::Pasc::Expression& _internal_fracdigits() const;
  public:
  const ::Pasc::Expression& fracdigits() const;
  ::Pasc::Expression* release_fracdigits();
  ::Pasc::Expression* mutable_fracdigits();
  void set_allocated_fracdigits(::Pasc::Expression* fracdigits);

  // @@protoc_insertion_point(class_scope:Pasc.WriteParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* e_;
  ::Pasc::Expression* totalwidth_;
  ::Pasc::Expression* fracdigits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BinaryExpr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.BinaryExpr) */ {
 public:
  BinaryExpr();
  virtual ~BinaryExpr();

  BinaryExpr(const BinaryExpr& from);

  inline BinaryExpr& operator=(const BinaryExpr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinaryExpr(BinaryExpr&& from) noexcept
    : BinaryExpr() {
    *this = ::std::move(from);
  }

  inline BinaryExpr& operator=(BinaryExpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BinaryExpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryExpr* internal_default_instance() {
    return reinterpret_cast<const BinaryExpr*>(
               &_BinaryExpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(BinaryExpr* other);
  friend void swap(BinaryExpr& a, BinaryExpr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinaryExpr* New() const final {
    return CreateMaybeMessage<BinaryExpr>(NULL);
  }

  BinaryExpr* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinaryExpr>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinaryExpr& from);
  void MergeFrom(const BinaryExpr& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryExpr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Expression left = 1;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_left() const;
  public:
  const ::Pasc::Expression& left() const;
  ::Pasc::Expression* release_left();
  ::Pasc::Expression* mutable_left();
  void set_allocated_left(::Pasc::Expression* left);

  // .Pasc.Expression right = 2;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_right() const;
  public:
  const ::Pasc::Expression& right() const;
  ::Pasc::Expression* release_right();
  ::Pasc::Expression* mutable_right();
  void set_allocated_right(::Pasc::Expression* right);

  // .Pasc.Operator op = 3;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 3;
  private:
  const ::Pasc::Operator& _internal_op() const;
  public:
  const ::Pasc::Operator& op() const;
  ::Pasc::Operator* release_op();
  ::Pasc::Operator* mutable_op();
  void set_allocated_op(::Pasc::Operator* op);

  // @@protoc_insertion_point(class_scope:Pasc.BinaryExpr)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Expression* left_;
  ::Pasc::Expression* right_;
  ::Pasc::Operator* op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UIntLiteral : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.UIntLiteral) */ {
 public:
  UIntLiteral();
  virtual ~UIntLiteral();

  UIntLiteral(const UIntLiteral& from);

  inline UIntLiteral& operator=(const UIntLiteral& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UIntLiteral(UIntLiteral&& from) noexcept
    : UIntLiteral() {
    *this = ::std::move(from);
  }

  inline UIntLiteral& operator=(UIntLiteral&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UIntLiteral& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UIntLiteral* internal_default_instance() {
    return reinterpret_cast<const UIntLiteral*>(
               &_UIntLiteral_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(UIntLiteral* other);
  friend void swap(UIntLiteral& a, UIntLiteral& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UIntLiteral* New() const final {
    return CreateMaybeMessage<UIntLiteral>(NULL);
  }

  UIntLiteral* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UIntLiteral>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UIntLiteral& from);
  void MergeFrom(const UIntLiteral& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIntLiteral* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Pasc.UIntLiteral)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FuncCall : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.FuncCall) */ {
 public:
  FuncCall();
  virtual ~FuncCall();

  FuncCall(const FuncCall& from);

  inline FuncCall& operator=(const FuncCall& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FuncCall(FuncCall&& from) noexcept
    : FuncCall() {
    *this = ::std::move(from);
  }

  inline FuncCall& operator=(FuncCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FuncCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FuncCall* internal_default_instance() {
    return reinterpret_cast<const FuncCall*>(
               &_FuncCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(FuncCall* other);
  friend void swap(FuncCall& a, FuncCall& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FuncCall* New() const final {
    return CreateMaybeMessage<FuncCall>(NULL);
  }

  FuncCall* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FuncCall>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FuncCall& from);
  void MergeFrom(const FuncCall& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FuncCall* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression args = 2;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 2;
  ::Pasc::Expression* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_args();
  const ::Pasc::Expression& args(int index) const;
  ::Pasc::Expression* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      args() const;

  // .Pasc.Expression name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Expression& _internal_name() const;
  public:
  const ::Pasc::Expression& name() const;
  ::Pasc::Expression* release_name();
  ::Pasc::Expression* mutable_name();
  void set_allocated_name(::Pasc::Expression* name);

  // .Pasc.Type returnType = 3;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 3;
  private:
  const ::Pasc::Type& _internal_returntype() const;
  public:
  const ::Pasc::Type& returntype() const;
  ::Pasc::Type* release_returntype();
  ::Pasc::Type* mutable_returntype();
  void set_allocated_returntype(::Pasc::Type* returntype);

  // @@protoc_insertion_point(class_scope:Pasc.FuncCall)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > args_;
  ::Pasc::Expression* name_;
  ::Pasc::Type* returntype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Integer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Integer) */ {
 public:
  Type_Integer();
  virtual ~Type_Integer();

  Type_Integer(const Type_Integer& from);

  inline Type_Integer& operator=(const Type_Integer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Integer(Type_Integer&& from) noexcept
    : Type_Integer() {
    *this = ::std::move(from);
  }

  inline Type_Integer& operator=(Type_Integer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Integer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Integer* internal_default_instance() {
    return reinterpret_cast<const Type_Integer*>(
               &_Type_Integer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(Type_Integer* other);
  friend void swap(Type_Integer& a, Type_Integer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Integer* New() const final {
    return CreateMaybeMessage<Type_Integer>(NULL);
  }

  Type_Integer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Integer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Integer& from);
  void MergeFrom(const Type_Integer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Integer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Integer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Boolean : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Boolean) */ {
 public:
  Type_Boolean();
  virtual ~Type_Boolean();

  Type_Boolean(const Type_Boolean& from);

  inline Type_Boolean& operator=(const Type_Boolean& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Boolean(Type_Boolean&& from) noexcept
    : Type_Boolean() {
    *this = ::std::move(from);
  }

  inline Type_Boolean& operator=(Type_Boolean&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Boolean& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Boolean* internal_default_instance() {
    return reinterpret_cast<const Type_Boolean*>(
               &_Type_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(Type_Boolean* other);
  friend void swap(Type_Boolean& a, Type_Boolean& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Boolean* New() const final {
    return CreateMaybeMessage<Type_Boolean>(NULL);
  }

  Type_Boolean* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Boolean>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Boolean& from);
  void MergeFrom(const Type_Boolean& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Boolean* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Boolean)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Real : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Real) */ {
 public:
  Type_Real();
  virtual ~Type_Real();

  Type_Real(const Type_Real& from);

  inline Type_Real& operator=(const Type_Real& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Real(Type_Real&& from) noexcept
    : Type_Real() {
    *this = ::std::move(from);
  }

  inline Type_Real& operator=(Type_Real&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Real& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Real* internal_default_instance() {
    return reinterpret_cast<const Type_Real*>(
               &_Type_Real_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(Type_Real* other);
  friend void swap(Type_Real& a, Type_Real& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Real* New() const final {
    return CreateMaybeMessage<Type_Real>(NULL);
  }

  Type_Real* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Real>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Real& from);
  void MergeFrom(const Type_Real& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Real* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Real)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Char : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Char) */ {
 public:
  Type_Char();
  virtual ~Type_Char();

  Type_Char(const Type_Char& from);

  inline Type_Char& operator=(const Type_Char& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Char(Type_Char&& from) noexcept
    : Type_Char() {
    *this = ::std::move(from);
  }

  inline Type_Char& operator=(Type_Char&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Char& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Char* internal_default_instance() {
    return reinterpret_cast<const Type_Char*>(
               &_Type_Char_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(Type_Char* other);
  friend void swap(Type_Char& a, Type_Char& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Char* New() const final {
    return CreateMaybeMessage<Type_Char>(NULL);
  }

  Type_Char* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Char>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Char& from);
  void MergeFrom(const Type_Char& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Char* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Char)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type_Void : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type.Void) */ {
 public:
  Type_Void();
  virtual ~Type_Void();

  Type_Void(const Type_Void& from);

  inline Type_Void& operator=(const Type_Void& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type_Void(Type_Void&& from) noexcept
    : Type_Void() {
    *this = ::std::move(from);
  }

  inline Type_Void& operator=(Type_Void&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type_Void& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type_Void* internal_default_instance() {
    return reinterpret_cast<const Type_Void*>(
               &_Type_Void_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(Type_Void* other);
  friend void swap(Type_Void& a, Type_Void& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type_Void* New() const final {
    return CreateMaybeMessage<Type_Void>(NULL);
  }

  Type_Void* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type_Void>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type_Void& from);
  void MergeFrom(const Type_Void& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type_Void* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Type.Void)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type) */ {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(Type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();

  enum TypeCase {
    kInt = 2,
    kReal = 3,
    kBool = 4,
    kChar = 5,
    kVoid = 6,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(Type* other);
  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(NULL);
  }

  Type* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_Integer Integer;
  typedef Type_Boolean Boolean;
  typedef Type_Real Real;
  typedef Type_Char Char;
  typedef Type_Void Void;

  typedef Type_TypeKind TypeKind;
  static const TypeKind INTEGER =
    Type_TypeKind_INTEGER;
  static const TypeKind REAL =
    Type_TypeKind_REAL;
  static const TypeKind BOOLEAN =
    Type_TypeKind_BOOLEAN;
  static const TypeKind CHAR =
    Type_TypeKind_CHAR;
  static const TypeKind VOID =
    Type_TypeKind_VOID;
  static inline bool TypeKind_IsValid(int value) {
    return Type_TypeKind_IsValid(value);
  }
  static const TypeKind TypeKind_MIN =
    Type_TypeKind_TypeKind_MIN;
  static const TypeKind TypeKind_MAX =
    Type_TypeKind_TypeKind_MAX;
  static const int TypeKind_ARRAYSIZE =
    Type_TypeKind_TypeKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TypeKind_descriptor() {
    return Type_TypeKind_descriptor();
  }
  static inline const ::std::string& TypeKind_Name(TypeKind value) {
    return Type_TypeKind_Name(value);
  }
  static inline bool TypeKind_Parse(const ::std::string& name,
      TypeKind* value) {
    return Type_TypeKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Type.TypeKind tk = 1;
  void clear_tk();
  static const int kTkFieldNumber = 1;
  ::Pasc::Type_TypeKind tk() const;
  void set_tk(::Pasc::Type_TypeKind value);

  // .Pasc.Type.Integer int = 2;
  bool has_int_() const;
  void clear_int_();
  static const int kIntFieldNumber = 2;
  private:
  const ::Pasc::Type_Integer& _internal_int_() const;
  public:
  const ::Pasc::Type_Integer& int_() const;
  ::Pasc::Type_Integer* release_int_();
  ::Pasc::Type_Integer* mutable_int_();
  void set_allocated_int_(::Pasc::Type_Integer* int_);

  // .Pasc.Type.Real real = 3;
  bool has_real() const;
  void clear_real();
  static const int kRealFieldNumber = 3;
  private:
  const ::Pasc::Type_Real& _internal_real() const;
  public:
  const ::Pasc::Type_Real& real() const;
  ::Pasc::Type_Real* release_real();
  ::Pasc::Type_Real* mutable_real();
  void set_allocated_real(::Pasc::Type_Real* real);

  // .Pasc.Type.Boolean bool = 4;
  bool has_bool_() const;
  void clear_bool_();
  static const int kBoolFieldNumber = 4;
  private:
  const ::Pasc::Type_Boolean& _internal_bool_() const;
  public:
  const ::Pasc::Type_Boolean& bool_() const;
  ::Pasc::Type_Boolean* release_bool_();
  ::Pasc::Type_Boolean* mutable_bool_();
  void set_allocated_bool_(::Pasc::Type_Boolean* bool_);

  // .Pasc.Type.Char char = 5;
  bool has_char_() const;
  void clear_char_();
  static const int kCharFieldNumber = 5;
  private:
  const ::Pasc::Type_Char& _internal_char_() const;
  public:
  const ::Pasc::Type_Char& char_() const;
  ::Pasc::Type_Char* release_char_();
  ::Pasc::Type_Char* mutable_char_();
  void set_allocated_char_(::Pasc::Type_Char* char_);

  // .Pasc.Type.Void void = 6;
  bool has_void_() const;
  void clear_void_();
  static const int kVoidFieldNumber = 6;
  private:
  const ::Pasc::Type_Void& _internal_void_() const;
  public:
  const ::Pasc::Type_Void& void_() const;
  ::Pasc::Type_Void* release_void_();
  ::Pasc::Type_Void* mutable_void_();
  void set_allocated_void_(::Pasc::Type_Void* void_);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Type)
 private:
  void set_has_int_();
  void set_has_real();
  void set_has_bool_();
  void set_has_char_();
  void set_has_void_();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int tk_;
  union TypeUnion {
    TypeUnion() {}
    ::Pasc::Type_Integer* int__;
    ::Pasc::Type_Real* real_;
    ::Pasc::Type_Boolean* bool__;
    ::Pasc::Type_Char* char__;
    ::Pasc::Type_Void* void__;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Operator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Operator) */ {
 public:
  Operator();
  virtual ~Operator();

  Operator(const Operator& from);

  inline Operator& operator=(const Operator& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Operator(Operator&& from) noexcept
    : Operator() {
    *this = ::std::move(from);
  }

  inline Operator& operator=(Operator&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Operator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Operator* internal_default_instance() {
    return reinterpret_cast<const Operator*>(
               &_Operator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(Operator* other);
  friend void swap(Operator& a, Operator& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Operator* New() const final {
    return CreateMaybeMessage<Operator>(NULL);
  }

  Operator* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Operator>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Operator& from);
  void MergeFrom(const Operator& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Operator_OpKind OpKind;
  static const OpKind Plus =
    Operator_OpKind_Plus;
  static const OpKind Minus =
    Operator_OpKind_Minus;
  static const OpKind Div =
    Operator_OpKind_Div;
  static const OpKind Sub =
    Operator_OpKind_Sub;
  static const OpKind Mod =
    Operator_OpKind_Mod;
  static const OpKind And =
    Operator_OpKind_And;
  static const OpKind Or =
    Operator_OpKind_Or;
  static const OpKind In =
    Operator_OpKind_In;
  static const OpKind Equal =
    Operator_OpKind_Equal;
  static const OpKind Less =
    Operator_OpKind_Less;
  static const OpKind Great =
    Operator_OpKind_Great;
  static inline bool OpKind_IsValid(int value) {
    return Operator_OpKind_IsValid(value);
  }
  static const OpKind OpKind_MIN =
    Operator_OpKind_OpKind_MIN;
  static const OpKind OpKind_MAX =
    Operator_OpKind_OpKind_MAX;
  static const int OpKind_ARRAYSIZE =
    Operator_OpKind_OpKind_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpKind_descriptor() {
    return Operator_OpKind_descriptor();
  }
  static inline const ::std::string& OpKind_Name(OpKind value) {
    return Operator_OpKind_Name(value);
  }
  static inline bool OpKind_Parse(const ::std::string& name,
      OpKind* value) {
    return Operator_OpKind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .Pasc.Operator.OpKind op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::Pasc::Operator_OpKind op() const;
  void set_op(::Pasc::Operator_OpKind value);

  // @@protoc_insertion_point(class_scope:Pasc.Operator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Program

// .Pasc.TokenKind kind = 1;
inline void Program::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::TokenKind Program::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Program.kind)
  return static_cast< ::Pasc::TokenKind >(kind_);
}
inline void Program::set_kind(::Pasc::TokenKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Program.kind)
}

// string name = 2;
inline void Program::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Program::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Program.name)
  return name_.GetNoArena();
}
inline void Program::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Program.name)
}
#if LANG_CXX11
inline void Program::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Program.name)
}
#endif
inline void Program::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Program.name)
}
inline void Program::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Program.name)
}
inline ::std::string* Program::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Program.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Program::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Program.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Program::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Program.name)
}

// repeated string params = 3;
inline int Program::params_size() const {
  return params_.size();
}
inline void Program::clear_params() {
  params_.Clear();
}
inline const ::std::string& Program::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Program.params)
  return params_.Get(index);
}
inline ::std::string* Program::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Program.params)
  return params_.Mutable(index);
}
inline void Program::set_params(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Pasc.Program.params)
  params_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Program::set_params(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Pasc.Program.params)
  params_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Program::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Pasc.Program.params)
}
inline void Program::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pasc.Program.params)
}
inline ::std::string* Program::add_params() {
  // @@protoc_insertion_point(field_add_mutable:Pasc.Program.params)
  return params_.Add();
}
inline void Program::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Pasc.Program.params)
}
#if LANG_CXX11
inline void Program::add_params(::std::string&& value) {
  params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Pasc.Program.params)
}
#endif
inline void Program::add_params(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Pasc.Program.params)
}
inline void Program::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Pasc.Program.params)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Program::params() const {
  // @@protoc_insertion_point(field_list:Pasc.Program.params)
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Program::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Program.params)
  return &params_;
}

// .Pasc.Block block = 4;
inline bool Program::has_block() const {
  return this != internal_default_instance() && block_ != NULL;
}
inline void Program::clear_block() {
  if (GetArenaNoVirtual() == NULL && block_ != NULL) {
    delete block_;
  }
  block_ = NULL;
}
inline const ::Pasc::Block& Program::_internal_block() const {
  return *block_;
}
inline const ::Pasc::Block& Program::block() const {
  const ::Pasc::Block* p = block_;
  // @@protoc_insertion_point(field_get:Pasc.Program.block)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Block*>(
      &::Pasc::_Block_default_instance_);
}
inline ::Pasc::Block* Program::release_block() {
  // @@protoc_insertion_point(field_release:Pasc.Program.block)
  
  ::Pasc::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::Pasc::Block* Program::mutable_block() {
  
  if (block_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Program.block)
  return block_;
}
inline void Program::set_allocated_block(::Pasc::Block* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:Pasc.Program.block)
}

// -------------------------------------------------------------------

// Block

// repeated .Pasc.VarDeclaration varDecl = 1;
inline int Block::vardecl_size() const {
  return vardecl_.size();
}
inline void Block::clear_vardecl() {
  vardecl_.Clear();
}
inline ::Pasc::VarDeclaration* Block::mutable_vardecl(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Block.varDecl)
  return vardecl_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >*
Block::mutable_vardecl() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Block.varDecl)
  return &vardecl_;
}
inline const ::Pasc::VarDeclaration& Block::vardecl(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Block.varDecl)
  return vardecl_.Get(index);
}
inline ::Pasc::VarDeclaration* Block::add_vardecl() {
  // @@protoc_insertion_point(field_add:Pasc.Block.varDecl)
  return vardecl_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >&
Block::vardecl() const {
  // @@protoc_insertion_point(field_list:Pasc.Block.varDecl)
  return vardecl_;
}

// repeated .Pasc.Statement stmts = 2;
inline int Block::stmts_size() const {
  return stmts_.size();
}
inline void Block::clear_stmts() {
  stmts_.Clear();
}
inline ::Pasc::Statement* Block::mutable_stmts(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Block.stmts)
  return stmts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
Block::mutable_stmts() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Block.stmts)
  return &stmts_;
}
inline const ::Pasc::Statement& Block::stmts(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Block.stmts)
  return stmts_.Get(index);
}
inline ::Pasc::Statement* Block::add_stmts() {
  // @@protoc_insertion_point(field_add:Pasc.Block.stmts)
  return stmts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
Block::stmts() const {
  // @@protoc_insertion_point(field_list:Pasc.Block.stmts)
  return stmts_;
}

// repeated .Pasc.Callable callables = 3;
inline int Block::callables_size() const {
  return callables_.size();
}
inline void Block::clear_callables() {
  callables_.Clear();
}
inline ::Pasc::Callable* Block::mutable_callables(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Block.callables)
  return callables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Callable >*
Block::mutable_callables() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Block.callables)
  return &callables_;
}
inline const ::Pasc::Callable& Block::callables(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Block.callables)
  return callables_.Get(index);
}
inline ::Pasc::Callable* Block::add_callables() {
  // @@protoc_insertion_point(field_add:Pasc.Block.callables)
  return callables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Callable >&
Block::callables() const {
  // @@protoc_insertion_point(field_list:Pasc.Block.callables)
  return callables_;
}

// -------------------------------------------------------------------

// Callable

// .Pasc.Callable.CallKind kind = 1;
inline void Callable::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Callable_CallKind Callable::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Callable.kind)
  return static_cast< ::Pasc::Callable_CallKind >(kind_);
}
inline void Callable::set_kind(::Pasc::Callable_CallKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Callable.kind)
}

// .Pasc.FuncDeclaration funcDecl = 2;
inline bool Callable::has_funcdecl() const {
  return call_case() == kFuncDecl;
}
inline void Callable::set_has_funcdecl() {
  _oneof_case_[0] = kFuncDecl;
}
inline void Callable::clear_funcdecl() {
  if (has_funcdecl()) {
    delete call_.funcdecl_;
    clear_has_call();
  }
}
inline const ::Pasc::FuncDeclaration& Callable::_internal_funcdecl() const {
  return *call_.funcdecl_;
}
inline ::Pasc::FuncDeclaration* Callable::release_funcdecl() {
  // @@protoc_insertion_point(field_release:Pasc.Callable.funcDecl)
  if (has_funcdecl()) {
    clear_has_call();
      ::Pasc::FuncDeclaration* temp = call_.funcdecl_;
    call_.funcdecl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::FuncDeclaration& Callable::funcdecl() const {
  // @@protoc_insertion_point(field_get:Pasc.Callable.funcDecl)
  return has_funcdecl()
      ? *call_.funcdecl_
      : *reinterpret_cast< ::Pasc::FuncDeclaration*>(&::Pasc::_FuncDeclaration_default_instance_);
}
inline ::Pasc::FuncDeclaration* Callable::mutable_funcdecl() {
  if (!has_funcdecl()) {
    clear_call();
    set_has_funcdecl();
    call_.funcdecl_ = CreateMaybeMessage< ::Pasc::FuncDeclaration >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Callable.funcDecl)
  return call_.funcdecl_;
}

// .Pasc.ProcDeclaration procDecl = 3;
inline bool Callable::has_procdecl() const {
  return call_case() == kProcDecl;
}
inline void Callable::set_has_procdecl() {
  _oneof_case_[0] = kProcDecl;
}
inline void Callable::clear_procdecl() {
  if (has_procdecl()) {
    delete call_.procdecl_;
    clear_has_call();
  }
}
inline const ::Pasc::ProcDeclaration& Callable::_internal_procdecl() const {
  return *call_.procdecl_;
}
inline ::Pasc::ProcDeclaration* Callable::release_procdecl() {
  // @@protoc_insertion_point(field_release:Pasc.Callable.procDecl)
  if (has_procdecl()) {
    clear_has_call();
      ::Pasc::ProcDeclaration* temp = call_.procdecl_;
    call_.procdecl_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcDeclaration& Callable::procdecl() const {
  // @@protoc_insertion_point(field_get:Pasc.Callable.procDecl)
  return has_procdecl()
      ? *call_.procdecl_
      : *reinterpret_cast< ::Pasc::ProcDeclaration*>(&::Pasc::_ProcDeclaration_default_instance_);
}
inline ::Pasc::ProcDeclaration* Callable::mutable_procdecl() {
  if (!has_procdecl()) {
    clear_call();
    set_has_procdecl();
    call_.procdecl_ = CreateMaybeMessage< ::Pasc::ProcDeclaration >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Callable.procDecl)
  return call_.procdecl_;
}

inline bool Callable::has_call() const {
  return call_case() != CALL_NOT_SET;
}
inline void Callable::clear_has_call() {
  _oneof_case_[0] = CALL_NOT_SET;
}
inline Callable::CallCase Callable::call_case() const {
  return Callable::CallCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// FormalParameter

// .Pasc.FormalParameter.FPKind kind = 1;
inline void FormalParameter::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::FormalParameter_FPKind FormalParameter::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.FormalParameter.kind)
  return static_cast< ::Pasc::FormalParameter_FPKind >(kind_);
}
inline void FormalParameter::set_kind(::Pasc::FormalParameter_FPKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.FormalParameter.kind)
}

// .Pasc.FuncHeading fHead = 2;
inline bool FormalParameter::has_fhead() const {
  return fp_case() == kFHead;
}
inline void FormalParameter::set_has_fhead() {
  _oneof_case_[0] = kFHead;
}
inline void FormalParameter::clear_fhead() {
  if (has_fhead()) {
    delete fp_.fhead_;
    clear_has_fp();
  }
}
inline const ::Pasc::FuncHeading& FormalParameter::_internal_fhead() const {
  return *fp_.fhead_;
}
inline ::Pasc::FuncHeading* FormalParameter::release_fhead() {
  // @@protoc_insertion_point(field_release:Pasc.FormalParameter.fHead)
  if (has_fhead()) {
    clear_has_fp();
      ::Pasc::FuncHeading* temp = fp_.fhead_;
    fp_.fhead_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::FuncHeading& FormalParameter::fhead() const {
  // @@protoc_insertion_point(field_get:Pasc.FormalParameter.fHead)
  return has_fhead()
      ? *fp_.fhead_
      : *reinterpret_cast< ::Pasc::FuncHeading*>(&::Pasc::_FuncHeading_default_instance_);
}
inline ::Pasc::FuncHeading* FormalParameter::mutable_fhead() {
  if (!has_fhead()) {
    clear_fp();
    set_has_fhead();
    fp_.fhead_ = CreateMaybeMessage< ::Pasc::FuncHeading >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FormalParameter.fHead)
  return fp_.fhead_;
}

// .Pasc.ProcHeading pHead = 3;
inline bool FormalParameter::has_phead() const {
  return fp_case() == kPHead;
}
inline void FormalParameter::set_has_phead() {
  _oneof_case_[0] = kPHead;
}
inline void FormalParameter::clear_phead() {
  if (has_phead()) {
    delete fp_.phead_;
    clear_has_fp();
  }
}
inline const ::Pasc::ProcHeading& FormalParameter::_internal_phead() const {
  return *fp_.phead_;
}
inline ::Pasc::ProcHeading* FormalParameter::release_phead() {
  // @@protoc_insertion_point(field_release:Pasc.FormalParameter.pHead)
  if (has_phead()) {
    clear_has_fp();
      ::Pasc::ProcHeading* temp = fp_.phead_;
    fp_.phead_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcHeading& FormalParameter::phead() const {
  // @@protoc_insertion_point(field_get:Pasc.FormalParameter.pHead)
  return has_phead()
      ? *fp_.phead_
      : *reinterpret_cast< ::Pasc::ProcHeading*>(&::Pasc::_ProcHeading_default_instance_);
}
inline ::Pasc::ProcHeading* FormalParameter::mutable_phead() {
  if (!has_phead()) {
    clear_fp();
    set_has_phead();
    fp_.phead_ = CreateMaybeMessage< ::Pasc::ProcHeading >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FormalParameter.pHead)
  return fp_.phead_;
}

// .Pasc.VariableParam vParam = 4;
inline bool FormalParameter::has_vparam() const {
  return fp_case() == kVParam;
}
inline void FormalParameter::set_has_vparam() {
  _oneof_case_[0] = kVParam;
}
inline void FormalParameter::clear_vparam() {
  if (has_vparam()) {
    delete fp_.vparam_;
    clear_has_fp();
  }
}
inline const ::Pasc::VariableParam& FormalParameter::_internal_vparam() const {
  return *fp_.vparam_;
}
inline ::Pasc::VariableParam* FormalParameter::release_vparam() {
  // @@protoc_insertion_point(field_release:Pasc.FormalParameter.vParam)
  if (has_vparam()) {
    clear_has_fp();
      ::Pasc::VariableParam* temp = fp_.vparam_;
    fp_.vparam_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::VariableParam& FormalParameter::vparam() const {
  // @@protoc_insertion_point(field_get:Pasc.FormalParameter.vParam)
  return has_vparam()
      ? *fp_.vparam_
      : *reinterpret_cast< ::Pasc::VariableParam*>(&::Pasc::_VariableParam_default_instance_);
}
inline ::Pasc::VariableParam* FormalParameter::mutable_vparam() {
  if (!has_vparam()) {
    clear_fp();
    set_has_vparam();
    fp_.vparam_ = CreateMaybeMessage< ::Pasc::VariableParam >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FormalParameter.vParam)
  return fp_.vparam_;
}

// .Pasc.ValueParam valParam = 5;
inline bool FormalParameter::has_valparam() const {
  return fp_case() == kValParam;
}
inline void FormalParameter::set_has_valparam() {
  _oneof_case_[0] = kValParam;
}
inline void FormalParameter::clear_valparam() {
  if (has_valparam()) {
    delete fp_.valparam_;
    clear_has_fp();
  }
}
inline const ::Pasc::ValueParam& FormalParameter::_internal_valparam() const {
  return *fp_.valparam_;
}
inline ::Pasc::ValueParam* FormalParameter::release_valparam() {
  // @@protoc_insertion_point(field_release:Pasc.FormalParameter.valParam)
  if (has_valparam()) {
    clear_has_fp();
      ::Pasc::ValueParam* temp = fp_.valparam_;
    fp_.valparam_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ValueParam& FormalParameter::valparam() const {
  // @@protoc_insertion_point(field_get:Pasc.FormalParameter.valParam)
  return has_valparam()
      ? *fp_.valparam_
      : *reinterpret_cast< ::Pasc::ValueParam*>(&::Pasc::_ValueParam_default_instance_);
}
inline ::Pasc::ValueParam* FormalParameter::mutable_valparam() {
  if (!has_valparam()) {
    clear_fp();
    set_has_valparam();
    fp_.valparam_ = CreateMaybeMessage< ::Pasc::ValueParam >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FormalParameter.valParam)
  return fp_.valparam_;
}

inline bool FormalParameter::has_fp() const {
  return fp_case() != FP_NOT_SET;
}
inline void FormalParameter::clear_has_fp() {
  _oneof_case_[0] = FP_NOT_SET;
}
inline FormalParameter::FpCase FormalParameter::fp_case() const {
  return FormalParameter::FpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// VariableParam

// repeated string names = 1;
inline int VariableParam::names_size() const {
  return names_.size();
}
inline void VariableParam::clear_names() {
  names_.Clear();
}
inline const ::std::string& VariableParam::names(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.VariableParam.names)
  return names_.Get(index);
}
inline ::std::string* VariableParam::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.VariableParam.names)
  return names_.Mutable(index);
}
inline void VariableParam::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Pasc.VariableParam.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void VariableParam::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Pasc.VariableParam.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void VariableParam::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Pasc.VariableParam.names)
}
inline void VariableParam::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pasc.VariableParam.names)
}
inline ::std::string* VariableParam::add_names() {
  // @@protoc_insertion_point(field_add_mutable:Pasc.VariableParam.names)
  return names_.Add();
}
inline void VariableParam::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Pasc.VariableParam.names)
}
#if LANG_CXX11
inline void VariableParam::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Pasc.VariableParam.names)
}
#endif
inline void VariableParam::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Pasc.VariableParam.names)
}
inline void VariableParam::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Pasc.VariableParam.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
VariableParam::names() const {
  // @@protoc_insertion_point(field_list:Pasc.VariableParam.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
VariableParam::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.VariableParam.names)
  return &names_;
}

// .Pasc.Type type = 2;
inline bool VariableParam::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void VariableParam::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}
inline const ::Pasc::Type& VariableParam::_internal_type() const {
  return *type_;
}
inline const ::Pasc::Type& VariableParam::type() const {
  const ::Pasc::Type* p = type_;
  // @@protoc_insertion_point(field_get:Pasc.VariableParam.type)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* VariableParam::release_type() {
  // @@protoc_insertion_point(field_release:Pasc.VariableParam.type)
  
  ::Pasc::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::Pasc::Type* VariableParam::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.VariableParam.type)
  return type_;
}
inline void VariableParam::set_allocated_type(::Pasc::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Pasc.VariableParam.type)
}

// -------------------------------------------------------------------

// ValueParam

// repeated string names = 1;
inline int ValueParam::names_size() const {
  return names_.size();
}
inline void ValueParam::clear_names() {
  names_.Clear();
}
inline const ::std::string& ValueParam::names(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ValueParam.names)
  return names_.Get(index);
}
inline ::std::string* ValueParam::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ValueParam.names)
  return names_.Mutable(index);
}
inline void ValueParam::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Pasc.ValueParam.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ValueParam::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Pasc.ValueParam.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ValueParam::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Pasc.ValueParam.names)
}
inline void ValueParam::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pasc.ValueParam.names)
}
inline ::std::string* ValueParam::add_names() {
  // @@protoc_insertion_point(field_add_mutable:Pasc.ValueParam.names)
  return names_.Add();
}
inline void ValueParam::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Pasc.ValueParam.names)
}
#if LANG_CXX11
inline void ValueParam::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Pasc.ValueParam.names)
}
#endif
inline void ValueParam::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Pasc.ValueParam.names)
}
inline void ValueParam::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Pasc.ValueParam.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ValueParam::names() const {
  // @@protoc_insertion_point(field_list:Pasc.ValueParam.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ValueParam::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ValueParam.names)
  return &names_;
}

// .Pasc.Type type = 2;
inline bool ValueParam::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void ValueParam::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}
inline const ::Pasc::Type& ValueParam::_internal_type() const {
  return *type_;
}
inline const ::Pasc::Type& ValueParam::type() const {
  const ::Pasc::Type* p = type_;
  // @@protoc_insertion_point(field_get:Pasc.ValueParam.type)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* ValueParam::release_type() {
  // @@protoc_insertion_point(field_release:Pasc.ValueParam.type)
  
  ::Pasc::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::Pasc::Type* ValueParam::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ValueParam.type)
  return type_;
}
inline void ValueParam::set_allocated_type(::Pasc::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ValueParam.type)
}

// -------------------------------------------------------------------

// FuncHeading

// string name = 1;
inline void FuncHeading::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FuncHeading::name() const {
  // @@protoc_insertion_point(field_get:Pasc.FuncHeading.name)
  return name_.GetNoArena();
}
inline void FuncHeading::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.FuncHeading.name)
}
#if LANG_CXX11
inline void FuncHeading::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.FuncHeading.name)
}
#endif
inline void FuncHeading::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.FuncHeading.name)
}
inline void FuncHeading::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.FuncHeading.name)
}
inline ::std::string* FuncHeading::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.FuncHeading.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FuncHeading::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.FuncHeading.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FuncHeading::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncHeading.name)
}

// repeated .Pasc.FormalParameter params = 2;
inline int FuncHeading::params_size() const {
  return params_.size();
}
inline void FuncHeading::clear_params() {
  params_.Clear();
}
inline ::Pasc::FormalParameter* FuncHeading::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.FuncHeading.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >*
FuncHeading::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.FuncHeading.params)
  return &params_;
}
inline const ::Pasc::FormalParameter& FuncHeading::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.FuncHeading.params)
  return params_.Get(index);
}
inline ::Pasc::FormalParameter* FuncHeading::add_params() {
  // @@protoc_insertion_point(field_add:Pasc.FuncHeading.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >&
FuncHeading::params() const {
  // @@protoc_insertion_point(field_list:Pasc.FuncHeading.params)
  return params_;
}

// .Pasc.Type returnType = 3;
inline bool FuncHeading::has_returntype() const {
  return this != internal_default_instance() && returntype_ != NULL;
}
inline void FuncHeading::clear_returntype() {
  if (GetArenaNoVirtual() == NULL && returntype_ != NULL) {
    delete returntype_;
  }
  returntype_ = NULL;
}
inline const ::Pasc::Type& FuncHeading::_internal_returntype() const {
  return *returntype_;
}
inline const ::Pasc::Type& FuncHeading::returntype() const {
  const ::Pasc::Type* p = returntype_;
  // @@protoc_insertion_point(field_get:Pasc.FuncHeading.returnType)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* FuncHeading::release_returntype() {
  // @@protoc_insertion_point(field_release:Pasc.FuncHeading.returnType)
  
  ::Pasc::Type* temp = returntype_;
  returntype_ = NULL;
  return temp;
}
inline ::Pasc::Type* FuncHeading::mutable_returntype() {
  
  if (returntype_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    returntype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FuncHeading.returnType)
  return returntype_;
}
inline void FuncHeading::set_allocated_returntype(::Pasc::Type* returntype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete returntype_;
  }
  if (returntype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      returntype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    
  } else {
    
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncHeading.returnType)
}

// -------------------------------------------------------------------

// ProcHeading

// string name = 1;
inline void ProcHeading::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcHeading::name() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcHeading.name)
  return name_.GetNoArena();
}
inline void ProcHeading::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcHeading.name)
}
#if LANG_CXX11
inline void ProcHeading::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcHeading.name)
}
#endif
inline void ProcHeading::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcHeading.name)
}
inline void ProcHeading::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcHeading.name)
}
inline ::std::string* ProcHeading::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcHeading.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcHeading::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcHeading.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcHeading::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcHeading.name)
}

// repeated .Pasc.FormalParameter params = 2;
inline int ProcHeading::params_size() const {
  return params_.size();
}
inline void ProcHeading::clear_params() {
  params_.Clear();
}
inline ::Pasc::FormalParameter* ProcHeading::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcHeading.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >*
ProcHeading::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcHeading.params)
  return &params_;
}
inline const ::Pasc::FormalParameter& ProcHeading::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcHeading.params)
  return params_.Get(index);
}
inline ::Pasc::FormalParameter* ProcHeading::add_params() {
  // @@protoc_insertion_point(field_add:Pasc.ProcHeading.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::FormalParameter >&
ProcHeading::params() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcHeading.params)
  return params_;
}

// .Pasc.Type returnType = 3;
inline bool ProcHeading::has_returntype() const {
  return this != internal_default_instance() && returntype_ != NULL;
}
inline void ProcHeading::clear_returntype() {
  if (GetArenaNoVirtual() == NULL && returntype_ != NULL) {
    delete returntype_;
  }
  returntype_ = NULL;
}
inline const ::Pasc::Type& ProcHeading::_internal_returntype() const {
  return *returntype_;
}
inline const ::Pasc::Type& ProcHeading::returntype() const {
  const ::Pasc::Type* p = returntype_;
  // @@protoc_insertion_point(field_get:Pasc.ProcHeading.returnType)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* ProcHeading::release_returntype() {
  // @@protoc_insertion_point(field_release:Pasc.ProcHeading.returnType)
  
  ::Pasc::Type* temp = returntype_;
  returntype_ = NULL;
  return temp;
}
inline ::Pasc::Type* ProcHeading::mutable_returntype() {
  
  if (returntype_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    returntype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcHeading.returnType)
  return returntype_;
}
inline void ProcHeading::set_allocated_returntype(::Pasc::Type* returntype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete returntype_;
  }
  if (returntype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      returntype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    
  } else {
    
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcHeading.returnType)
}

// -------------------------------------------------------------------

// FuncDeclaration

// .Pasc.FuncHeading funcHeading = 1;
inline bool FuncDeclaration::has_funcheading() const {
  return this != internal_default_instance() && funcheading_ != NULL;
}
inline void FuncDeclaration::clear_funcheading() {
  if (GetArenaNoVirtual() == NULL && funcheading_ != NULL) {
    delete funcheading_;
  }
  funcheading_ = NULL;
}
inline const ::Pasc::FuncHeading& FuncDeclaration::_internal_funcheading() const {
  return *funcheading_;
}
inline const ::Pasc::FuncHeading& FuncDeclaration::funcheading() const {
  const ::Pasc::FuncHeading* p = funcheading_;
  // @@protoc_insertion_point(field_get:Pasc.FuncDeclaration.funcHeading)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::FuncHeading*>(
      &::Pasc::_FuncHeading_default_instance_);
}
inline ::Pasc::FuncHeading* FuncDeclaration::release_funcheading() {
  // @@protoc_insertion_point(field_release:Pasc.FuncDeclaration.funcHeading)
  
  ::Pasc::FuncHeading* temp = funcheading_;
  funcheading_ = NULL;
  return temp;
}
inline ::Pasc::FuncHeading* FuncDeclaration::mutable_funcheading() {
  
  if (funcheading_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::FuncHeading>(GetArenaNoVirtual());
    funcheading_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FuncDeclaration.funcHeading)
  return funcheading_;
}
inline void FuncDeclaration::set_allocated_funcheading(::Pasc::FuncHeading* funcheading) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete funcheading_;
  }
  if (funcheading) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      funcheading = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, funcheading, submessage_arena);
    }
    
  } else {
    
  }
  funcheading_ = funcheading;
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncDeclaration.funcHeading)
}

// .Pasc.Block blk = 2;
inline bool FuncDeclaration::has_blk() const {
  return this != internal_default_instance() && blk_ != NULL;
}
inline void FuncDeclaration::clear_blk() {
  if (GetArenaNoVirtual() == NULL && blk_ != NULL) {
    delete blk_;
  }
  blk_ = NULL;
}
inline const ::Pasc::Block& FuncDeclaration::_internal_blk() const {
  return *blk_;
}
inline const ::Pasc::Block& FuncDeclaration::blk() const {
  const ::Pasc::Block* p = blk_;
  // @@protoc_insertion_point(field_get:Pasc.FuncDeclaration.blk)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Block*>(
      &::Pasc::_Block_default_instance_);
}
inline ::Pasc::Block* FuncDeclaration::release_blk() {
  // @@protoc_insertion_point(field_release:Pasc.FuncDeclaration.blk)
  
  ::Pasc::Block* temp = blk_;
  blk_ = NULL;
  return temp;
}
inline ::Pasc::Block* FuncDeclaration::mutable_blk() {
  
  if (blk_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Block>(GetArenaNoVirtual());
    blk_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FuncDeclaration.blk)
  return blk_;
}
inline void FuncDeclaration::set_allocated_blk(::Pasc::Block* blk) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blk_;
  }
  if (blk) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blk = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blk, submessage_arena);
    }
    
  } else {
    
  }
  blk_ = blk;
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncDeclaration.blk)
}

// string dir = 3;
inline void FuncDeclaration::clear_dir() {
  dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FuncDeclaration::dir() const {
  // @@protoc_insertion_point(field_get:Pasc.FuncDeclaration.dir)
  return dir_.GetNoArena();
}
inline void FuncDeclaration::set_dir(const ::std::string& value) {
  
  dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.FuncDeclaration.dir)
}
#if LANG_CXX11
inline void FuncDeclaration::set_dir(::std::string&& value) {
  
  dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.FuncDeclaration.dir)
}
#endif
inline void FuncDeclaration::set_dir(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.FuncDeclaration.dir)
}
inline void FuncDeclaration::set_dir(const char* value, size_t size) {
  
  dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.FuncDeclaration.dir)
}
inline ::std::string* FuncDeclaration::mutable_dir() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.FuncDeclaration.dir)
  return dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FuncDeclaration::release_dir() {
  // @@protoc_insertion_point(field_release:Pasc.FuncDeclaration.dir)
  
  return dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FuncDeclaration::set_allocated_dir(::std::string* dir) {
  if (dir != NULL) {
    
  } else {
    
  }
  dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dir);
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncDeclaration.dir)
}

// -------------------------------------------------------------------

// ProcDeclaration

// .Pasc.ProcHeading procHead = 1;
inline bool ProcDeclaration::has_prochead() const {
  return this != internal_default_instance() && prochead_ != NULL;
}
inline void ProcDeclaration::clear_prochead() {
  if (GetArenaNoVirtual() == NULL && prochead_ != NULL) {
    delete prochead_;
  }
  prochead_ = NULL;
}
inline const ::Pasc::ProcHeading& ProcDeclaration::_internal_prochead() const {
  return *prochead_;
}
inline const ::Pasc::ProcHeading& ProcDeclaration::prochead() const {
  const ::Pasc::ProcHeading* p = prochead_;
  // @@protoc_insertion_point(field_get:Pasc.ProcDeclaration.procHead)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::ProcHeading*>(
      &::Pasc::_ProcHeading_default_instance_);
}
inline ::Pasc::ProcHeading* ProcDeclaration::release_prochead() {
  // @@protoc_insertion_point(field_release:Pasc.ProcDeclaration.procHead)
  
  ::Pasc::ProcHeading* temp = prochead_;
  prochead_ = NULL;
  return temp;
}
inline ::Pasc::ProcHeading* ProcDeclaration::mutable_prochead() {
  
  if (prochead_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::ProcHeading>(GetArenaNoVirtual());
    prochead_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcDeclaration.procHead)
  return prochead_;
}
inline void ProcDeclaration::set_allocated_prochead(::Pasc::ProcHeading* prochead) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete prochead_;
  }
  if (prochead) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prochead = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prochead, submessage_arena);
    }
    
  } else {
    
  }
  prochead_ = prochead;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcDeclaration.procHead)
}

// .Pasc.Block blk = 2;
inline bool ProcDeclaration::has_blk() const {
  return this != internal_default_instance() && blk_ != NULL;
}
inline void ProcDeclaration::clear_blk() {
  if (GetArenaNoVirtual() == NULL && blk_ != NULL) {
    delete blk_;
  }
  blk_ = NULL;
}
inline const ::Pasc::Block& ProcDeclaration::_internal_blk() const {
  return *blk_;
}
inline const ::Pasc::Block& ProcDeclaration::blk() const {
  const ::Pasc::Block* p = blk_;
  // @@protoc_insertion_point(field_get:Pasc.ProcDeclaration.blk)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Block*>(
      &::Pasc::_Block_default_instance_);
}
inline ::Pasc::Block* ProcDeclaration::release_blk() {
  // @@protoc_insertion_point(field_release:Pasc.ProcDeclaration.blk)
  
  ::Pasc::Block* temp = blk_;
  blk_ = NULL;
  return temp;
}
inline ::Pasc::Block* ProcDeclaration::mutable_blk() {
  
  if (blk_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Block>(GetArenaNoVirtual());
    blk_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcDeclaration.blk)
  return blk_;
}
inline void ProcDeclaration::set_allocated_blk(::Pasc::Block* blk) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete blk_;
  }
  if (blk) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      blk = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, blk, submessage_arena);
    }
    
  } else {
    
  }
  blk_ = blk;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcDeclaration.blk)
}

// string dir = 3;
inline void ProcDeclaration::clear_dir() {
  dir_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcDeclaration::dir() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcDeclaration.dir)
  return dir_.GetNoArena();
}
inline void ProcDeclaration::set_dir(const ::std::string& value) {
  
  dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcDeclaration.dir)
}
#if LANG_CXX11
inline void ProcDeclaration::set_dir(::std::string&& value) {
  
  dir_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcDeclaration.dir)
}
#endif
inline void ProcDeclaration::set_dir(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcDeclaration.dir)
}
inline void ProcDeclaration::set_dir(const char* value, size_t size) {
  
  dir_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcDeclaration.dir)
}
inline ::std::string* ProcDeclaration::mutable_dir() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcDeclaration.dir)
  return dir_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcDeclaration::release_dir() {
  // @@protoc_insertion_point(field_release:Pasc.ProcDeclaration.dir)
  
  return dir_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcDeclaration::set_allocated_dir(::std::string* dir) {
  if (dir != NULL) {
    
  } else {
    
  }
  dir_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dir);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcDeclaration.dir)
}

// -------------------------------------------------------------------

// VarDeclaration

// .Pasc.Expression name = 1;
inline bool VarDeclaration::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void VarDeclaration::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Expression& VarDeclaration::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Expression& VarDeclaration::name() const {
  const ::Pasc::Expression* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.VarDeclaration.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* VarDeclaration::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.VarDeclaration.name)
  
  ::Pasc::Expression* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Expression* VarDeclaration::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.VarDeclaration.name)
  return name_;
}
inline void VarDeclaration::set_allocated_name(::Pasc::Expression* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.VarDeclaration.name)
}

// .Pasc.Type type = 2;
inline bool VarDeclaration::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void VarDeclaration::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}
inline const ::Pasc::Type& VarDeclaration::_internal_type() const {
  return *type_;
}
inline const ::Pasc::Type& VarDeclaration::type() const {
  const ::Pasc::Type* p = type_;
  // @@protoc_insertion_point(field_get:Pasc.VarDeclaration.type)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* VarDeclaration::release_type() {
  // @@protoc_insertion_point(field_release:Pasc.VarDeclaration.type)
  
  ::Pasc::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::Pasc::Type* VarDeclaration::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.VarDeclaration.type)
  return type_;
}
inline void VarDeclaration::set_allocated_type(::Pasc::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Pasc.VarDeclaration.type)
}

// -------------------------------------------------------------------

// ProcedureStatement_WriteLn

// string name = 1;
inline void ProcedureStatement_WriteLn::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ProcedureStatement_WriteLn::name() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.WriteLn.name)
  return name_.GetNoArena();
}
inline void ProcedureStatement_WriteLn::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.WriteLn.name)
}
#if LANG_CXX11
inline void ProcedureStatement_WriteLn::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.ProcedureStatement.WriteLn.name)
}
#endif
inline void ProcedureStatement_WriteLn::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.ProcedureStatement.WriteLn.name)
}
inline void ProcedureStatement_WriteLn::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.ProcedureStatement.WriteLn.name)
}
inline ::std::string* ProcedureStatement_WriteLn::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.WriteLn.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcedureStatement_WriteLn::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.WriteLn.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureStatement_WriteLn::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.WriteLn.name)
}

// .Pasc.Expression file = 2;
inline bool ProcedureStatement_WriteLn::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline void ProcedureStatement_WriteLn::clear_file() {
  if (GetArenaNoVirtual() == NULL && file_ != NULL) {
    delete file_;
  }
  file_ = NULL;
}
inline const ::Pasc::Expression& ProcedureStatement_WriteLn::_internal_file() const {
  return *file_;
}
inline const ::Pasc::Expression& ProcedureStatement_WriteLn::file() const {
  const ::Pasc::Expression* p = file_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.WriteLn.file)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::release_file() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.WriteLn.file)
  
  ::Pasc::Expression* temp = file_;
  file_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::mutable_file() {
  
  if (file_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    file_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.WriteLn.file)
  return file_;
}
inline void ProcedureStatement_WriteLn::set_allocated_file(::Pasc::Expression* file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete file_;
  }
  if (file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.WriteLn.file)
}

// repeated .Pasc.Expression params = 3;
inline int ProcedureStatement_WriteLn::params_size() const {
  return params_.size();
}
inline void ProcedureStatement_WriteLn::clear_params() {
  params_.Clear();
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.WriteLn.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStatement_WriteLn::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStatement.WriteLn.params)
  return &params_;
}
inline const ::Pasc::Expression& ProcedureStatement_WriteLn::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.WriteLn.params)
  return params_.Get(index);
}
inline ::Pasc::Expression* ProcedureStatement_WriteLn::add_params() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStatement.WriteLn.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStatement_WriteLn::params() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStatement.WriteLn.params)
  return params_;
}

// -------------------------------------------------------------------

// ProcedureStatement_Write

// -------------------------------------------------------------------

// ProcedureStatement_Read

// -------------------------------------------------------------------

// ProcedureStatement_ReadLn

// -------------------------------------------------------------------

// ProcedureStatement_ProcStmt

// .Pasc.Expression name = 1;
inline bool ProcedureStatement_ProcStmt::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void ProcedureStatement_ProcStmt::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Expression& ProcedureStatement_ProcStmt::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Expression& ProcedureStatement_ProcStmt::name() const {
  const ::Pasc::Expression* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ProcStmt.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ProcStmt.name)
  
  ::Pasc::Expression* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ProcStmt.name)
  return name_;
}
inline void ProcedureStatement_ProcStmt::set_allocated_name(::Pasc::Expression* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStatement.ProcStmt.name)
}

// repeated .Pasc.Expression params = 2;
inline int ProcedureStatement_ProcStmt::params_size() const {
  return params_.size();
}
inline void ProcedureStatement_ProcStmt::clear_params() {
  params_.Clear();
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ProcStmt.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStatement_ProcStmt::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStatement.ProcStmt.params)
  return &params_;
}
inline const ::Pasc::Expression& ProcedureStatement_ProcStmt::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ProcStmt.params)
  return params_.Get(index);
}
inline ::Pasc::Expression* ProcedureStatement_ProcStmt::add_params() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStatement.ProcStmt.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStatement_ProcStmt::params() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStatement.ProcStmt.params)
  return params_;
}

// -------------------------------------------------------------------

// ProcedureStatement

// .Pasc.ProcedureStatement.PSKind kind = 1;
inline void ProcedureStatement::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::ProcedureStatement_PSKind ProcedureStatement::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.kind)
  return static_cast< ::Pasc::ProcedureStatement_PSKind >(kind_);
}
inline void ProcedureStatement::set_kind(::Pasc::ProcedureStatement_PSKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.ProcedureStatement.kind)
}

// .Pasc.ProcedureStatement.Write wrt = 2;
inline bool ProcedureStatement::has_wrt() const {
  return stmt_case() == kWrt;
}
inline void ProcedureStatement::set_has_wrt() {
  _oneof_case_[0] = kWrt;
}
inline void ProcedureStatement::clear_wrt() {
  if (has_wrt()) {
    delete stmt_.wrt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_Write& ProcedureStatement::_internal_wrt() const {
  return *stmt_.wrt_;
}
inline ::Pasc::ProcedureStatement_Write* ProcedureStatement::release_wrt() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.wrt)
  if (has_wrt()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_Write* temp = stmt_.wrt_;
    stmt_.wrt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_Write& ProcedureStatement::wrt() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.wrt)
  return has_wrt()
      ? *stmt_.wrt_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_Write*>(&::Pasc::_ProcedureStatement_Write_default_instance_);
}
inline ::Pasc::ProcedureStatement_Write* ProcedureStatement::mutable_wrt() {
  if (!has_wrt()) {
    clear_stmt();
    set_has_wrt();
    stmt_.wrt_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_Write >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.wrt)
  return stmt_.wrt_;
}

// .Pasc.ProcedureStatement.WriteLn wrtLn = 3;
inline bool ProcedureStatement::has_wrtln() const {
  return stmt_case() == kWrtLn;
}
inline void ProcedureStatement::set_has_wrtln() {
  _oneof_case_[0] = kWrtLn;
}
inline void ProcedureStatement::clear_wrtln() {
  if (has_wrtln()) {
    delete stmt_.wrtln_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_WriteLn& ProcedureStatement::_internal_wrtln() const {
  return *stmt_.wrtln_;
}
inline ::Pasc::ProcedureStatement_WriteLn* ProcedureStatement::release_wrtln() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.wrtLn)
  if (has_wrtln()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_WriteLn* temp = stmt_.wrtln_;
    stmt_.wrtln_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_WriteLn& ProcedureStatement::wrtln() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.wrtLn)
  return has_wrtln()
      ? *stmt_.wrtln_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_WriteLn*>(&::Pasc::_ProcedureStatement_WriteLn_default_instance_);
}
inline ::Pasc::ProcedureStatement_WriteLn* ProcedureStatement::mutable_wrtln() {
  if (!has_wrtln()) {
    clear_stmt();
    set_has_wrtln();
    stmt_.wrtln_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_WriteLn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.wrtLn)
  return stmt_.wrtln_;
}

// .Pasc.ProcedureStatement.Read rd = 4;
inline bool ProcedureStatement::has_rd() const {
  return stmt_case() == kRd;
}
inline void ProcedureStatement::set_has_rd() {
  _oneof_case_[0] = kRd;
}
inline void ProcedureStatement::clear_rd() {
  if (has_rd()) {
    delete stmt_.rd_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_Read& ProcedureStatement::_internal_rd() const {
  return *stmt_.rd_;
}
inline ::Pasc::ProcedureStatement_Read* ProcedureStatement::release_rd() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.rd)
  if (has_rd()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_Read* temp = stmt_.rd_;
    stmt_.rd_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_Read& ProcedureStatement::rd() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.rd)
  return has_rd()
      ? *stmt_.rd_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_Read*>(&::Pasc::_ProcedureStatement_Read_default_instance_);
}
inline ::Pasc::ProcedureStatement_Read* ProcedureStatement::mutable_rd() {
  if (!has_rd()) {
    clear_stmt();
    set_has_rd();
    stmt_.rd_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_Read >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.rd)
  return stmt_.rd_;
}

// .Pasc.ProcedureStatement.ReadLn rdLn = 5;
inline bool ProcedureStatement::has_rdln() const {
  return stmt_case() == kRdLn;
}
inline void ProcedureStatement::set_has_rdln() {
  _oneof_case_[0] = kRdLn;
}
inline void ProcedureStatement::clear_rdln() {
  if (has_rdln()) {
    delete stmt_.rdln_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_ReadLn& ProcedureStatement::_internal_rdln() const {
  return *stmt_.rdln_;
}
inline ::Pasc::ProcedureStatement_ReadLn* ProcedureStatement::release_rdln() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.rdLn)
  if (has_rdln()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_ReadLn* temp = stmt_.rdln_;
    stmt_.rdln_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_ReadLn& ProcedureStatement::rdln() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.rdLn)
  return has_rdln()
      ? *stmt_.rdln_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_ReadLn*>(&::Pasc::_ProcedureStatement_ReadLn_default_instance_);
}
inline ::Pasc::ProcedureStatement_ReadLn* ProcedureStatement::mutable_rdln() {
  if (!has_rdln()) {
    clear_stmt();
    set_has_rdln();
    stmt_.rdln_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_ReadLn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.rdLn)
  return stmt_.rdln_;
}

// .Pasc.ProcedureStatement.ProcStmt ps = 6;
inline bool ProcedureStatement::has_ps() const {
  return stmt_case() == kPs;
}
inline void ProcedureStatement::set_has_ps() {
  _oneof_case_[0] = kPs;
}
inline void ProcedureStatement::clear_ps() {
  if (has_ps()) {
    delete stmt_.ps_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement_ProcStmt& ProcedureStatement::_internal_ps() const {
  return *stmt_.ps_;
}
inline ::Pasc::ProcedureStatement_ProcStmt* ProcedureStatement::release_ps() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStatement.ps)
  if (has_ps()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement_ProcStmt* temp = stmt_.ps_;
    stmt_.ps_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement_ProcStmt& ProcedureStatement::ps() const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStatement.ps)
  return has_ps()
      ? *stmt_.ps_
      : *reinterpret_cast< ::Pasc::ProcedureStatement_ProcStmt*>(&::Pasc::_ProcedureStatement_ProcStmt_default_instance_);
}
inline ::Pasc::ProcedureStatement_ProcStmt* ProcedureStatement::mutable_ps() {
  if (!has_ps()) {
    clear_stmt();
    set_has_ps();
    stmt_.ps_ = CreateMaybeMessage< ::Pasc::ProcedureStatement_ProcStmt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStatement.ps)
  return stmt_.ps_;
}

inline bool ProcedureStatement::has_stmt() const {
  return stmt_case() != STMT_NOT_SET;
}
inline void ProcedureStatement::clear_has_stmt() {
  _oneof_case_[0] = STMT_NOT_SET;
}
inline ProcedureStatement::StmtCase ProcedureStatement::stmt_case() const {
  return ProcedureStatement::StmtCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AssignStatement

// .Pasc.Expression variable = 1;
inline bool AssignStatement::has_variable() const {
  return this != internal_default_instance() && variable_ != NULL;
}
inline void AssignStatement::clear_variable() {
  if (GetArenaNoVirtual() == NULL && variable_ != NULL) {
    delete variable_;
  }
  variable_ = NULL;
}
inline const ::Pasc::Expression& AssignStatement::_internal_variable() const {
  return *variable_;
}
inline const ::Pasc::Expression& AssignStatement::variable() const {
  const ::Pasc::Expression* p = variable_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStatement.variable)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* AssignStatement::release_variable() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStatement.variable)
  
  ::Pasc::Expression* temp = variable_;
  variable_ = NULL;
  return temp;
}
inline ::Pasc::Expression* AssignStatement::mutable_variable() {
  
  if (variable_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    variable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStatement.variable)
  return variable_;
}
inline void AssignStatement::set_allocated_variable(::Pasc::Expression* variable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete variable_;
  }
  if (variable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      variable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, variable, submessage_arena);
    }
    
  } else {
    
  }
  variable_ = variable;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStatement.variable)
}

// .Pasc.Expression value = 2;
inline bool AssignStatement::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void AssignStatement::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::Pasc::Expression& AssignStatement::_internal_value() const {
  return *value_;
}
inline const ::Pasc::Expression& AssignStatement::value() const {
  const ::Pasc::Expression* p = value_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStatement.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* AssignStatement::release_value() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStatement.value)
  
  ::Pasc::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Pasc::Expression* AssignStatement::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStatement.value)
  return value_;
}
inline void AssignStatement::set_allocated_value(::Pasc::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStatement.value)
}

// -------------------------------------------------------------------

// IfStatement

// .Pasc.Expression cond = 1;
inline bool IfStatement::has_cond() const {
  return this != internal_default_instance() && cond_ != NULL;
}
inline void IfStatement::clear_cond() {
  if (GetArenaNoVirtual() == NULL && cond_ != NULL) {
    delete cond_;
  }
  cond_ = NULL;
}
inline const ::Pasc::Expression& IfStatement::_internal_cond() const {
  return *cond_;
}
inline const ::Pasc::Expression& IfStatement::cond() const {
  const ::Pasc::Expression* p = cond_;
  // @@protoc_insertion_point(field_get:Pasc.IfStatement.cond)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* IfStatement::release_cond() {
  // @@protoc_insertion_point(field_release:Pasc.IfStatement.cond)
  
  ::Pasc::Expression* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline ::Pasc::Expression* IfStatement::mutable_cond() {
  
  if (cond_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStatement.cond)
  return cond_;
}
inline void IfStatement::set_allocated_cond(::Pasc::Expression* cond) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cond_;
  }
  if (cond) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cond = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    
  } else {
    
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStatement.cond)
}

// .Pasc.Statement truePath = 2;
inline bool IfStatement::has_truepath() const {
  return this != internal_default_instance() && truepath_ != NULL;
}
inline void IfStatement::clear_truepath() {
  if (GetArenaNoVirtual() == NULL && truepath_ != NULL) {
    delete truepath_;
  }
  truepath_ = NULL;
}
inline const ::Pasc::Statement& IfStatement::_internal_truepath() const {
  return *truepath_;
}
inline const ::Pasc::Statement& IfStatement::truepath() const {
  const ::Pasc::Statement* p = truepath_;
  // @@protoc_insertion_point(field_get:Pasc.IfStatement.truePath)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* IfStatement::release_truepath() {
  // @@protoc_insertion_point(field_release:Pasc.IfStatement.truePath)
  
  ::Pasc::Statement* temp = truepath_;
  truepath_ = NULL;
  return temp;
}
inline ::Pasc::Statement* IfStatement::mutable_truepath() {
  
  if (truepath_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    truepath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStatement.truePath)
  return truepath_;
}
inline void IfStatement::set_allocated_truepath(::Pasc::Statement* truepath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete truepath_;
  }
  if (truepath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      truepath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, truepath, submessage_arena);
    }
    
  } else {
    
  }
  truepath_ = truepath;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStatement.truePath)
}

// .Pasc.Statement elsePath = 3;
inline bool IfStatement::has_elsepath() const {
  return this != internal_default_instance() && elsepath_ != NULL;
}
inline void IfStatement::clear_elsepath() {
  if (GetArenaNoVirtual() == NULL && elsepath_ != NULL) {
    delete elsepath_;
  }
  elsepath_ = NULL;
}
inline const ::Pasc::Statement& IfStatement::_internal_elsepath() const {
  return *elsepath_;
}
inline const ::Pasc::Statement& IfStatement::elsepath() const {
  const ::Pasc::Statement* p = elsepath_;
  // @@protoc_insertion_point(field_get:Pasc.IfStatement.elsePath)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Statement*>(
      &::Pasc::_Statement_default_instance_);
}
inline ::Pasc::Statement* IfStatement::release_elsepath() {
  // @@protoc_insertion_point(field_release:Pasc.IfStatement.elsePath)
  
  ::Pasc::Statement* temp = elsepath_;
  elsepath_ = NULL;
  return temp;
}
inline ::Pasc::Statement* IfStatement::mutable_elsepath() {
  
  if (elsepath_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Statement>(GetArenaNoVirtual());
    elsepath_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.IfStatement.elsePath)
  return elsepath_;
}
inline void IfStatement::set_allocated_elsepath(::Pasc::Statement* elsepath) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete elsepath_;
  }
  if (elsepath) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      elsepath = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, elsepath, submessage_arena);
    }
    
  } else {
    
  }
  elsepath_ = elsepath;
  // @@protoc_insertion_point(field_set_allocated:Pasc.IfStatement.elsePath)
}

// -------------------------------------------------------------------

// ReturnStatement

// .Pasc.Expression value = 1;
inline bool ReturnStatement::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void ReturnStatement::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::Pasc::Expression& ReturnStatement::_internal_value() const {
  return *value_;
}
inline const ::Pasc::Expression& ReturnStatement::value() const {
  const ::Pasc::Expression* p = value_;
  // @@protoc_insertion_point(field_get:Pasc.ReturnStatement.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* ReturnStatement::release_value() {
  // @@protoc_insertion_point(field_release:Pasc.ReturnStatement.value)
  
  ::Pasc::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Pasc::Expression* ReturnStatement::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ReturnStatement.value)
  return value_;
}
inline void ReturnStatement::set_allocated_value(::Pasc::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ReturnStatement.value)
}

// -------------------------------------------------------------------

// Statement

// .Pasc.Statement.StmtKind kind = 1;
inline void Statement::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Statement_StmtKind Statement::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.kind)
  return static_cast< ::Pasc::Statement_StmtKind >(kind_);
}
inline void Statement::set_kind(::Pasc::Statement_StmtKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Statement.kind)
}

// .Pasc.AssignStatement assignStmt = 2;
inline bool Statement::has_assignstmt() const {
  return stmt_case() == kAssignStmt;
}
inline void Statement::set_has_assignstmt() {
  _oneof_case_[0] = kAssignStmt;
}
inline void Statement::clear_assignstmt() {
  if (has_assignstmt()) {
    delete stmt_.assignstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::AssignStatement& Statement::_internal_assignstmt() const {
  return *stmt_.assignstmt_;
}
inline ::Pasc::AssignStatement* Statement::release_assignstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.assignStmt)
  if (has_assignstmt()) {
    clear_has_stmt();
      ::Pasc::AssignStatement* temp = stmt_.assignstmt_;
    stmt_.assignstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::AssignStatement& Statement::assignstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.assignStmt)
  return has_assignstmt()
      ? *stmt_.assignstmt_
      : *reinterpret_cast< ::Pasc::AssignStatement*>(&::Pasc::_AssignStatement_default_instance_);
}
inline ::Pasc::AssignStatement* Statement::mutable_assignstmt() {
  if (!has_assignstmt()) {
    clear_stmt();
    set_has_assignstmt();
    stmt_.assignstmt_ = CreateMaybeMessage< ::Pasc::AssignStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.assignStmt)
  return stmt_.assignstmt_;
}

// .Pasc.ProcedureStatement procStmt = 3;
inline bool Statement::has_procstmt() const {
  return stmt_case() == kProcStmt;
}
inline void Statement::set_has_procstmt() {
  _oneof_case_[0] = kProcStmt;
}
inline void Statement::clear_procstmt() {
  if (has_procstmt()) {
    delete stmt_.procstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStatement& Statement::_internal_procstmt() const {
  return *stmt_.procstmt_;
}
inline ::Pasc::ProcedureStatement* Statement::release_procstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.procStmt)
  if (has_procstmt()) {
    clear_has_stmt();
      ::Pasc::ProcedureStatement* temp = stmt_.procstmt_;
    stmt_.procstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStatement& Statement::procstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.procStmt)
  return has_procstmt()
      ? *stmt_.procstmt_
      : *reinterpret_cast< ::Pasc::ProcedureStatement*>(&::Pasc::_ProcedureStatement_default_instance_);
}
inline ::Pasc::ProcedureStatement* Statement::mutable_procstmt() {
  if (!has_procstmt()) {
    clear_stmt();
    set_has_procstmt();
    stmt_.procstmt_ = CreateMaybeMessage< ::Pasc::ProcedureStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.procStmt)
  return stmt_.procstmt_;
}

// .Pasc.IfStatement ifStmt = 4;
inline bool Statement::has_ifstmt() const {
  return stmt_case() == kIfStmt;
}
inline void Statement::set_has_ifstmt() {
  _oneof_case_[0] = kIfStmt;
}
inline void Statement::clear_ifstmt() {
  if (has_ifstmt()) {
    delete stmt_.ifstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::IfStatement& Statement::_internal_ifstmt() const {
  return *stmt_.ifstmt_;
}
inline ::Pasc::IfStatement* Statement::release_ifstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.ifStmt)
  if (has_ifstmt()) {
    clear_has_stmt();
      ::Pasc::IfStatement* temp = stmt_.ifstmt_;
    stmt_.ifstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::IfStatement& Statement::ifstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.ifStmt)
  return has_ifstmt()
      ? *stmt_.ifstmt_
      : *reinterpret_cast< ::Pasc::IfStatement*>(&::Pasc::_IfStatement_default_instance_);
}
inline ::Pasc::IfStatement* Statement::mutable_ifstmt() {
  if (!has_ifstmt()) {
    clear_stmt();
    set_has_ifstmt();
    stmt_.ifstmt_ = CreateMaybeMessage< ::Pasc::IfStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.ifStmt)
  return stmt_.ifstmt_;
}

// .Pasc.ReturnStatement retStmt = 5;
inline bool Statement::has_retstmt() const {
  return stmt_case() == kRetStmt;
}
inline void Statement::set_has_retstmt() {
  _oneof_case_[0] = kRetStmt;
}
inline void Statement::clear_retstmt() {
  if (has_retstmt()) {
    delete stmt_.retstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ReturnStatement& Statement::_internal_retstmt() const {
  return *stmt_.retstmt_;
}
inline ::Pasc::ReturnStatement* Statement::release_retstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.retStmt)
  if (has_retstmt()) {
    clear_has_stmt();
      ::Pasc::ReturnStatement* temp = stmt_.retstmt_;
    stmt_.retstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ReturnStatement& Statement::retstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.retStmt)
  return has_retstmt()
      ? *stmt_.retstmt_
      : *reinterpret_cast< ::Pasc::ReturnStatement*>(&::Pasc::_ReturnStatement_default_instance_);
}
inline ::Pasc::ReturnStatement* Statement::mutable_retstmt() {
  if (!has_retstmt()) {
    clear_stmt();
    set_has_retstmt();
    stmt_.retstmt_ = CreateMaybeMessage< ::Pasc::ReturnStatement >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.retStmt)
  return stmt_.retstmt_;
}

inline bool Statement::has_stmt() const {
  return stmt_case() != STMT_NOT_SET;
}
inline void Statement::clear_has_stmt() {
  _oneof_case_[0] = STMT_NOT_SET;
}
inline Statement::StmtCase Statement::stmt_case() const {
  return Statement::StmtCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Identifier_Variable

// string name = 1;
inline void Identifier_Variable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier_Variable::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.Variable.name)
  return name_.GetNoArena();
}
inline void Identifier_Variable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Identifier.Variable.name)
}
#if LANG_CXX11
inline void Identifier_Variable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Identifier.Variable.name)
}
#endif
inline void Identifier_Variable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Identifier.Variable.name)
}
inline void Identifier_Variable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Identifier.Variable.name)
}
inline ::std::string* Identifier_Variable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.Variable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier_Variable::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.Variable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier_Variable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Identifier.Variable.name)
}

// -------------------------------------------------------------------

// Identifier_IndexedVariable

// -------------------------------------------------------------------

// Identifier_FieldDesignator

// -------------------------------------------------------------------

// Identifier

// .Pasc.Identifier.IDKind kind = 1;
inline void Identifier::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Identifier_IDKind Identifier::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.kind)
  return static_cast< ::Pasc::Identifier_IDKind >(kind_);
}
inline void Identifier::set_kind(::Pasc::Identifier_IDKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Identifier.kind)
}

// .Pasc.Identifier.Variable var = 2;
inline bool Identifier::has_var() const {
  return value_case() == kVar;
}
inline void Identifier::set_has_var() {
  _oneof_case_[0] = kVar;
}
inline void Identifier::clear_var() {
  if (has_var()) {
    delete value_.var_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_Variable& Identifier::_internal_var() const {
  return *value_.var_;
}
inline ::Pasc::Identifier_Variable* Identifier::release_var() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.var)
  if (has_var()) {
    clear_has_value();
      ::Pasc::Identifier_Variable* temp = value_.var_;
    value_.var_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_Variable& Identifier::var() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.var)
  return has_var()
      ? *value_.var_
      : *reinterpret_cast< ::Pasc::Identifier_Variable*>(&::Pasc::_Identifier_Variable_default_instance_);
}
inline ::Pasc::Identifier_Variable* Identifier::mutable_var() {
  if (!has_var()) {
    clear_value();
    set_has_var();
    value_.var_ = CreateMaybeMessage< ::Pasc::Identifier_Variable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.var)
  return value_.var_;
}

// .Pasc.Identifier.IndexedVariable iv = 3;
inline bool Identifier::has_iv() const {
  return value_case() == kIv;
}
inline void Identifier::set_has_iv() {
  _oneof_case_[0] = kIv;
}
inline void Identifier::clear_iv() {
  if (has_iv()) {
    delete value_.iv_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_IndexedVariable& Identifier::_internal_iv() const {
  return *value_.iv_;
}
inline ::Pasc::Identifier_IndexedVariable* Identifier::release_iv() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.iv)
  if (has_iv()) {
    clear_has_value();
      ::Pasc::Identifier_IndexedVariable* temp = value_.iv_;
    value_.iv_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_IndexedVariable& Identifier::iv() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.iv)
  return has_iv()
      ? *value_.iv_
      : *reinterpret_cast< ::Pasc::Identifier_IndexedVariable*>(&::Pasc::_Identifier_IndexedVariable_default_instance_);
}
inline ::Pasc::Identifier_IndexedVariable* Identifier::mutable_iv() {
  if (!has_iv()) {
    clear_value();
    set_has_iv();
    value_.iv_ = CreateMaybeMessage< ::Pasc::Identifier_IndexedVariable >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.iv)
  return value_.iv_;
}

// .Pasc.Identifier.FieldDesignator fld = 4;
inline bool Identifier::has_fld() const {
  return value_case() == kFld;
}
inline void Identifier::set_has_fld() {
  _oneof_case_[0] = kFld;
}
inline void Identifier::clear_fld() {
  if (has_fld()) {
    delete value_.fld_;
    clear_has_value();
  }
}
inline const ::Pasc::Identifier_FieldDesignator& Identifier::_internal_fld() const {
  return *value_.fld_;
}
inline ::Pasc::Identifier_FieldDesignator* Identifier::release_fld() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.fld)
  if (has_fld()) {
    clear_has_value();
      ::Pasc::Identifier_FieldDesignator* temp = value_.fld_;
    value_.fld_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier_FieldDesignator& Identifier::fld() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.fld)
  return has_fld()
      ? *value_.fld_
      : *reinterpret_cast< ::Pasc::Identifier_FieldDesignator*>(&::Pasc::_Identifier_FieldDesignator_default_instance_);
}
inline ::Pasc::Identifier_FieldDesignator* Identifier::mutable_fld() {
  if (!has_fld()) {
    clear_value();
    set_has_fld();
    value_.fld_ = CreateMaybeMessage< ::Pasc::Identifier_FieldDesignator >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.fld)
  return value_.fld_;
}

inline bool Identifier::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Identifier::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Identifier::ValueCase Identifier::value_case() const {
  return Identifier::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression

// .Pasc.Expression.ExprKind kind = 1;
inline void Expression::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::Expression_ExprKind Expression::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.kind)
  return static_cast< ::Pasc::Expression_ExprKind >(kind_);
}
inline void Expression::set_kind(::Pasc::Expression_ExprKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Expression.kind)
}

// .Pasc.Identifier id = 2;
inline bool Expression::has_id() const {
  return expr_case() == kId;
}
inline void Expression::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void Expression::clear_id() {
  if (has_id()) {
    delete expr_.id_;
    clear_has_expr();
  }
}
inline const ::Pasc::Identifier& Expression::_internal_id() const {
  return *expr_.id_;
}
inline ::Pasc::Identifier* Expression::release_id() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.id)
  if (has_id()) {
    clear_has_expr();
      ::Pasc::Identifier* temp = expr_.id_;
    expr_.id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier& Expression::id() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.id)
  return has_id()
      ? *expr_.id_
      : *reinterpret_cast< ::Pasc::Identifier*>(&::Pasc::_Identifier_default_instance_);
}
inline ::Pasc::Identifier* Expression::mutable_id() {
  if (!has_id()) {
    clear_expr();
    set_has_id();
    expr_.id_ = CreateMaybeMessage< ::Pasc::Identifier >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.id)
  return expr_.id_;
}

// .Pasc.UIntLiteral uint = 3;
inline bool Expression::has_uint() const {
  return expr_case() == kUint;
}
inline void Expression::set_has_uint() {
  _oneof_case_[0] = kUint;
}
inline void Expression::clear_uint() {
  if (has_uint()) {
    delete expr_.uint_;
    clear_has_expr();
  }
}
inline const ::Pasc::UIntLiteral& Expression::_internal_uint() const {
  return *expr_.uint_;
}
inline ::Pasc::UIntLiteral* Expression::release_uint() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.uint)
  if (has_uint()) {
    clear_has_expr();
      ::Pasc::UIntLiteral* temp = expr_.uint_;
    expr_.uint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::UIntLiteral& Expression::uint() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.uint)
  return has_uint()
      ? *expr_.uint_
      : *reinterpret_cast< ::Pasc::UIntLiteral*>(&::Pasc::_UIntLiteral_default_instance_);
}
inline ::Pasc::UIntLiteral* Expression::mutable_uint() {
  if (!has_uint()) {
    clear_expr();
    set_has_uint();
    expr_.uint_ = CreateMaybeMessage< ::Pasc::UIntLiteral >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.uint)
  return expr_.uint_;
}

// .Pasc.BinaryExpr be = 4;
inline bool Expression::has_be() const {
  return expr_case() == kBe;
}
inline void Expression::set_has_be() {
  _oneof_case_[0] = kBe;
}
inline void Expression::clear_be() {
  if (has_be()) {
    delete expr_.be_;
    clear_has_expr();
  }
}
inline const ::Pasc::BinaryExpr& Expression::_internal_be() const {
  return *expr_.be_;
}
inline ::Pasc::BinaryExpr* Expression::release_be() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.be)
  if (has_be()) {
    clear_has_expr();
      ::Pasc::BinaryExpr* temp = expr_.be_;
    expr_.be_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::BinaryExpr& Expression::be() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.be)
  return has_be()
      ? *expr_.be_
      : *reinterpret_cast< ::Pasc::BinaryExpr*>(&::Pasc::_BinaryExpr_default_instance_);
}
inline ::Pasc::BinaryExpr* Expression::mutable_be() {
  if (!has_be()) {
    clear_expr();
    set_has_be();
    expr_.be_ = CreateMaybeMessage< ::Pasc::BinaryExpr >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.be)
  return expr_.be_;
}

// .Pasc.WriteParameter wp = 5;
inline bool Expression::has_wp() const {
  return expr_case() == kWp;
}
inline void Expression::set_has_wp() {
  _oneof_case_[0] = kWp;
}
inline void Expression::clear_wp() {
  if (has_wp()) {
    delete expr_.wp_;
    clear_has_expr();
  }
}
inline const ::Pasc::WriteParameter& Expression::_internal_wp() const {
  return *expr_.wp_;
}
inline ::Pasc::WriteParameter* Expression::release_wp() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.wp)
  if (has_wp()) {
    clear_has_expr();
      ::Pasc::WriteParameter* temp = expr_.wp_;
    expr_.wp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::WriteParameter& Expression::wp() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.wp)
  return has_wp()
      ? *expr_.wp_
      : *reinterpret_cast< ::Pasc::WriteParameter*>(&::Pasc::_WriteParameter_default_instance_);
}
inline ::Pasc::WriteParameter* Expression::mutable_wp() {
  if (!has_wp()) {
    clear_expr();
    set_has_wp();
    expr_.wp_ = CreateMaybeMessage< ::Pasc::WriteParameter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.wp)
  return expr_.wp_;
}

// .Pasc.FuncCall fc = 6;
inline bool Expression::has_fc() const {
  return expr_case() == kFc;
}
inline void Expression::set_has_fc() {
  _oneof_case_[0] = kFc;
}
inline void Expression::clear_fc() {
  if (has_fc()) {
    delete expr_.fc_;
    clear_has_expr();
  }
}
inline const ::Pasc::FuncCall& Expression::_internal_fc() const {
  return *expr_.fc_;
}
inline ::Pasc::FuncCall* Expression::release_fc() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.fc)
  if (has_fc()) {
    clear_has_expr();
      ::Pasc::FuncCall* temp = expr_.fc_;
    expr_.fc_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::FuncCall& Expression::fc() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.fc)
  return has_fc()
      ? *expr_.fc_
      : *reinterpret_cast< ::Pasc::FuncCall*>(&::Pasc::_FuncCall_default_instance_);
}
inline ::Pasc::FuncCall* Expression::mutable_fc() {
  if (!has_fc()) {
    clear_expr();
    set_has_fc();
    expr_.fc_ = CreateMaybeMessage< ::Pasc::FuncCall >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.fc)
  return expr_.fc_;
}

inline bool Expression::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void Expression::clear_has_expr() {
  _oneof_case_[0] = EXPR_NOT_SET;
}
inline Expression::ExprCase Expression::expr_case() const {
  return Expression::ExprCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteParameter

// .Pasc.Expression e = 1;
inline bool WriteParameter::has_e() const {
  return this != internal_default_instance() && e_ != NULL;
}
inline void WriteParameter::clear_e() {
  if (GetArenaNoVirtual() == NULL && e_ != NULL) {
    delete e_;
  }
  e_ = NULL;
}
inline const ::Pasc::Expression& WriteParameter::_internal_e() const {
  return *e_;
}
inline const ::Pasc::Expression& WriteParameter::e() const {
  const ::Pasc::Expression* p = e_;
  // @@protoc_insertion_point(field_get:Pasc.WriteParameter.e)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* WriteParameter::release_e() {
  // @@protoc_insertion_point(field_release:Pasc.WriteParameter.e)
  
  ::Pasc::Expression* temp = e_;
  e_ = NULL;
  return temp;
}
inline ::Pasc::Expression* WriteParameter::mutable_e() {
  
  if (e_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    e_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WriteParameter.e)
  return e_;
}
inline void WriteParameter::set_allocated_e(::Pasc::Expression* e) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete e_;
  }
  if (e) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      e = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, e, submessage_arena);
    }
    
  } else {
    
  }
  e_ = e;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WriteParameter.e)
}

// .Pasc.Expression totalWidth = 2;
inline bool WriteParameter::has_totalwidth() const {
  return this != internal_default_instance() && totalwidth_ != NULL;
}
inline void WriteParameter::clear_totalwidth() {
  if (GetArenaNoVirtual() == NULL && totalwidth_ != NULL) {
    delete totalwidth_;
  }
  totalwidth_ = NULL;
}
inline const ::Pasc::Expression& WriteParameter::_internal_totalwidth() const {
  return *totalwidth_;
}
inline const ::Pasc::Expression& WriteParameter::totalwidth() const {
  const ::Pasc::Expression* p = totalwidth_;
  // @@protoc_insertion_point(field_get:Pasc.WriteParameter.totalWidth)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* WriteParameter::release_totalwidth() {
  // @@protoc_insertion_point(field_release:Pasc.WriteParameter.totalWidth)
  
  ::Pasc::Expression* temp = totalwidth_;
  totalwidth_ = NULL;
  return temp;
}
inline ::Pasc::Expression* WriteParameter::mutable_totalwidth() {
  
  if (totalwidth_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    totalwidth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WriteParameter.totalWidth)
  return totalwidth_;
}
inline void WriteParameter::set_allocated_totalwidth(::Pasc::Expression* totalwidth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete totalwidth_;
  }
  if (totalwidth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      totalwidth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, totalwidth, submessage_arena);
    }
    
  } else {
    
  }
  totalwidth_ = totalwidth;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WriteParameter.totalWidth)
}

// .Pasc.Expression fracDigits = 3;
inline bool WriteParameter::has_fracdigits() const {
  return this != internal_default_instance() && fracdigits_ != NULL;
}
inline void WriteParameter::clear_fracdigits() {
  if (GetArenaNoVirtual() == NULL && fracdigits_ != NULL) {
    delete fracdigits_;
  }
  fracdigits_ = NULL;
}
inline const ::Pasc::Expression& WriteParameter::_internal_fracdigits() const {
  return *fracdigits_;
}
inline const ::Pasc::Expression& WriteParameter::fracdigits() const {
  const ::Pasc::Expression* p = fracdigits_;
  // @@protoc_insertion_point(field_get:Pasc.WriteParameter.fracDigits)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* WriteParameter::release_fracdigits() {
  // @@protoc_insertion_point(field_release:Pasc.WriteParameter.fracDigits)
  
  ::Pasc::Expression* temp = fracdigits_;
  fracdigits_ = NULL;
  return temp;
}
inline ::Pasc::Expression* WriteParameter::mutable_fracdigits() {
  
  if (fracdigits_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    fracdigits_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.WriteParameter.fracDigits)
  return fracdigits_;
}
inline void WriteParameter::set_allocated_fracdigits(::Pasc::Expression* fracdigits) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fracdigits_;
  }
  if (fracdigits) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fracdigits = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fracdigits, submessage_arena);
    }
    
  } else {
    
  }
  fracdigits_ = fracdigits;
  // @@protoc_insertion_point(field_set_allocated:Pasc.WriteParameter.fracDigits)
}

// -------------------------------------------------------------------

// BinaryExpr

// .Pasc.Expression left = 1;
inline bool BinaryExpr::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline void BinaryExpr::clear_left() {
  if (GetArenaNoVirtual() == NULL && left_ != NULL) {
    delete left_;
  }
  left_ = NULL;
}
inline const ::Pasc::Expression& BinaryExpr::_internal_left() const {
  return *left_;
}
inline const ::Pasc::Expression& BinaryExpr::left() const {
  const ::Pasc::Expression* p = left_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.left)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* BinaryExpr::release_left() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.left)
  
  ::Pasc::Expression* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::Pasc::Expression* BinaryExpr::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.left)
  return left_;
}
inline void BinaryExpr::set_allocated_left(::Pasc::Expression* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete left_;
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.left)
}

// .Pasc.Expression right = 2;
inline bool BinaryExpr::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline void BinaryExpr::clear_right() {
  if (GetArenaNoVirtual() == NULL && right_ != NULL) {
    delete right_;
  }
  right_ = NULL;
}
inline const ::Pasc::Expression& BinaryExpr::_internal_right() const {
  return *right_;
}
inline const ::Pasc::Expression& BinaryExpr::right() const {
  const ::Pasc::Expression* p = right_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.right)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* BinaryExpr::release_right() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.right)
  
  ::Pasc::Expression* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::Pasc::Expression* BinaryExpr::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.right)
  return right_;
}
inline void BinaryExpr::set_allocated_right(::Pasc::Expression* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete right_;
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.right)
}

// .Pasc.Operator op = 3;
inline bool BinaryExpr::has_op() const {
  return this != internal_default_instance() && op_ != NULL;
}
inline void BinaryExpr::clear_op() {
  if (GetArenaNoVirtual() == NULL && op_ != NULL) {
    delete op_;
  }
  op_ = NULL;
}
inline const ::Pasc::Operator& BinaryExpr::_internal_op() const {
  return *op_;
}
inline const ::Pasc::Operator& BinaryExpr::op() const {
  const ::Pasc::Operator* p = op_;
  // @@protoc_insertion_point(field_get:Pasc.BinaryExpr.op)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Operator*>(
      &::Pasc::_Operator_default_instance_);
}
inline ::Pasc::Operator* BinaryExpr::release_op() {
  // @@protoc_insertion_point(field_release:Pasc.BinaryExpr.op)
  
  ::Pasc::Operator* temp = op_;
  op_ = NULL;
  return temp;
}
inline ::Pasc::Operator* BinaryExpr::mutable_op() {
  
  if (op_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Operator>(GetArenaNoVirtual());
    op_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.BinaryExpr.op)
  return op_;
}
inline void BinaryExpr::set_allocated_op(::Pasc::Operator* op) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete op_;
  }
  if (op) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      op = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, op, submessage_arena);
    }
    
  } else {
    
  }
  op_ = op;
  // @@protoc_insertion_point(field_set_allocated:Pasc.BinaryExpr.op)
}

// -------------------------------------------------------------------

// UIntLiteral

// uint32 value = 1;
inline void UIntLiteral::clear_value() {
  value_ = 0u;
}
inline ::google::protobuf::uint32 UIntLiteral::value() const {
  // @@protoc_insertion_point(field_get:Pasc.UIntLiteral.value)
  return value_;
}
inline void UIntLiteral::set_value(::google::protobuf::uint32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Pasc.UIntLiteral.value)
}

// -------------------------------------------------------------------

// FuncCall

// .Pasc.Expression name = 1;
inline bool FuncCall::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void FuncCall::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Expression& FuncCall::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Expression& FuncCall::name() const {
  const ::Pasc::Expression* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.FuncCall.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* FuncCall::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.FuncCall.name)
  
  ::Pasc::Expression* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Expression* FuncCall::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FuncCall.name)
  return name_;
}
inline void FuncCall::set_allocated_name(::Pasc::Expression* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncCall.name)
}

// repeated .Pasc.Expression args = 2;
inline int FuncCall::args_size() const {
  return args_.size();
}
inline void FuncCall::clear_args() {
  args_.Clear();
}
inline ::Pasc::Expression* FuncCall::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.FuncCall.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
FuncCall::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.FuncCall.args)
  return &args_;
}
inline const ::Pasc::Expression& FuncCall::args(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.FuncCall.args)
  return args_.Get(index);
}
inline ::Pasc::Expression* FuncCall::add_args() {
  // @@protoc_insertion_point(field_add:Pasc.FuncCall.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
FuncCall::args() const {
  // @@protoc_insertion_point(field_list:Pasc.FuncCall.args)
  return args_;
}

// .Pasc.Type returnType = 3;
inline bool FuncCall::has_returntype() const {
  return this != internal_default_instance() && returntype_ != NULL;
}
inline void FuncCall::clear_returntype() {
  if (GetArenaNoVirtual() == NULL && returntype_ != NULL) {
    delete returntype_;
  }
  returntype_ = NULL;
}
inline const ::Pasc::Type& FuncCall::_internal_returntype() const {
  return *returntype_;
}
inline const ::Pasc::Type& FuncCall::returntype() const {
  const ::Pasc::Type* p = returntype_;
  // @@protoc_insertion_point(field_get:Pasc.FuncCall.returnType)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* FuncCall::release_returntype() {
  // @@protoc_insertion_point(field_release:Pasc.FuncCall.returnType)
  
  ::Pasc::Type* temp = returntype_;
  returntype_ = NULL;
  return temp;
}
inline ::Pasc::Type* FuncCall::mutable_returntype() {
  
  if (returntype_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    returntype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.FuncCall.returnType)
  return returntype_;
}
inline void FuncCall::set_allocated_returntype(::Pasc::Type* returntype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete returntype_;
  }
  if (returntype) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      returntype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    
  } else {
    
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:Pasc.FuncCall.returnType)
}

// -------------------------------------------------------------------

// Type_Integer

// string name = 1;
inline void Type_Integer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Integer::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Integer.name)
  return name_.GetNoArena();
}
inline void Type_Integer::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Integer.name)
}
#if LANG_CXX11
inline void Type_Integer::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Integer.name)
}
#endif
inline void Type_Integer::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Integer.name)
}
inline void Type_Integer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Integer.name)
}
inline ::std::string* Type_Integer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Integer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Integer::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Integer.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Integer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Integer.name)
}

// -------------------------------------------------------------------

// Type_Boolean

// string name = 1;
inline void Type_Boolean::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Boolean::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Boolean.name)
  return name_.GetNoArena();
}
inline void Type_Boolean::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Boolean.name)
}
#if LANG_CXX11
inline void Type_Boolean::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Boolean.name)
}
#endif
inline void Type_Boolean::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Boolean.name)
}
inline void Type_Boolean::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Boolean.name)
}
inline ::std::string* Type_Boolean::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Boolean.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Boolean::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Boolean.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Boolean::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Boolean.name)
}

// -------------------------------------------------------------------

// Type_Real

// string name = 1;
inline void Type_Real::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Real::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Real.name)
  return name_.GetNoArena();
}
inline void Type_Real::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Real.name)
}
#if LANG_CXX11
inline void Type_Real::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Real.name)
}
#endif
inline void Type_Real::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Real.name)
}
inline void Type_Real::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Real.name)
}
inline ::std::string* Type_Real::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Real.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Real::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Real.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Real::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Real.name)
}

// -------------------------------------------------------------------

// Type_Char

// string name = 1;
inline void Type_Char::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Char::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Char.name)
  return name_.GetNoArena();
}
inline void Type_Char::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Char.name)
}
#if LANG_CXX11
inline void Type_Char::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Char.name)
}
#endif
inline void Type_Char::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Char.name)
}
inline void Type_Char::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Char.name)
}
inline ::std::string* Type_Char::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Char.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Char::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Char.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Char::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Char.name)
}

// -------------------------------------------------------------------

// Type_Void

// string name = 1;
inline void Type_Void::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Type_Void::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.Void.name)
  return name_.GetNoArena();
}
inline void Type_Void::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Type.Void.name)
}
#if LANG_CXX11
inline void Type_Void::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Type.Void.name)
}
#endif
inline void Type_Void::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Type.Void.name)
}
inline void Type_Void::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Type.Void.name)
}
inline ::std::string* Type_Void::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Type.Void.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Type_Void::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Type.Void.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Type_Void::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Type.Void.name)
}

// -------------------------------------------------------------------

// Type

// .Pasc.Type.TypeKind tk = 1;
inline void Type::clear_tk() {
  tk_ = 0;
}
inline ::Pasc::Type_TypeKind Type::tk() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.tk)
  return static_cast< ::Pasc::Type_TypeKind >(tk_);
}
inline void Type::set_tk(::Pasc::Type_TypeKind value) {
  
  tk_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Type.tk)
}

// .Pasc.Type.Integer int = 2;
inline bool Type::has_int_() const {
  return type_case() == kInt;
}
inline void Type::set_has_int_() {
  _oneof_case_[0] = kInt;
}
inline void Type::clear_int_() {
  if (has_int_()) {
    delete type_.int__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Integer& Type::_internal_int_() const {
  return *type_.int__;
}
inline ::Pasc::Type_Integer* Type::release_int_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.int)
  if (has_int_()) {
    clear_has_type();
      ::Pasc::Type_Integer* temp = type_.int__;
    type_.int__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Integer& Type::int_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.int)
  return has_int_()
      ? *type_.int__
      : *reinterpret_cast< ::Pasc::Type_Integer*>(&::Pasc::_Type_Integer_default_instance_);
}
inline ::Pasc::Type_Integer* Type::mutable_int_() {
  if (!has_int_()) {
    clear_type();
    set_has_int_();
    type_.int__ = CreateMaybeMessage< ::Pasc::Type_Integer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.int)
  return type_.int__;
}

// .Pasc.Type.Real real = 3;
inline bool Type::has_real() const {
  return type_case() == kReal;
}
inline void Type::set_has_real() {
  _oneof_case_[0] = kReal;
}
inline void Type::clear_real() {
  if (has_real()) {
    delete type_.real_;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Real& Type::_internal_real() const {
  return *type_.real_;
}
inline ::Pasc::Type_Real* Type::release_real() {
  // @@protoc_insertion_point(field_release:Pasc.Type.real)
  if (has_real()) {
    clear_has_type();
      ::Pasc::Type_Real* temp = type_.real_;
    type_.real_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Real& Type::real() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.real)
  return has_real()
      ? *type_.real_
      : *reinterpret_cast< ::Pasc::Type_Real*>(&::Pasc::_Type_Real_default_instance_);
}
inline ::Pasc::Type_Real* Type::mutable_real() {
  if (!has_real()) {
    clear_type();
    set_has_real();
    type_.real_ = CreateMaybeMessage< ::Pasc::Type_Real >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.real)
  return type_.real_;
}

// .Pasc.Type.Boolean bool = 4;
inline bool Type::has_bool_() const {
  return type_case() == kBool;
}
inline void Type::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void Type::clear_bool_() {
  if (has_bool_()) {
    delete type_.bool__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Boolean& Type::_internal_bool_() const {
  return *type_.bool__;
}
inline ::Pasc::Type_Boolean* Type::release_bool_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.bool)
  if (has_bool_()) {
    clear_has_type();
      ::Pasc::Type_Boolean* temp = type_.bool__;
    type_.bool__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Boolean& Type::bool_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.bool)
  return has_bool_()
      ? *type_.bool__
      : *reinterpret_cast< ::Pasc::Type_Boolean*>(&::Pasc::_Type_Boolean_default_instance_);
}
inline ::Pasc::Type_Boolean* Type::mutable_bool_() {
  if (!has_bool_()) {
    clear_type();
    set_has_bool_();
    type_.bool__ = CreateMaybeMessage< ::Pasc::Type_Boolean >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.bool)
  return type_.bool__;
}

// .Pasc.Type.Char char = 5;
inline bool Type::has_char_() const {
  return type_case() == kChar;
}
inline void Type::set_has_char_() {
  _oneof_case_[0] = kChar;
}
inline void Type::clear_char_() {
  if (has_char_()) {
    delete type_.char__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Char& Type::_internal_char_() const {
  return *type_.char__;
}
inline ::Pasc::Type_Char* Type::release_char_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.char)
  if (has_char_()) {
    clear_has_type();
      ::Pasc::Type_Char* temp = type_.char__;
    type_.char__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Char& Type::char_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.char)
  return has_char_()
      ? *type_.char__
      : *reinterpret_cast< ::Pasc::Type_Char*>(&::Pasc::_Type_Char_default_instance_);
}
inline ::Pasc::Type_Char* Type::mutable_char_() {
  if (!has_char_()) {
    clear_type();
    set_has_char_();
    type_.char__ = CreateMaybeMessage< ::Pasc::Type_Char >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.char)
  return type_.char__;
}

// .Pasc.Type.Void void = 6;
inline bool Type::has_void_() const {
  return type_case() == kVoid;
}
inline void Type::set_has_void_() {
  _oneof_case_[0] = kVoid;
}
inline void Type::clear_void_() {
  if (has_void_()) {
    delete type_.void__;
    clear_has_type();
  }
}
inline const ::Pasc::Type_Void& Type::_internal_void_() const {
  return *type_.void__;
}
inline ::Pasc::Type_Void* Type::release_void_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.void)
  if (has_void_()) {
    clear_has_type();
      ::Pasc::Type_Void* temp = type_.void__;
    type_.void__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Type_Void& Type::void_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.void)
  return has_void_()
      ? *type_.void__
      : *reinterpret_cast< ::Pasc::Type_Void*>(&::Pasc::_Type_Void_default_instance_);
}
inline ::Pasc::Type_Void* Type::mutable_void_() {
  if (!has_void_()) {
    clear_type();
    set_has_void_();
    type_.void__ = CreateMaybeMessage< ::Pasc::Type_Void >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.void)
  return type_.void__;
}

inline bool Type::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Type::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Type::TypeCase Type::type_case() const {
  return Type::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Operator

// .Pasc.Operator.OpKind op = 1;
inline void Operator::clear_op() {
  op_ = 0;
}
inline ::Pasc::Operator_OpKind Operator::op() const {
  // @@protoc_insertion_point(field_get:Pasc.Operator.op)
  return static_cast< ::Pasc::Operator_OpKind >(op_);
}
inline void Operator::set_op(::Pasc::Operator_OpKind value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Operator.op)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pasc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pasc::Callable_CallKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Callable_CallKind>() {
  return ::Pasc::Callable_CallKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::FormalParameter_FPKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::FormalParameter_FPKind>() {
  return ::Pasc::FormalParameter_FPKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::ProcedureStatement_PSKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::ProcedureStatement_PSKind>() {
  return ::Pasc::ProcedureStatement_PSKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Statement_StmtKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Statement_StmtKind>() {
  return ::Pasc::Statement_StmtKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Identifier_IDKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Identifier_IDKind>() {
  return ::Pasc::Identifier_IDKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Expression_ExprKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Expression_ExprKind>() {
  return ::Pasc::Expression_ExprKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Type_TypeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Type_TypeKind>() {
  return ::Pasc::Type_TypeKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::Operator_OpKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::Operator_OpKind>() {
  return ::Pasc::Operator_OpKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::TokenKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::TokenKind>() {
  return ::Pasc::TokenKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_program_2eproto
