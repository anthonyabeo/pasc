// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: program.proto

#ifndef PROTOBUF_INCLUDED_program_2eproto
#define PROTOBUF_INCLUDED_program_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_program_2eproto 

namespace protobuf_program_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_program_2eproto
namespace Pasc {
class AssignStmt;
class AssignStmtDefaultTypeInternal;
extern AssignStmtDefaultTypeInternal _AssignStmt_default_instance_;
class Block;
class BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class Boolean;
class BooleanDefaultTypeInternal;
extern BooleanDefaultTypeInternal _Boolean_default_instance_;
class Char;
class CharDefaultTypeInternal;
extern CharDefaultTypeInternal _Char_default_instance_;
class Expression;
class ExpressionDefaultTypeInternal;
extern ExpressionDefaultTypeInternal _Expression_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class Integer;
class IntegerDefaultTypeInternal;
extern IntegerDefaultTypeInternal _Integer_default_instance_;
class ProcedureStmt;
class ProcedureStmtDefaultTypeInternal;
extern ProcedureStmtDefaultTypeInternal _ProcedureStmt_default_instance_;
class Program;
class ProgramDefaultTypeInternal;
extern ProgramDefaultTypeInternal _Program_default_instance_;
class Real;
class RealDefaultTypeInternal;
extern RealDefaultTypeInternal _Real_default_instance_;
class Statement;
class StatementDefaultTypeInternal;
extern StatementDefaultTypeInternal _Statement_default_instance_;
class Type;
class TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
class UIntLiteral;
class UIntLiteralDefaultTypeInternal;
extern UIntLiteralDefaultTypeInternal _UIntLiteral_default_instance_;
class VarDeclaration;
class VarDeclarationDefaultTypeInternal;
extern VarDeclarationDefaultTypeInternal _VarDeclaration_default_instance_;
}  // namespace Pasc
namespace google {
namespace protobuf {
template<> ::Pasc::AssignStmt* Arena::CreateMaybeMessage<::Pasc::AssignStmt>(Arena*);
template<> ::Pasc::Block* Arena::CreateMaybeMessage<::Pasc::Block>(Arena*);
template<> ::Pasc::Boolean* Arena::CreateMaybeMessage<::Pasc::Boolean>(Arena*);
template<> ::Pasc::Char* Arena::CreateMaybeMessage<::Pasc::Char>(Arena*);
template<> ::Pasc::Expression* Arena::CreateMaybeMessage<::Pasc::Expression>(Arena*);
template<> ::Pasc::Identifier* Arena::CreateMaybeMessage<::Pasc::Identifier>(Arena*);
template<> ::Pasc::Integer* Arena::CreateMaybeMessage<::Pasc::Integer>(Arena*);
template<> ::Pasc::ProcedureStmt* Arena::CreateMaybeMessage<::Pasc::ProcedureStmt>(Arena*);
template<> ::Pasc::Program* Arena::CreateMaybeMessage<::Pasc::Program>(Arena*);
template<> ::Pasc::Real* Arena::CreateMaybeMessage<::Pasc::Real>(Arena*);
template<> ::Pasc::Statement* Arena::CreateMaybeMessage<::Pasc::Statement>(Arena*);
template<> ::Pasc::Type* Arena::CreateMaybeMessage<::Pasc::Type>(Arena*);
template<> ::Pasc::UIntLiteral* Arena::CreateMaybeMessage<::Pasc::UIntLiteral>(Arena*);
template<> ::Pasc::VarDeclaration* Arena::CreateMaybeMessage<::Pasc::VarDeclaration>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Pasc {

enum TokenKind {
  PROGRAM = 0,
  ASSIGN = 1,
  IDENTIFIER = 2,
  UINTLIT = 3,
  TokenKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TokenKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TokenKind_IsValid(int value);
const TokenKind TokenKind_MIN = PROGRAM;
const TokenKind TokenKind_MAX = UINTLIT;
const int TokenKind_ARRAYSIZE = TokenKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TokenKind_descriptor();
inline const ::std::string& TokenKind_Name(TokenKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TokenKind_descriptor(), value);
}
inline bool TokenKind_Parse(
    const ::std::string& name, TokenKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TokenKind>(
    TokenKind_descriptor(), name, value);
}
enum TypeKind {
  INTEGER = 0,
  REAL = 1,
  BOOLEAN = 2,
  CHAR = 3,
  TypeKind_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TypeKind_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TypeKind_IsValid(int value);
const TypeKind TypeKind_MIN = INTEGER;
const TypeKind TypeKind_MAX = CHAR;
const int TypeKind_ARRAYSIZE = TypeKind_MAX + 1;

const ::google::protobuf::EnumDescriptor* TypeKind_descriptor();
inline const ::std::string& TypeKind_Name(TypeKind value) {
  return ::google::protobuf::internal::NameOfEnum(
    TypeKind_descriptor(), value);
}
inline bool TypeKind_Parse(
    const ::std::string& name, TypeKind* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TypeKind>(
    TypeKind_descriptor(), name, value);
}
// ===================================================================

class Program : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Program) */ {
 public:
  Program();
  virtual ~Program();

  Program(const Program& from);

  inline Program& operator=(const Program& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Program(Program&& from) noexcept
    : Program() {
    *this = ::std::move(from);
  }

  inline Program& operator=(Program&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Program& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Program* internal_default_instance() {
    return reinterpret_cast<const Program*>(
               &_Program_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Program* other);
  friend void swap(Program& a, Program& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Program* New() const final {
    return CreateMaybeMessage<Program>(NULL);
  }

  Program* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Program>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Program& from);
  void MergeFrom(const Program& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Program* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string params = 3;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 3;
  const ::std::string& params(int index) const;
  ::std::string* mutable_params(int index);
  void set_params(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_params(int index, ::std::string&& value);
  #endif
  void set_params(int index, const char* value);
  void set_params(int index, const char* value, size_t size);
  ::std::string* add_params();
  void add_params(const ::std::string& value);
  #if LANG_CXX11
  void add_params(::std::string&& value);
  #endif
  void add_params(const char* value);
  void add_params(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& params() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_params();

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .Pasc.Block block = 4;
  bool has_block() const;
  void clear_block();
  static const int kBlockFieldNumber = 4;
  private:
  const ::Pasc::Block& _internal_block() const;
  public:
  const ::Pasc::Block& block() const;
  ::Pasc::Block* release_block();
  ::Pasc::Block* mutable_block();
  void set_allocated_block(::Pasc::Block* block);

  // .Pasc.TokenKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::TokenKind kind() const;
  void set_kind(::Pasc::TokenKind value);

  // @@protoc_insertion_point(class_scope:Pasc.Program)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> params_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Pasc::Block* block_;
  int kind_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Block) */ {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(Block&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Block* other);
  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return CreateMaybeMessage<Block>(NULL);
  }

  Block* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.VarDeclaration varDeclrs = 1;
  int vardeclrs_size() const;
  void clear_vardeclrs();
  static const int kVarDeclrsFieldNumber = 1;
  ::Pasc::VarDeclaration* mutable_vardeclrs(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >*
      mutable_vardeclrs();
  const ::Pasc::VarDeclaration& vardeclrs(int index) const;
  ::Pasc::VarDeclaration* add_vardeclrs();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >&
      vardeclrs() const;

  // repeated .Pasc.Statement stmts = 2;
  int stmts_size() const;
  void clear_stmts();
  static const int kStmtsFieldNumber = 2;
  ::Pasc::Statement* mutable_stmts(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
      mutable_stmts();
  const ::Pasc::Statement& stmts(int index) const;
  ::Pasc::Statement* add_stmts();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
      stmts() const;

  // @@protoc_insertion_point(class_scope:Pasc.Block)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration > vardeclrs_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Statement > stmts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VarDeclaration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.VarDeclaration) */ {
 public:
  VarDeclaration();
  virtual ~VarDeclaration();

  VarDeclaration(const VarDeclaration& from);

  inline VarDeclaration& operator=(const VarDeclaration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VarDeclaration(VarDeclaration&& from) noexcept
    : VarDeclaration() {
    *this = ::std::move(from);
  }

  inline VarDeclaration& operator=(VarDeclaration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const VarDeclaration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VarDeclaration* internal_default_instance() {
    return reinterpret_cast<const VarDeclaration*>(
               &_VarDeclaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(VarDeclaration* other);
  friend void swap(VarDeclaration& a, VarDeclaration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VarDeclaration* New() const final {
    return CreateMaybeMessage<VarDeclaration>(NULL);
  }

  VarDeclaration* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VarDeclaration>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VarDeclaration& from);
  void MergeFrom(const VarDeclaration& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VarDeclaration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Identifier name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Identifier& _internal_name() const;
  public:
  const ::Pasc::Identifier& name() const;
  ::Pasc::Identifier* release_name();
  ::Pasc::Identifier* mutable_name();
  void set_allocated_name(::Pasc::Identifier* name);

  // .Pasc.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  private:
  const ::Pasc::Type& _internal_type() const;
  public:
  const ::Pasc::Type& type() const;
  ::Pasc::Type* release_type();
  ::Pasc::Type* mutable_type();
  void set_allocated_type(::Pasc::Type* type);

  // @@protoc_insertion_point(class_scope:Pasc.VarDeclaration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Identifier* name_;
  ::Pasc::Type* type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssignStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.AssignStmt) */ {
 public:
  AssignStmt();
  virtual ~AssignStmt();

  AssignStmt(const AssignStmt& from);

  inline AssignStmt& operator=(const AssignStmt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssignStmt(AssignStmt&& from) noexcept
    : AssignStmt() {
    *this = ::std::move(from);
  }

  inline AssignStmt& operator=(AssignStmt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AssignStmt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssignStmt* internal_default_instance() {
    return reinterpret_cast<const AssignStmt*>(
               &_AssignStmt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AssignStmt* other);
  friend void swap(AssignStmt& a, AssignStmt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssignStmt* New() const final {
    return CreateMaybeMessage<AssignStmt>(NULL);
  }

  AssignStmt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssignStmt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssignStmt& from);
  void MergeFrom(const AssignStmt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssignStmt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.Identifier variable = 1;
  bool has_variable() const;
  void clear_variable();
  static const int kVariableFieldNumber = 1;
  private:
  const ::Pasc::Identifier& _internal_variable() const;
  public:
  const ::Pasc::Identifier& variable() const;
  ::Pasc::Identifier* release_variable();
  ::Pasc::Identifier* mutable_variable();
  void set_allocated_variable(::Pasc::Identifier* variable);

  // .Pasc.Expression value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::Pasc::Expression& _internal_value() const;
  public:
  const ::Pasc::Expression& value() const;
  ::Pasc::Expression* release_value();
  ::Pasc::Expression* mutable_value();
  void set_allocated_value(::Pasc::Expression* value);

  // @@protoc_insertion_point(class_scope:Pasc.AssignStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Pasc::Identifier* variable_;
  ::Pasc::Expression* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProcedureStmt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.ProcedureStmt) */ {
 public:
  ProcedureStmt();
  virtual ~ProcedureStmt();

  ProcedureStmt(const ProcedureStmt& from);

  inline ProcedureStmt& operator=(const ProcedureStmt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcedureStmt(ProcedureStmt&& from) noexcept
    : ProcedureStmt() {
    *this = ::std::move(from);
  }

  inline ProcedureStmt& operator=(ProcedureStmt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStmt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureStmt* internal_default_instance() {
    return reinterpret_cast<const ProcedureStmt*>(
               &_ProcedureStmt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProcedureStmt* other);
  friend void swap(ProcedureStmt& a, ProcedureStmt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcedureStmt* New() const final {
    return CreateMaybeMessage<ProcedureStmt>(NULL);
  }

  ProcedureStmt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureStmt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProcedureStmt& from);
  void MergeFrom(const ProcedureStmt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureStmt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Pasc.Expression args = 2;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 2;
  ::Pasc::Expression* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
      mutable_args();
  const ::Pasc::Expression& args(int index) const;
  ::Pasc::Expression* add_args();
  const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
      args() const;

  // .Pasc.Identifier name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  private:
  const ::Pasc::Identifier& _internal_name() const;
  public:
  const ::Pasc::Identifier& name() const;
  ::Pasc::Identifier* release_name();
  ::Pasc::Identifier* mutable_name();
  void set_allocated_name(::Pasc::Identifier* name);

  // @@protoc_insertion_point(class_scope:Pasc.ProcedureStmt)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Pasc::Expression > args_;
  ::Pasc::Identifier* name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Statement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Statement) */ {
 public:
  Statement();
  virtual ~Statement();

  Statement(const Statement& from);

  inline Statement& operator=(const Statement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Statement(Statement&& from) noexcept
    : Statement() {
    *this = ::std::move(from);
  }

  inline Statement& operator=(Statement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Statement& default_instance();

  enum StmtCase {
    kAssignStmt = 2,
    kProcStmt = 3,
    STMT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Statement* internal_default_instance() {
    return reinterpret_cast<const Statement*>(
               &_Statement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Statement* other);
  friend void swap(Statement& a, Statement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Statement* New() const final {
    return CreateMaybeMessage<Statement>(NULL);
  }

  Statement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Statement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Statement& from);
  void MergeFrom(const Statement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Statement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.TokenKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::TokenKind kind() const;
  void set_kind(::Pasc::TokenKind value);

  // .Pasc.AssignStmt assignStmt = 2;
  bool has_assignstmt() const;
  void clear_assignstmt();
  static const int kAssignStmtFieldNumber = 2;
  private:
  const ::Pasc::AssignStmt& _internal_assignstmt() const;
  public:
  const ::Pasc::AssignStmt& assignstmt() const;
  ::Pasc::AssignStmt* release_assignstmt();
  ::Pasc::AssignStmt* mutable_assignstmt();
  void set_allocated_assignstmt(::Pasc::AssignStmt* assignstmt);

  // .Pasc.ProcedureStmt procStmt = 3;
  bool has_procstmt() const;
  void clear_procstmt();
  static const int kProcStmtFieldNumber = 3;
  private:
  const ::Pasc::ProcedureStmt& _internal_procstmt() const;
  public:
  const ::Pasc::ProcedureStmt& procstmt() const;
  ::Pasc::ProcedureStmt* release_procstmt();
  ::Pasc::ProcedureStmt* mutable_procstmt();
  void set_allocated_procstmt(::Pasc::ProcedureStmt* procstmt);

  void clear_stmt();
  StmtCase stmt_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Statement)
 private:
  void set_has_assignstmt();
  void set_has_procstmt();

  inline bool has_stmt() const;
  inline void clear_has_stmt();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union StmtUnion {
    StmtUnion() {}
    ::Pasc::AssignStmt* assignstmt_;
    ::Pasc::ProcedureStmt* procstmt_;
  } stmt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Expression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Expression) */ {
 public:
  Expression();
  virtual ~Expression();

  Expression(const Expression& from);

  inline Expression& operator=(const Expression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expression(Expression&& from) noexcept
    : Expression() {
    *this = ::std::move(from);
  }

  inline Expression& operator=(Expression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Expression& default_instance();

  enum ExprCase {
    kId = 2,
    kUint = 3,
    EXPR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expression* internal_default_instance() {
    return reinterpret_cast<const Expression*>(
               &_Expression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Expression* other);
  friend void swap(Expression& a, Expression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expression* New() const final {
    return CreateMaybeMessage<Expression>(NULL);
  }

  Expression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Expression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Expression& from);
  void MergeFrom(const Expression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Expression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.TokenKind kind = 1;
  void clear_kind();
  static const int kKindFieldNumber = 1;
  ::Pasc::TokenKind kind() const;
  void set_kind(::Pasc::TokenKind value);

  // .Pasc.Identifier id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  private:
  const ::Pasc::Identifier& _internal_id() const;
  public:
  const ::Pasc::Identifier& id() const;
  ::Pasc::Identifier* release_id();
  ::Pasc::Identifier* mutable_id();
  void set_allocated_id(::Pasc::Identifier* id);

  // .Pasc.UIntLiteral uint = 3;
  bool has_uint() const;
  void clear_uint();
  static const int kUintFieldNumber = 3;
  private:
  const ::Pasc::UIntLiteral& _internal_uint() const;
  public:
  const ::Pasc::UIntLiteral& uint() const;
  ::Pasc::UIntLiteral* release_uint();
  ::Pasc::UIntLiteral* mutable_uint();
  void set_allocated_uint(::Pasc::UIntLiteral* uint);

  void clear_expr();
  ExprCase expr_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Expression)
 private:
  void set_has_id();
  void set_has_uint();

  inline bool has_expr() const;
  inline void clear_has_expr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int kind_;
  union ExprUnion {
    ExprUnion() {}
    ::Pasc::Identifier* id_;
    ::Pasc::UIntLiteral* uint_;
  } expr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Identifier : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(NULL);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Identifier)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UIntLiteral : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.UIntLiteral) */ {
 public:
  UIntLiteral();
  virtual ~UIntLiteral();

  UIntLiteral(const UIntLiteral& from);

  inline UIntLiteral& operator=(const UIntLiteral& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UIntLiteral(UIntLiteral&& from) noexcept
    : UIntLiteral() {
    *this = ::std::move(from);
  }

  inline UIntLiteral& operator=(UIntLiteral&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UIntLiteral& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UIntLiteral* internal_default_instance() {
    return reinterpret_cast<const UIntLiteral*>(
               &_UIntLiteral_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(UIntLiteral* other);
  friend void swap(UIntLiteral& a, UIntLiteral& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UIntLiteral* New() const final {
    return CreateMaybeMessage<UIntLiteral>(NULL);
  }

  UIntLiteral* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UIntLiteral>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UIntLiteral& from);
  void MergeFrom(const UIntLiteral& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIntLiteral* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 value = 1;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Pasc.UIntLiteral)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Type) */ {
 public:
  Type();
  virtual ~Type();

  Type(const Type& from);

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(Type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Type& default_instance();

  enum TypeCase {
    kInt = 2,
    kReal = 3,
    kBool = 4,
    kChar = 5,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Type* other);
  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Type* New() const final {
    return CreateMaybeMessage<Type>(NULL);
  }

  Type* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Type& from);
  void MergeFrom(const Type& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Pasc.TypeKind tk = 1;
  void clear_tk();
  static const int kTkFieldNumber = 1;
  ::Pasc::TypeKind tk() const;
  void set_tk(::Pasc::TypeKind value);

  // .Pasc.Integer int = 2;
  bool has_int_() const;
  void clear_int_();
  static const int kIntFieldNumber = 2;
  private:
  const ::Pasc::Integer& _internal_int_() const;
  public:
  const ::Pasc::Integer& int_() const;
  ::Pasc::Integer* release_int_();
  ::Pasc::Integer* mutable_int_();
  void set_allocated_int_(::Pasc::Integer* int_);

  // .Pasc.Real real = 3;
  bool has_real() const;
  void clear_real();
  static const int kRealFieldNumber = 3;
  private:
  const ::Pasc::Real& _internal_real() const;
  public:
  const ::Pasc::Real& real() const;
  ::Pasc::Real* release_real();
  ::Pasc::Real* mutable_real();
  void set_allocated_real(::Pasc::Real* real);

  // .Pasc.Boolean bool = 4;
  bool has_bool_() const;
  void clear_bool_();
  static const int kBoolFieldNumber = 4;
  private:
  const ::Pasc::Boolean& _internal_bool_() const;
  public:
  const ::Pasc::Boolean& bool_() const;
  ::Pasc::Boolean* release_bool_();
  ::Pasc::Boolean* mutable_bool_();
  void set_allocated_bool_(::Pasc::Boolean* bool_);

  // .Pasc.Char char = 5;
  bool has_char_() const;
  void clear_char_();
  static const int kCharFieldNumber = 5;
  private:
  const ::Pasc::Char& _internal_char_() const;
  public:
  const ::Pasc::Char& char_() const;
  ::Pasc::Char* release_char_();
  ::Pasc::Char* mutable_char_();
  void set_allocated_char_(::Pasc::Char* char_);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:Pasc.Type)
 private:
  void set_has_int_();
  void set_has_real();
  void set_has_bool_();
  void set_has_char_();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int tk_;
  union TypeUnion {
    TypeUnion() {}
    ::Pasc::Integer* int__;
    ::Pasc::Real* real_;
    ::Pasc::Boolean* bool__;
    ::Pasc::Char* char__;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Integer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Integer) */ {
 public:
  Integer();
  virtual ~Integer();

  Integer(const Integer& from);

  inline Integer& operator=(const Integer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Integer(Integer&& from) noexcept
    : Integer() {
    *this = ::std::move(from);
  }

  inline Integer& operator=(Integer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Integer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Integer* internal_default_instance() {
    return reinterpret_cast<const Integer*>(
               &_Integer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Integer* other);
  friend void swap(Integer& a, Integer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Integer* New() const final {
    return CreateMaybeMessage<Integer>(NULL);
  }

  Integer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Integer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Integer& from);
  void MergeFrom(const Integer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Integer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Integer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Boolean : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Boolean) */ {
 public:
  Boolean();
  virtual ~Boolean();

  Boolean(const Boolean& from);

  inline Boolean& operator=(const Boolean& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Boolean(Boolean&& from) noexcept
    : Boolean() {
    *this = ::std::move(from);
  }

  inline Boolean& operator=(Boolean&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Boolean& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Boolean* internal_default_instance() {
    return reinterpret_cast<const Boolean*>(
               &_Boolean_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Boolean* other);
  friend void swap(Boolean& a, Boolean& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Boolean* New() const final {
    return CreateMaybeMessage<Boolean>(NULL);
  }

  Boolean* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Boolean>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Boolean& from);
  void MergeFrom(const Boolean& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Boolean* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Boolean)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Real : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Real) */ {
 public:
  Real();
  virtual ~Real();

  Real(const Real& from);

  inline Real& operator=(const Real& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Real(Real&& from) noexcept
    : Real() {
    *this = ::std::move(from);
  }

  inline Real& operator=(Real&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Real& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Real* internal_default_instance() {
    return reinterpret_cast<const Real*>(
               &_Real_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Real* other);
  friend void swap(Real& a, Real& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Real* New() const final {
    return CreateMaybeMessage<Real>(NULL);
  }

  Real* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Real>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Real& from);
  void MergeFrom(const Real& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Real* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Real)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Char : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Pasc.Char) */ {
 public:
  Char();
  virtual ~Char();

  Char(const Char& from);

  inline Char& operator=(const Char& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Char(Char&& from) noexcept
    : Char() {
    *this = ::std::move(from);
  }

  inline Char& operator=(Char&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Char& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Char* internal_default_instance() {
    return reinterpret_cast<const Char*>(
               &_Char_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Char* other);
  friend void swap(Char& a, Char& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Char* New() const final {
    return CreateMaybeMessage<Char>(NULL);
  }

  Char* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Char>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Char& from);
  void MergeFrom(const Char& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Char* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Pasc.Char)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_program_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Program

// .Pasc.TokenKind kind = 1;
inline void Program::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::TokenKind Program::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Program.kind)
  return static_cast< ::Pasc::TokenKind >(kind_);
}
inline void Program::set_kind(::Pasc::TokenKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Program.kind)
}

// string name = 2;
inline void Program::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Program::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Program.name)
  return name_.GetNoArena();
}
inline void Program::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Program.name)
}
#if LANG_CXX11
inline void Program::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Program.name)
}
#endif
inline void Program::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Program.name)
}
inline void Program::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Program.name)
}
inline ::std::string* Program::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Program.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Program::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Program.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Program::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Program.name)
}

// repeated string params = 3;
inline int Program::params_size() const {
  return params_.size();
}
inline void Program::clear_params() {
  params_.Clear();
}
inline const ::std::string& Program::params(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Program.params)
  return params_.Get(index);
}
inline ::std::string* Program::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Program.params)
  return params_.Mutable(index);
}
inline void Program::set_params(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Pasc.Program.params)
  params_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Program::set_params(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Pasc.Program.params)
  params_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Program::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Pasc.Program.params)
}
inline void Program::set_params(int index, const char* value, size_t size) {
  params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Pasc.Program.params)
}
inline ::std::string* Program::add_params() {
  // @@protoc_insertion_point(field_add_mutable:Pasc.Program.params)
  return params_.Add();
}
inline void Program::add_params(const ::std::string& value) {
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Pasc.Program.params)
}
#if LANG_CXX11
inline void Program::add_params(::std::string&& value) {
  params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Pasc.Program.params)
}
#endif
inline void Program::add_params(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Pasc.Program.params)
}
inline void Program::add_params(const char* value, size_t size) {
  params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Pasc.Program.params)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Program::params() const {
  // @@protoc_insertion_point(field_list:Pasc.Program.params)
  return params_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Program::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Program.params)
  return &params_;
}

// .Pasc.Block block = 4;
inline bool Program::has_block() const {
  return this != internal_default_instance() && block_ != NULL;
}
inline void Program::clear_block() {
  if (GetArenaNoVirtual() == NULL && block_ != NULL) {
    delete block_;
  }
  block_ = NULL;
}
inline const ::Pasc::Block& Program::_internal_block() const {
  return *block_;
}
inline const ::Pasc::Block& Program::block() const {
  const ::Pasc::Block* p = block_;
  // @@protoc_insertion_point(field_get:Pasc.Program.block)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Block*>(
      &::Pasc::_Block_default_instance_);
}
inline ::Pasc::Block* Program::release_block() {
  // @@protoc_insertion_point(field_release:Pasc.Program.block)
  
  ::Pasc::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline ::Pasc::Block* Program::mutable_block() {
  
  if (block_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Block>(GetArenaNoVirtual());
    block_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Program.block)
  return block_;
}
inline void Program::set_allocated_block(::Pasc::Block* block) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete block_;
  }
  if (block) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      block = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:Pasc.Program.block)
}

// -------------------------------------------------------------------

// Block

// repeated .Pasc.VarDeclaration varDeclrs = 1;
inline int Block::vardeclrs_size() const {
  return vardeclrs_.size();
}
inline void Block::clear_vardeclrs() {
  vardeclrs_.Clear();
}
inline ::Pasc::VarDeclaration* Block::mutable_vardeclrs(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Block.varDeclrs)
  return vardeclrs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >*
Block::mutable_vardeclrs() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Block.varDeclrs)
  return &vardeclrs_;
}
inline const ::Pasc::VarDeclaration& Block::vardeclrs(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Block.varDeclrs)
  return vardeclrs_.Get(index);
}
inline ::Pasc::VarDeclaration* Block::add_vardeclrs() {
  // @@protoc_insertion_point(field_add:Pasc.Block.varDeclrs)
  return vardeclrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::VarDeclaration >&
Block::vardeclrs() const {
  // @@protoc_insertion_point(field_list:Pasc.Block.varDeclrs)
  return vardeclrs_;
}

// repeated .Pasc.Statement stmts = 2;
inline int Block::stmts_size() const {
  return stmts_.size();
}
inline void Block::clear_stmts() {
  stmts_.Clear();
}
inline ::Pasc::Statement* Block::mutable_stmts(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.Block.stmts)
  return stmts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >*
Block::mutable_stmts() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.Block.stmts)
  return &stmts_;
}
inline const ::Pasc::Statement& Block::stmts(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.Block.stmts)
  return stmts_.Get(index);
}
inline ::Pasc::Statement* Block::add_stmts() {
  // @@protoc_insertion_point(field_add:Pasc.Block.stmts)
  return stmts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Statement >&
Block::stmts() const {
  // @@protoc_insertion_point(field_list:Pasc.Block.stmts)
  return stmts_;
}

// -------------------------------------------------------------------

// VarDeclaration

// .Pasc.Identifier name = 1;
inline bool VarDeclaration::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void VarDeclaration::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Identifier& VarDeclaration::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Identifier& VarDeclaration::name() const {
  const ::Pasc::Identifier* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.VarDeclaration.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Identifier*>(
      &::Pasc::_Identifier_default_instance_);
}
inline ::Pasc::Identifier* VarDeclaration::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.VarDeclaration.name)
  
  ::Pasc::Identifier* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Identifier* VarDeclaration::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Identifier>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.VarDeclaration.name)
  return name_;
}
inline void VarDeclaration::set_allocated_name(::Pasc::Identifier* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.VarDeclaration.name)
}

// .Pasc.Type type = 2;
inline bool VarDeclaration::has_type() const {
  return this != internal_default_instance() && type_ != NULL;
}
inline void VarDeclaration::clear_type() {
  if (GetArenaNoVirtual() == NULL && type_ != NULL) {
    delete type_;
  }
  type_ = NULL;
}
inline const ::Pasc::Type& VarDeclaration::_internal_type() const {
  return *type_;
}
inline const ::Pasc::Type& VarDeclaration::type() const {
  const ::Pasc::Type* p = type_;
  // @@protoc_insertion_point(field_get:Pasc.VarDeclaration.type)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Type*>(
      &::Pasc::_Type_default_instance_);
}
inline ::Pasc::Type* VarDeclaration::release_type() {
  // @@protoc_insertion_point(field_release:Pasc.VarDeclaration.type)
  
  ::Pasc::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline ::Pasc::Type* VarDeclaration::mutable_type() {
  
  if (type_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Type>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.VarDeclaration.type)
  return type_;
}
inline void VarDeclaration::set_allocated_type(::Pasc::Type* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:Pasc.VarDeclaration.type)
}

// -------------------------------------------------------------------

// AssignStmt

// .Pasc.Identifier variable = 1;
inline bool AssignStmt::has_variable() const {
  return this != internal_default_instance() && variable_ != NULL;
}
inline void AssignStmt::clear_variable() {
  if (GetArenaNoVirtual() == NULL && variable_ != NULL) {
    delete variable_;
  }
  variable_ = NULL;
}
inline const ::Pasc::Identifier& AssignStmt::_internal_variable() const {
  return *variable_;
}
inline const ::Pasc::Identifier& AssignStmt::variable() const {
  const ::Pasc::Identifier* p = variable_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStmt.variable)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Identifier*>(
      &::Pasc::_Identifier_default_instance_);
}
inline ::Pasc::Identifier* AssignStmt::release_variable() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStmt.variable)
  
  ::Pasc::Identifier* temp = variable_;
  variable_ = NULL;
  return temp;
}
inline ::Pasc::Identifier* AssignStmt::mutable_variable() {
  
  if (variable_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Identifier>(GetArenaNoVirtual());
    variable_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStmt.variable)
  return variable_;
}
inline void AssignStmt::set_allocated_variable(::Pasc::Identifier* variable) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete variable_;
  }
  if (variable) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      variable = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, variable, submessage_arena);
    }
    
  } else {
    
  }
  variable_ = variable;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStmt.variable)
}

// .Pasc.Expression value = 2;
inline bool AssignStmt::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void AssignStmt::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::Pasc::Expression& AssignStmt::_internal_value() const {
  return *value_;
}
inline const ::Pasc::Expression& AssignStmt::value() const {
  const ::Pasc::Expression* p = value_;
  // @@protoc_insertion_point(field_get:Pasc.AssignStmt.value)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Expression*>(
      &::Pasc::_Expression_default_instance_);
}
inline ::Pasc::Expression* AssignStmt::release_value() {
  // @@protoc_insertion_point(field_release:Pasc.AssignStmt.value)
  
  ::Pasc::Expression* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::Pasc::Expression* AssignStmt::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Expression>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.AssignStmt.value)
  return value_;
}
inline void AssignStmt::set_allocated_value(::Pasc::Expression* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:Pasc.AssignStmt.value)
}

// -------------------------------------------------------------------

// ProcedureStmt

// .Pasc.Identifier name = 1;
inline bool ProcedureStmt::has_name() const {
  return this != internal_default_instance() && name_ != NULL;
}
inline void ProcedureStmt::clear_name() {
  if (GetArenaNoVirtual() == NULL && name_ != NULL) {
    delete name_;
  }
  name_ = NULL;
}
inline const ::Pasc::Identifier& ProcedureStmt::_internal_name() const {
  return *name_;
}
inline const ::Pasc::Identifier& ProcedureStmt::name() const {
  const ::Pasc::Identifier* p = name_;
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStmt.name)
  return p != NULL ? *p : *reinterpret_cast<const ::Pasc::Identifier*>(
      &::Pasc::_Identifier_default_instance_);
}
inline ::Pasc::Identifier* ProcedureStmt::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.ProcedureStmt.name)
  
  ::Pasc::Identifier* temp = name_;
  name_ = NULL;
  return temp;
}
inline ::Pasc::Identifier* ProcedureStmt::mutable_name() {
  
  if (name_ == NULL) {
    auto* p = CreateMaybeMessage<::Pasc::Identifier>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStmt.name)
  return name_;
}
inline void ProcedureStmt::set_allocated_name(::Pasc::Identifier* name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete name_;
  }
  if (name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    
  } else {
    
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:Pasc.ProcedureStmt.name)
}

// repeated .Pasc.Expression args = 2;
inline int ProcedureStmt::args_size() const {
  return args_.size();
}
inline void ProcedureStmt::clear_args() {
  args_.Clear();
}
inline ::Pasc::Expression* ProcedureStmt::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:Pasc.ProcedureStmt.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >*
ProcedureStmt::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:Pasc.ProcedureStmt.args)
  return &args_;
}
inline const ::Pasc::Expression& ProcedureStmt::args(int index) const {
  // @@protoc_insertion_point(field_get:Pasc.ProcedureStmt.args)
  return args_.Get(index);
}
inline ::Pasc::Expression* ProcedureStmt::add_args() {
  // @@protoc_insertion_point(field_add:Pasc.ProcedureStmt.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pasc::Expression >&
ProcedureStmt::args() const {
  // @@protoc_insertion_point(field_list:Pasc.ProcedureStmt.args)
  return args_;
}

// -------------------------------------------------------------------

// Statement

// .Pasc.TokenKind kind = 1;
inline void Statement::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::TokenKind Statement::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.kind)
  return static_cast< ::Pasc::TokenKind >(kind_);
}
inline void Statement::set_kind(::Pasc::TokenKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Statement.kind)
}

// .Pasc.AssignStmt assignStmt = 2;
inline bool Statement::has_assignstmt() const {
  return stmt_case() == kAssignStmt;
}
inline void Statement::set_has_assignstmt() {
  _oneof_case_[0] = kAssignStmt;
}
inline void Statement::clear_assignstmt() {
  if (has_assignstmt()) {
    delete stmt_.assignstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::AssignStmt& Statement::_internal_assignstmt() const {
  return *stmt_.assignstmt_;
}
inline ::Pasc::AssignStmt* Statement::release_assignstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.assignStmt)
  if (has_assignstmt()) {
    clear_has_stmt();
      ::Pasc::AssignStmt* temp = stmt_.assignstmt_;
    stmt_.assignstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::AssignStmt& Statement::assignstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.assignStmt)
  return has_assignstmt()
      ? *stmt_.assignstmt_
      : *reinterpret_cast< ::Pasc::AssignStmt*>(&::Pasc::_AssignStmt_default_instance_);
}
inline ::Pasc::AssignStmt* Statement::mutable_assignstmt() {
  if (!has_assignstmt()) {
    clear_stmt();
    set_has_assignstmt();
    stmt_.assignstmt_ = CreateMaybeMessage< ::Pasc::AssignStmt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.assignStmt)
  return stmt_.assignstmt_;
}

// .Pasc.ProcedureStmt procStmt = 3;
inline bool Statement::has_procstmt() const {
  return stmt_case() == kProcStmt;
}
inline void Statement::set_has_procstmt() {
  _oneof_case_[0] = kProcStmt;
}
inline void Statement::clear_procstmt() {
  if (has_procstmt()) {
    delete stmt_.procstmt_;
    clear_has_stmt();
  }
}
inline const ::Pasc::ProcedureStmt& Statement::_internal_procstmt() const {
  return *stmt_.procstmt_;
}
inline ::Pasc::ProcedureStmt* Statement::release_procstmt() {
  // @@protoc_insertion_point(field_release:Pasc.Statement.procStmt)
  if (has_procstmt()) {
    clear_has_stmt();
      ::Pasc::ProcedureStmt* temp = stmt_.procstmt_;
    stmt_.procstmt_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::ProcedureStmt& Statement::procstmt() const {
  // @@protoc_insertion_point(field_get:Pasc.Statement.procStmt)
  return has_procstmt()
      ? *stmt_.procstmt_
      : *reinterpret_cast< ::Pasc::ProcedureStmt*>(&::Pasc::_ProcedureStmt_default_instance_);
}
inline ::Pasc::ProcedureStmt* Statement::mutable_procstmt() {
  if (!has_procstmt()) {
    clear_stmt();
    set_has_procstmt();
    stmt_.procstmt_ = CreateMaybeMessage< ::Pasc::ProcedureStmt >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Statement.procStmt)
  return stmt_.procstmt_;
}

inline bool Statement::has_stmt() const {
  return stmt_case() != STMT_NOT_SET;
}
inline void Statement::clear_has_stmt() {
  _oneof_case_[0] = STMT_NOT_SET;
}
inline Statement::StmtCase Statement::stmt_case() const {
  return Statement::StmtCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Expression

// .Pasc.TokenKind kind = 1;
inline void Expression::clear_kind() {
  kind_ = 0;
}
inline ::Pasc::TokenKind Expression::kind() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.kind)
  return static_cast< ::Pasc::TokenKind >(kind_);
}
inline void Expression::set_kind(::Pasc::TokenKind value) {
  
  kind_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Expression.kind)
}

// .Pasc.Identifier id = 2;
inline bool Expression::has_id() const {
  return expr_case() == kId;
}
inline void Expression::set_has_id() {
  _oneof_case_[0] = kId;
}
inline void Expression::clear_id() {
  if (has_id()) {
    delete expr_.id_;
    clear_has_expr();
  }
}
inline const ::Pasc::Identifier& Expression::_internal_id() const {
  return *expr_.id_;
}
inline ::Pasc::Identifier* Expression::release_id() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.id)
  if (has_id()) {
    clear_has_expr();
      ::Pasc::Identifier* temp = expr_.id_;
    expr_.id_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Identifier& Expression::id() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.id)
  return has_id()
      ? *expr_.id_
      : *reinterpret_cast< ::Pasc::Identifier*>(&::Pasc::_Identifier_default_instance_);
}
inline ::Pasc::Identifier* Expression::mutable_id() {
  if (!has_id()) {
    clear_expr();
    set_has_id();
    expr_.id_ = CreateMaybeMessage< ::Pasc::Identifier >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.id)
  return expr_.id_;
}

// .Pasc.UIntLiteral uint = 3;
inline bool Expression::has_uint() const {
  return expr_case() == kUint;
}
inline void Expression::set_has_uint() {
  _oneof_case_[0] = kUint;
}
inline void Expression::clear_uint() {
  if (has_uint()) {
    delete expr_.uint_;
    clear_has_expr();
  }
}
inline const ::Pasc::UIntLiteral& Expression::_internal_uint() const {
  return *expr_.uint_;
}
inline ::Pasc::UIntLiteral* Expression::release_uint() {
  // @@protoc_insertion_point(field_release:Pasc.Expression.uint)
  if (has_uint()) {
    clear_has_expr();
      ::Pasc::UIntLiteral* temp = expr_.uint_;
    expr_.uint_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::UIntLiteral& Expression::uint() const {
  // @@protoc_insertion_point(field_get:Pasc.Expression.uint)
  return has_uint()
      ? *expr_.uint_
      : *reinterpret_cast< ::Pasc::UIntLiteral*>(&::Pasc::_UIntLiteral_default_instance_);
}
inline ::Pasc::UIntLiteral* Expression::mutable_uint() {
  if (!has_uint()) {
    clear_expr();
    set_has_uint();
    expr_.uint_ = CreateMaybeMessage< ::Pasc::UIntLiteral >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Expression.uint)
  return expr_.uint_;
}

inline bool Expression::has_expr() const {
  return expr_case() != EXPR_NOT_SET;
}
inline void Expression::clear_has_expr() {
  _oneof_case_[0] = EXPR_NOT_SET;
}
inline Expression::ExprCase Expression::expr_case() const {
  return Expression::ExprCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Identifier

// string name = 2;
inline void Identifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Identifier.name)
  return name_.GetNoArena();
}
inline void Identifier::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Identifier.name)
}
#if LANG_CXX11
inline void Identifier::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Identifier.name)
}
#endif
inline void Identifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Identifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Identifier.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Identifier.name)
}

// -------------------------------------------------------------------

// UIntLiteral

// int32 value = 1;
inline void UIntLiteral::clear_value() {
  value_ = 0;
}
inline ::google::protobuf::int32 UIntLiteral::value() const {
  // @@protoc_insertion_point(field_get:Pasc.UIntLiteral.value)
  return value_;
}
inline void UIntLiteral::set_value(::google::protobuf::int32 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Pasc.UIntLiteral.value)
}

// -------------------------------------------------------------------

// Type

// .Pasc.TypeKind tk = 1;
inline void Type::clear_tk() {
  tk_ = 0;
}
inline ::Pasc::TypeKind Type::tk() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.tk)
  return static_cast< ::Pasc::TypeKind >(tk_);
}
inline void Type::set_tk(::Pasc::TypeKind value) {
  
  tk_ = value;
  // @@protoc_insertion_point(field_set:Pasc.Type.tk)
}

// .Pasc.Integer int = 2;
inline bool Type::has_int_() const {
  return type_case() == kInt;
}
inline void Type::set_has_int_() {
  _oneof_case_[0] = kInt;
}
inline void Type::clear_int_() {
  if (has_int_()) {
    delete type_.int__;
    clear_has_type();
  }
}
inline const ::Pasc::Integer& Type::_internal_int_() const {
  return *type_.int__;
}
inline ::Pasc::Integer* Type::release_int_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.int)
  if (has_int_()) {
    clear_has_type();
      ::Pasc::Integer* temp = type_.int__;
    type_.int__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Integer& Type::int_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.int)
  return has_int_()
      ? *type_.int__
      : *reinterpret_cast< ::Pasc::Integer*>(&::Pasc::_Integer_default_instance_);
}
inline ::Pasc::Integer* Type::mutable_int_() {
  if (!has_int_()) {
    clear_type();
    set_has_int_();
    type_.int__ = CreateMaybeMessage< ::Pasc::Integer >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.int)
  return type_.int__;
}

// .Pasc.Real real = 3;
inline bool Type::has_real() const {
  return type_case() == kReal;
}
inline void Type::set_has_real() {
  _oneof_case_[0] = kReal;
}
inline void Type::clear_real() {
  if (has_real()) {
    delete type_.real_;
    clear_has_type();
  }
}
inline const ::Pasc::Real& Type::_internal_real() const {
  return *type_.real_;
}
inline ::Pasc::Real* Type::release_real() {
  // @@protoc_insertion_point(field_release:Pasc.Type.real)
  if (has_real()) {
    clear_has_type();
      ::Pasc::Real* temp = type_.real_;
    type_.real_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Real& Type::real() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.real)
  return has_real()
      ? *type_.real_
      : *reinterpret_cast< ::Pasc::Real*>(&::Pasc::_Real_default_instance_);
}
inline ::Pasc::Real* Type::mutable_real() {
  if (!has_real()) {
    clear_type();
    set_has_real();
    type_.real_ = CreateMaybeMessage< ::Pasc::Real >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.real)
  return type_.real_;
}

// .Pasc.Boolean bool = 4;
inline bool Type::has_bool_() const {
  return type_case() == kBool;
}
inline void Type::set_has_bool_() {
  _oneof_case_[0] = kBool;
}
inline void Type::clear_bool_() {
  if (has_bool_()) {
    delete type_.bool__;
    clear_has_type();
  }
}
inline const ::Pasc::Boolean& Type::_internal_bool_() const {
  return *type_.bool__;
}
inline ::Pasc::Boolean* Type::release_bool_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.bool)
  if (has_bool_()) {
    clear_has_type();
      ::Pasc::Boolean* temp = type_.bool__;
    type_.bool__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Boolean& Type::bool_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.bool)
  return has_bool_()
      ? *type_.bool__
      : *reinterpret_cast< ::Pasc::Boolean*>(&::Pasc::_Boolean_default_instance_);
}
inline ::Pasc::Boolean* Type::mutable_bool_() {
  if (!has_bool_()) {
    clear_type();
    set_has_bool_();
    type_.bool__ = CreateMaybeMessage< ::Pasc::Boolean >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.bool)
  return type_.bool__;
}

// .Pasc.Char char = 5;
inline bool Type::has_char_() const {
  return type_case() == kChar;
}
inline void Type::set_has_char_() {
  _oneof_case_[0] = kChar;
}
inline void Type::clear_char_() {
  if (has_char_()) {
    delete type_.char__;
    clear_has_type();
  }
}
inline const ::Pasc::Char& Type::_internal_char_() const {
  return *type_.char__;
}
inline ::Pasc::Char* Type::release_char_() {
  // @@protoc_insertion_point(field_release:Pasc.Type.char)
  if (has_char_()) {
    clear_has_type();
      ::Pasc::Char* temp = type_.char__;
    type_.char__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::Pasc::Char& Type::char_() const {
  // @@protoc_insertion_point(field_get:Pasc.Type.char)
  return has_char_()
      ? *type_.char__
      : *reinterpret_cast< ::Pasc::Char*>(&::Pasc::_Char_default_instance_);
}
inline ::Pasc::Char* Type::mutable_char_() {
  if (!has_char_()) {
    clear_type();
    set_has_char_();
    type_.char__ = CreateMaybeMessage< ::Pasc::Char >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Pasc.Type.char)
  return type_.char__;
}

inline bool Type::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Type::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Type::TypeCase Type::type_case() const {
  return Type::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Integer

// string name = 1;
inline void Integer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Integer::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Integer.name)
  return name_.GetNoArena();
}
inline void Integer::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Integer.name)
}
#if LANG_CXX11
inline void Integer::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Integer.name)
}
#endif
inline void Integer::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Integer.name)
}
inline void Integer::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Integer.name)
}
inline ::std::string* Integer::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Integer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Integer::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Integer.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Integer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Integer.name)
}

// -------------------------------------------------------------------

// Boolean

// string name = 1;
inline void Boolean::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Boolean::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Boolean.name)
  return name_.GetNoArena();
}
inline void Boolean::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Boolean.name)
}
#if LANG_CXX11
inline void Boolean::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Boolean.name)
}
#endif
inline void Boolean::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Boolean.name)
}
inline void Boolean::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Boolean.name)
}
inline ::std::string* Boolean::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Boolean.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Boolean::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Boolean.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Boolean::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Boolean.name)
}

// -------------------------------------------------------------------

// Real

// string name = 1;
inline void Real::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Real::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Real.name)
  return name_.GetNoArena();
}
inline void Real::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Real.name)
}
#if LANG_CXX11
inline void Real::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Real.name)
}
#endif
inline void Real::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Real.name)
}
inline void Real::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Real.name)
}
inline ::std::string* Real::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Real.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Real::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Real.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Real::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Real.name)
}

// -------------------------------------------------------------------

// Char

// string name = 1;
inline void Char::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Char::name() const {
  // @@protoc_insertion_point(field_get:Pasc.Char.name)
  return name_.GetNoArena();
}
inline void Char::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Pasc.Char.name)
}
#if LANG_CXX11
inline void Char::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Pasc.Char.name)
}
#endif
inline void Char::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Pasc.Char.name)
}
inline void Char::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Pasc.Char.name)
}
inline ::std::string* Char::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Pasc.Char.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Char::release_name() {
  // @@protoc_insertion_point(field_release:Pasc.Char.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Char::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Pasc.Char.name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Pasc

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Pasc::TokenKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::TokenKind>() {
  return ::Pasc::TokenKind_descriptor();
}
template <> struct is_proto_enum< ::Pasc::TypeKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Pasc::TypeKind>() {
  return ::Pasc::TypeKind_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_program_2eproto
